{
  "paths" : {
    "/nodes/:node/bridges/:id/:operation" : {
      
    },
    "/bridges_probe" : {
      
    },
    "/bridges/:id/metrics/reset" : {
      
    },
    "/bridges/:id/metrics" : {
      "get" : {
        "type" : "object",
        "properties" : {
          "metrics" : {
            "$ref" : "#/components/schemas/bridge.metrics",
            "summary" : "Bridge Metrics",
            "label" : "Bridge Metrics",
            "description" : "Bridge metrics."
          },
          "node_metrics" : {
            "type" : "array",
            "summary" : "Node Metrics",
            "label" : "Node Metrics",
            "items" : {
              "$ref" : "#/components/schemas/bridge.node_metrics"
            },
            "description" : "Node metrics."
          }
        }
      }
    },
    "/bridges/:id/enable/:enable" : {
      
    },
    "/bridges/:id/:operation" : {
      
    },
    "/bridges/:id" : {
      "put" : {
        "oneOf" : [
          {
            "$ref" : "#/components/schemas/bridge_sqlserver.get"
          },
          {
            "$ref" : "#/components/schemas/bridge_cassa.get"
          },
          {
            "$ref" : "#/components/schemas/bridge_rocketmq.get"
          },
          {
            "$ref" : "#/components/schemas/bridge_dynamo.get"
          },
          {
            "$ref" : "#/components/schemas/bridge_clickhouse.get"
          },
          {
            "$ref" : "#/components/schemas/bridge_tdengine.get"
          },
          {
            "$ref" : "#/components/schemas/bridge_matrix.get"
          },
          {
            "$ref" : "#/components/schemas/bridge_timescale.get"
          },
          {
            "$ref" : "#/components/schemas/bridge_redis.get_cluster"
          },
          {
            "$ref" : "#/components/schemas/bridge_redis.get_sentinel"
          },
          {
            "$ref" : "#/components/schemas/bridge_redis.get_single"
          },
          {
            "$ref" : "#/components/schemas/bridge_influxdb.get_api_v2"
          },
          {
            "$ref" : "#/components/schemas/bridge_influxdb.get_api_v1"
          },
          {
            "$ref" : "#/components/schemas/bridge_hstreamdb.get"
          },
          {
            "$ref" : "#/components/schemas/bridge_mongodb.get_single"
          },
          {
            "$ref" : "#/components/schemas/bridge_mongodb.get_sharded"
          },
          {
            "$ref" : "#/components/schemas/bridge_mongodb.get_rs"
          },
          {
            "$ref" : "#/components/schemas/bridge_pgsql.get"
          },
          {
            "$ref" : "#/components/schemas/bridge_mysql.get"
          },
          {
            "$ref" : "#/components/schemas/bridge_kafka.get_producer"
          },
          {
            "$ref" : "#/components/schemas/bridge_kafka.get_consumer"
          },
          {
            "$ref" : "#/components/schemas/bridge_gcp_pubsub.get"
          },
          {
            "$ref" : "#/components/schemas/bridge_mqtt.get"
          },
          {
            "$ref" : "#/components/schemas/bridge_webhook.get"
          }
        ]
      },
      "get" : {
        "oneOf" : [
          {
            "$ref" : "#/components/schemas/bridge_sqlserver.get"
          },
          {
            "$ref" : "#/components/schemas/bridge_cassa.get"
          },
          {
            "$ref" : "#/components/schemas/bridge_rocketmq.get"
          },
          {
            "$ref" : "#/components/schemas/bridge_dynamo.get"
          },
          {
            "$ref" : "#/components/schemas/bridge_clickhouse.get"
          },
          {
            "$ref" : "#/components/schemas/bridge_tdengine.get"
          },
          {
            "$ref" : "#/components/schemas/bridge_matrix.get"
          },
          {
            "$ref" : "#/components/schemas/bridge_timescale.get"
          },
          {
            "$ref" : "#/components/schemas/bridge_redis.get_cluster"
          },
          {
            "$ref" : "#/components/schemas/bridge_redis.get_sentinel"
          },
          {
            "$ref" : "#/components/schemas/bridge_redis.get_single"
          },
          {
            "$ref" : "#/components/schemas/bridge_influxdb.get_api_v2"
          },
          {
            "$ref" : "#/components/schemas/bridge_influxdb.get_api_v1"
          },
          {
            "$ref" : "#/components/schemas/bridge_hstreamdb.get"
          },
          {
            "$ref" : "#/components/schemas/bridge_mongodb.get_single"
          },
          {
            "$ref" : "#/components/schemas/bridge_mongodb.get_sharded"
          },
          {
            "$ref" : "#/components/schemas/bridge_mongodb.get_rs"
          },
          {
            "$ref" : "#/components/schemas/bridge_pgsql.get"
          },
          {
            "$ref" : "#/components/schemas/bridge_mysql.get"
          },
          {
            "$ref" : "#/components/schemas/bridge_kafka.get_producer"
          },
          {
            "$ref" : "#/components/schemas/bridge_kafka.get_consumer"
          },
          {
            "$ref" : "#/components/schemas/bridge_gcp_pubsub.get"
          },
          {
            "$ref" : "#/components/schemas/bridge_mqtt.get"
          },
          {
            "$ref" : "#/components/schemas/bridge_webhook.get"
          }
        ]
      }
    },
    "/bridges" : {
      "get" : {
        "type" : "array",
        "items" : {
          "oneOf" : [
            {
              "$ref" : "#/components/schemas/bridge_sqlserver.get"
            },
            {
              "$ref" : "#/components/schemas/bridge_cassa.get"
            },
            {
              "$ref" : "#/components/schemas/bridge_rocketmq.get"
            },
            {
              "$ref" : "#/components/schemas/bridge_dynamo.get"
            },
            {
              "$ref" : "#/components/schemas/bridge_clickhouse.get"
            },
            {
              "$ref" : "#/components/schemas/bridge_tdengine.get"
            },
            {
              "$ref" : "#/components/schemas/bridge_matrix.get"
            },
            {
              "$ref" : "#/components/schemas/bridge_timescale.get"
            },
            {
              "$ref" : "#/components/schemas/bridge_redis.get_cluster"
            },
            {
              "$ref" : "#/components/schemas/bridge_redis.get_sentinel"
            },
            {
              "$ref" : "#/components/schemas/bridge_redis.get_single"
            },
            {
              "$ref" : "#/components/schemas/bridge_influxdb.get_api_v2"
            },
            {
              "$ref" : "#/components/schemas/bridge_influxdb.get_api_v1"
            },
            {
              "$ref" : "#/components/schemas/bridge_hstreamdb.get"
            },
            {
              "$ref" : "#/components/schemas/bridge_mongodb.get_single"
            },
            {
              "$ref" : "#/components/schemas/bridge_mongodb.get_sharded"
            },
            {
              "$ref" : "#/components/schemas/bridge_mongodb.get_rs"
            },
            {
              "$ref" : "#/components/schemas/bridge_pgsql.get"
            },
            {
              "$ref" : "#/components/schemas/bridge_mysql.get"
            },
            {
              "$ref" : "#/components/schemas/bridge_kafka.get_producer"
            },
            {
              "$ref" : "#/components/schemas/bridge_kafka.get_consumer"
            },
            {
              "$ref" : "#/components/schemas/bridge_gcp_pubsub.get"
            },
            {
              "$ref" : "#/components/schemas/bridge_mqtt.get"
            },
            {
              "$ref" : "#/components/schemas/bridge_webhook.get"
            }
          ]
        }
      }
    }
  },
  "info" : {
    "version" : "0.1.0",
    "title" : "EMQX Data Bridge API Schema"
  },
  "components" : {
    "schemas" : {
      "bridge_cassa.get" : {
        "type" : "object",
        "properties" : {
          "status" : {
            "type" : "enum",
            "symbols" : [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "summary" : "Bridge Status",
            "label" : "Bridge Status",
            "description" : "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason" : {
            "type" : "string",
            "summary" : "Failure reason",
            "label" : "Failure reason",
            "example" : "Connection refused",
            "description" : "This is the reason given in case a bridge is failing to connect."
          },
          "node_status" : {
            "type" : "array",
            "summary" : "Node Status",
            "label" : "Node Status",
            "items" : {
              "$ref" : "#/components/schemas/bridge.node_status"
            },
            "description" : "Node status."
          },
          "type" : {
            "type" : "enum",
            "symbols" : [
              "cassandra"
            ],
            "summary" : "Bridge Type",
            "label" : "Bridge Type",
            "description" : "The Bridge Type"
          },
          "name" : {
            "type" : "string",
            "summary" : "Bridge Name",
            "label" : "Bridge Name",
            "description" : "Bridge name."
          },
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "cql" : {
            "type" : "string",
            "summary" : "CQL Template",
            "label" : "CQL Template",
            "format" : "sql",
            "description" : "CQL Template",
            "default" : "insert into mqtt_msg(topic, msgid, sender, qos, payload, arrived, retain) values (${topic}, ${id}, ${clientid}, ${qos}, ${payload}, ${timestamp}, ${flags.retain})"
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "The MQTT topic filter to be forwarded to Cassandra. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/resource_schema.creation_opts",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "servers" : {
            "type" : "string",
            "summary" : "Servers",
            "label" : "Servers",
            "description" : "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port][,Host2:Port]`.<br/><br/>The Cassandra default port 9042 is used if `[:Port]` is not specified."
          },
          "keyspace" : {
            "type" : "string",
            "summary" : "Keyspace",
            "label" : "Keyspace",
            "description" : "Keyspace name to connect to."
          },
          "pool_size" : {
            "type" : "string",
            "summary" : "Connection Pool Size",
            "label" : "Connection Pool Size",
            "description" : "Size of the connection pool towards the bridge target service.",
            "default" : 8
          },
          "username" : {
            "type" : "string",
            "summary" : "Username",
            "label" : "Username",
            "description" : "EMQX's username in the external database."
          },
          "password" : {
            "type" : "string",
            "summary" : "Password",
            "label" : "Password",
            "format" : "password",
            "description" : "EMQX's password in the external database."
          },
          "auto_reconnect" : {
            "type" : "boolean",
            "summary" : "Deprecated. Auto Reconnect Database",
            "label" : "Deprecated. Auto Reconnect Database",
            "description" : "Deprecated. Enable automatic reconnect to the database.",
            "deprecated" : true,
            "default" : true
          },
          "ssl" : {
            "$ref" : "#/components/schemas/broker.ssl_client_opts",
            "summary" : "Enable SSL",
            "label" : "Enable SSL",
            "description" : "SSL connection settings.",
            "default" : {
              "enable" : false
            }
          }
        },
        "required" : [
          "keyspace",
          "name",
          "servers",
          "type"
        ]
      },
      "bridge_redis.post_sentinel" : {
        "type" : "object",
        "properties" : {
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "The MQTT topic filter to be forwarded to Redis. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "command_template" : {
            "type" : "array",
            "summary" : "Redis Command Template",
            "label" : "Redis Command Template",
            "items" : {
              "type" : "string"
            },
            "description" : "Redis command template used to export messages. Each list element stands for a command name or its argument.<br/>For example, to push payloads in a Redis list by key `msgs`, the elements should be the following:<br/>`rpush`, `msgs`, `${payload}`."
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/bridge_redis.creation_opts_redis_sentinel",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "servers" : {
            "type" : "string",
            "summary" : "Servers",
            "label" : "Servers",
            "description" : "A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`<br/>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.<br/>A host entry has the following form: `Host[:Port]`.<br/>The Redis default port 6379 is used if `[:Port]` is not specified."
          },
          "redis_type" : {
            "type" : "enum",
            "symbols" : [
              "sentinel"
            ],
            "summary" : "Sentinel Mode",
            "label" : "Sentinel Mode",
            "description" : "Sentinel mode. Must be set to 'sentinel' when Redis server is running in sentinel mode.",
            "default" : "sentinel"
          },
          "sentinel" : {
            "type" : "string",
            "summary" : "Cluster Name",
            "label" : "Cluster Name",
            "description" : "The cluster name in Redis sentinel mode."
          },
          "pool_size" : {
            "type" : "string",
            "summary" : "Connection Pool Size",
            "label" : "Connection Pool Size",
            "description" : "Size of the connection pool towards the bridge target service.",
            "default" : 8
          },
          "password" : {
            "type" : "string",
            "summary" : "Password",
            "label" : "Password",
            "format" : "password",
            "description" : "EMQX's password in the external database."
          },
          "database" : {
            "type" : "number",
            "summary" : "Database ID",
            "label" : "Database ID",
            "description" : "Redis database ID.",
            "default" : 0
          },
          "auto_reconnect" : {
            "type" : "boolean",
            "summary" : "Deprecated. Auto Reconnect Database",
            "label" : "Deprecated. Auto Reconnect Database",
            "description" : "Deprecated. Enable automatic reconnect to the database.",
            "deprecated" : true,
            "default" : true
          },
          "ssl" : {
            "$ref" : "#/components/schemas/broker.ssl_client_opts",
            "summary" : "Enable SSL",
            "label" : "Enable SSL",
            "description" : "SSL connection settings.",
            "default" : {
              "enable" : false
            }
          },
          "type" : {
            "type" : "enum",
            "symbols" : [
              "redis_sentinel"
            ],
            "summary" : "Bridge Type",
            "label" : "Bridge Type",
            "description" : "The Bridge Type"
          },
          "name" : {
            "type" : "string",
            "summary" : "Bridge Name",
            "label" : "Bridge Name",
            "description" : "Bridge name, used as a human-readable description of the bridge."
          }
        },
        "required" : [
          "command_template",
          "name",
          "sentinel",
          "servers",
          "type"
        ]
      },
      "bridge_kafka.producer_buffer" : {
        "type" : "object",
        "properties" : {
          "mode" : {
            "type" : "enum",
            "symbols" : [
              "memory",
              "disk",
              "hybrid"
            ],
            "summary" : "Buffer Mode",
            "label" : "Buffer Mode",
            "description" : "Message buffer mode.<br/><br/><code>memory</code>: Buffer all messages in memory. The messages will be lost in case of EMQX node restart<br/><code>disk</code>: Buffer all messages on disk. The messages on disk are able to survive EMQX node restart.<br/><code>hybrid</code>: Buffer message in memory first, when up to certain limit (see <code>segment_bytes</code> config for more information), then start offloading messages to disk, Like <code>memory</code> mode, the messages will be lost in case of EMQX node restart.",
            "default" : "memory"
          },
          "per_partition_limit" : {
            "type" : "byteSize",
            "summary" : "Per-partition Buffer Limit",
            "label" : "Per-partition Buffer Limit",
            "description" : "Number of bytes allowed to buffer for each Kafka partition. When this limit is exceeded, old messages will be dropped in a trade for credits for new messages to be buffered.",
            "default" : "2GB"
          },
          "segment_bytes" : {
            "type" : "byteSize",
            "summary" : "Segment File Bytes",
            "label" : "Segment File Bytes",
            "description" : "Applicable when buffer mode is set to <code>disk</code> or <code>hybrid</code>.<br/>This value is to specify the size of each on-disk buffer file.",
            "default" : "100MB"
          },
          "memory_overload_protection" : {
            "type" : "boolean",
            "summary" : "Memory Overload Protection",
            "label" : "Memory Overload Protection",
            "description" : "Applicable when buffer mode is set to <code>memory</code><br/>EMQX will drop old buffered messages under high memory pressure. The high memory threshold is defined in config <code>sysmon.os.sysmem_high_watermark</code>. NOTE: This config only works on Linux.",
            "default" : false
          }
        }
      },
      "bridge_tdengine.post" : {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "enum",
            "symbols" : [
              "tdengine"
            ],
            "summary" : "Bridge Type",
            "label" : "Bridge Type",
            "description" : "The Bridge Type"
          },
          "name" : {
            "type" : "string",
            "summary" : "Bridge Name",
            "label" : "Bridge Name",
            "description" : "Bridge name."
          },
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "sql" : {
            "type" : "string",
            "summary" : "SQL Template",
            "label" : "SQL Template",
            "format" : "sql",
            "description" : "SQL Template",
            "default" : "insert into t_mqtt_msg(ts, msgid, mqtt_topic, qos, payload, arrived) values (${ts}, ${id}, ${topic}, ${qos}, ${payload}, ${timestamp})"
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "The MQTT topic filter to be forwarded to TDengine. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/resource_schema.creation_opts",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "server" : {
            "type" : "string",
            "summary" : "Server Host",
            "label" : "Server Host",
            "description" : "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The TDengine default port 6041 is used if `[:Port]` is not specified."
          },
          "database" : {
            "type" : "string",
            "summary" : "Database Name",
            "label" : "Database Name",
            "description" : "Database name."
          },
          "pool_size" : {
            "type" : "string",
            "summary" : "Connection Pool Size",
            "label" : "Connection Pool Size",
            "description" : "Size of the connection pool towards the bridge target service.",
            "default" : 8
          },
          "username" : {
            "type" : "string",
            "summary" : "Username",
            "label" : "Username",
            "description" : "EMQX's username in the external database.",
            "default" : "root"
          },
          "password" : {
            "type" : "string",
            "summary" : "Password",
            "label" : "Password",
            "format" : "password",
            "description" : "EMQX's password in the external database."
          },
          "auto_reconnect" : {
            "type" : "boolean",
            "summary" : "Deprecated. Auto Reconnect Database",
            "label" : "Deprecated. Auto Reconnect Database",
            "description" : "Deprecated. Enable automatic reconnect to the database.",
            "deprecated" : true,
            "default" : true
          }
        },
        "required" : [
          "database",
          "name",
          "password",
          "server",
          "type"
        ]
      },
      "bridge_influxdb.post_api_v1" : {
        "type" : "object",
        "properties" : {
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "The MQTT topic filter to be forwarded to the InfluxDB. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "write_syntax" : {
            "type" : "string",
            "summary" : "Write Syntax",
            "label" : "Write Syntax",
            "format" : "sql",
            "description" : "Conf of InfluxDB line protocol to write data points. It is a text-based format that provides the measurement, tag set, field set, and timestamp of a data point, and placeholder supported.<br/>See also [InfluxDB 2.3 Line Protocol](https://docs.influxdata.com/influxdb/v2.3/reference/syntax/line-protocol/) and<br/>[InfluxDB 1.8 Line Protocol](https://docs.influxdata.com/influxdb/v1.8/write_protocols/line_protocol_tutorial/) </br><br/>TLDR:</br><br/>```<br/><measurement>[,<tag_key>=<tag_value>[,<tag_key>=<tag_value>]] <field_key>=<field_value>[,<field_key>=<field_value>] [<timestamp>]<br/>```<br/>Please note that a placeholder for an integer value must be annotated with a suffix `i`. For example `${payload.int_value}i`."
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/resource_schema.creation_opts",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "server" : {
            "type" : "string",
            "summary" : "Server Host",
            "label" : "Server Host",
            "description" : "The IPv4 or IPv6 address or the hostname to connect to.</br><br/>A host entry has the following form: `Host[:Port]`.</br><br/>The InfluxDB default port 8086 is used if `[:Port]` is not specified.",
            "default" : "127.0.0.1:8086"
          },
          "precision" : {
            "type" : "enum",
            "symbols" : [
              "ns",
              "us",
              "ms",
              "s"
            ],
            "summary" : "Time Precision",
            "label" : "Time Precision",
            "description" : "InfluxDB time precision.",
            "default" : "ms"
          },
          "database" : {
            "type" : "string",
            "summary" : "Database",
            "label" : "Database",
            "description" : "InfluxDB database."
          },
          "username" : {
            "type" : "string",
            "summary" : "Username",
            "label" : "Username",
            "description" : "InfluxDB username."
          },
          "password" : {
            "type" : "string",
            "summary" : "Password",
            "label" : "Password",
            "format" : "password",
            "description" : "InfluxDB password."
          },
          "ssl" : {
            "$ref" : "#/components/schemas/broker.ssl_client_opts",
            "summary" : "Enable SSL",
            "label" : "Enable SSL",
            "description" : "SSL connection settings.",
            "default" : {
              "enable" : false
            }
          },
          "type" : {
            "type" : "enum",
            "symbols" : [
              "influxdb_api_v1"
            ],
            "summary" : "Bridge Type",
            "label" : "Bridge Type",
            "description" : "The Bridge Type."
          },
          "name" : {
            "type" : "string",
            "summary" : "Bridge Name",
            "label" : "Bridge Name",
            "description" : "Bridge name."
          }
        },
        "required" : [
          "database",
          "name",
          "type",
          "write_syntax"
        ]
      },
      "connector-mqtt.ingress" : {
        "type" : "object",
        "properties" : {
          "remote" : {
            "$ref" : "#/components/schemas/connector-mqtt.ingress_remote",
            "summary" : "Remote Configs",
            "label" : "Remote Configs",
            "description" : "The configs about subscribing to the remote broker."
          },
          "local" : {
            "$ref" : "#/components/schemas/connector-mqtt.ingress_local",
            "summary" : "Local Configs",
            "label" : "Local Configs",
            "description" : "The configs about sending message to the local broker."
          }
        }
      },
      "bridge_influxdb.get_api_v2" : {
        "type" : "object",
        "properties" : {
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "The MQTT topic filter to be forwarded to the InfluxDB. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "write_syntax" : {
            "type" : "string",
            "summary" : "Write Syntax",
            "label" : "Write Syntax",
            "format" : "sql",
            "description" : "Conf of InfluxDB line protocol to write data points. It is a text-based format that provides the measurement, tag set, field set, and timestamp of a data point, and placeholder supported.<br/>See also [InfluxDB 2.3 Line Protocol](https://docs.influxdata.com/influxdb/v2.3/reference/syntax/line-protocol/) and<br/>[InfluxDB 1.8 Line Protocol](https://docs.influxdata.com/influxdb/v1.8/write_protocols/line_protocol_tutorial/) </br><br/>TLDR:</br><br/>```<br/><measurement>[,<tag_key>=<tag_value>[,<tag_key>=<tag_value>]] <field_key>=<field_value>[,<field_key>=<field_value>] [<timestamp>]<br/>```<br/>Please note that a placeholder for an integer value must be annotated with a suffix `i`. For example `${payload.int_value}i`."
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/resource_schema.creation_opts",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "server" : {
            "type" : "string",
            "summary" : "Server Host",
            "label" : "Server Host",
            "description" : "The IPv4 or IPv6 address or the hostname to connect to.</br><br/>A host entry has the following form: `Host[:Port]`.</br><br/>The InfluxDB default port 8086 is used if `[:Port]` is not specified.",
            "default" : "127.0.0.1:8086"
          },
          "precision" : {
            "type" : "enum",
            "symbols" : [
              "ns",
              "us",
              "ms",
              "s"
            ],
            "summary" : "Time Precision",
            "label" : "Time Precision",
            "description" : "InfluxDB time precision.",
            "default" : "ms"
          },
          "bucket" : {
            "type" : "string",
            "summary" : "Bucket",
            "label" : "Bucket",
            "description" : "InfluxDB bucket name."
          },
          "org" : {
            "type" : "string",
            "summary" : "Organization",
            "label" : "Organization",
            "description" : "Organization name of InfluxDB."
          },
          "token" : {
            "type" : "string",
            "summary" : "Token",
            "label" : "Token",
            "description" : "InfluxDB token."
          },
          "ssl" : {
            "$ref" : "#/components/schemas/broker.ssl_client_opts",
            "summary" : "Enable SSL",
            "label" : "Enable SSL",
            "description" : "SSL connection settings.",
            "default" : {
              "enable" : false
            }
          },
          "type" : {
            "type" : "enum",
            "symbols" : [
              "influxdb_api_v2"
            ],
            "summary" : "Bridge Type",
            "label" : "Bridge Type",
            "description" : "The Bridge Type."
          },
          "name" : {
            "type" : "string",
            "summary" : "Bridge Name",
            "label" : "Bridge Name",
            "description" : "Bridge name."
          },
          "status" : {
            "type" : "enum",
            "symbols" : [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "summary" : "Bridge Status",
            "label" : "Bridge Status",
            "description" : "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason" : {
            "type" : "string",
            "summary" : "Failure reason",
            "label" : "Failure reason",
            "example" : "Connection refused",
            "description" : "This is the reason given in case a bridge is failing to connect."
          },
          "node_status" : {
            "type" : "array",
            "summary" : "Node Status",
            "label" : "Node Status",
            "items" : {
              "$ref" : "#/components/schemas/bridge.node_status"
            },
            "description" : "Node status."
          }
        },
        "required" : [
          "bucket",
          "name",
          "org",
          "token",
          "type",
          "write_syntax"
        ]
      },
      "connector-mqtt.egress_local" : {
        "type" : "object",
        "properties" : {
          "topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "The local topic to be forwarded to the remote broker"
          }
        }
      },
      "bridge_influxdb.put_api_v2" : {
        "type" : "object",
        "properties" : {
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "The MQTT topic filter to be forwarded to the InfluxDB. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "write_syntax" : {
            "type" : "string",
            "summary" : "Write Syntax",
            "label" : "Write Syntax",
            "format" : "sql",
            "description" : "Conf of InfluxDB line protocol to write data points. It is a text-based format that provides the measurement, tag set, field set, and timestamp of a data point, and placeholder supported.<br/>See also [InfluxDB 2.3 Line Protocol](https://docs.influxdata.com/influxdb/v2.3/reference/syntax/line-protocol/) and<br/>[InfluxDB 1.8 Line Protocol](https://docs.influxdata.com/influxdb/v1.8/write_protocols/line_protocol_tutorial/) </br><br/>TLDR:</br><br/>```<br/><measurement>[,<tag_key>=<tag_value>[,<tag_key>=<tag_value>]] <field_key>=<field_value>[,<field_key>=<field_value>] [<timestamp>]<br/>```<br/>Please note that a placeholder for an integer value must be annotated with a suffix `i`. For example `${payload.int_value}i`."
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/resource_schema.creation_opts",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "server" : {
            "type" : "string",
            "summary" : "Server Host",
            "label" : "Server Host",
            "description" : "The IPv4 or IPv6 address or the hostname to connect to.</br><br/>A host entry has the following form: `Host[:Port]`.</br><br/>The InfluxDB default port 8086 is used if `[:Port]` is not specified.",
            "default" : "127.0.0.1:8086"
          },
          "precision" : {
            "type" : "enum",
            "symbols" : [
              "ns",
              "us",
              "ms",
              "s"
            ],
            "summary" : "Time Precision",
            "label" : "Time Precision",
            "description" : "InfluxDB time precision.",
            "default" : "ms"
          },
          "bucket" : {
            "type" : "string",
            "summary" : "Bucket",
            "label" : "Bucket",
            "description" : "InfluxDB bucket name."
          },
          "org" : {
            "type" : "string",
            "summary" : "Organization",
            "label" : "Organization",
            "description" : "Organization name of InfluxDB."
          },
          "token" : {
            "type" : "string",
            "summary" : "Token",
            "label" : "Token",
            "description" : "InfluxDB token."
          },
          "ssl" : {
            "$ref" : "#/components/schemas/broker.ssl_client_opts",
            "summary" : "Enable SSL",
            "label" : "Enable SSL",
            "description" : "SSL connection settings.",
            "default" : {
              "enable" : false
            }
          }
        },
        "required" : [
          "bucket",
          "org",
          "token",
          "write_syntax"
        ]
      },
      "bridge_redis.creation_opts_redis_single" : {
        "type" : "object",
        "properties" : {
          "worker_pool_size" : {
            "type" : "number",
            "summary" : "Buffer Pool Size",
            "minimum" : 1,
            "label" : "Buffer Pool Size",
            "description" : "The number of buffer workers. Only applicable for egress type bridges.<br/>For bridges only have ingress direction data flow, it can be set to 0 otherwise must be greater than 0.",
            "default" : 16
          },
          "health_check_interval" : {
            "type" : "duration",
            "summary" : "Health Check Interval",
            "label" : "Health Check Interval",
            "description" : "Health check interval.",
            "default" : "15s"
          },
          "start_after_created" : {
            "type" : "boolean",
            "summary" : "Start After Created",
            "label" : "Start After Created",
            "description" : "Whether start the resource right after created.",
            "default" : "true"
          },
          "start_timeout" : {
            "type" : "duration",
            "summary" : "Start Timeout",
            "label" : "Start Timeout",
            "description" : "Time interval to wait for an auto-started resource to become healthy before responding resource creation requests.",
            "default" : "5s"
          },
          "auto_restart_interval" : {
            "oneOf" : [
              {
                "type" : "duration"
              },
              {
                "type" : "enum",
                "symbols" : [
                  "infinity"
                ]
              }
            ],
            "summary" : "Auto Restart Interval",
            "label" : "Auto Restart Interval",
            "description" : "The auto restart interval after the resource is disconnected.",
            "default" : "60s"
          },
          "query_mode" : {
            "type" : "enum",
            "symbols" : [
              "sync",
              "async"
            ],
            "summary" : "Query mode",
            "label" : "Query mode",
            "description" : "Query mode. Optional 'sync/async', default 'async'.",
            "default" : "async"
          },
          "request_timeout" : {
            "oneOf" : [
              {
                "type" : "duration"
              },
              {
                "type" : "enum",
                "symbols" : [
                  "infinity"
                ]
              }
            ],
            "summary" : "Request Expiry",
            "label" : "Request Expiry",
            "description" : "Starting from the moment when the request enters the buffer, if the request remains in the buffer for the specified time or is sent but does not receive a response or acknowledgement in time, the request is considered expired.",
            "default" : "15s"
          },
          "inflight_window" : {
            "type" : "string",
            "summary" : "Inflight window",
            "label" : "Inflight window",
            "description" : "Query inflight window. When query_mode is set to async, this config has to be set to 1 if messages from the same MQTT client have to be strictly ordered.",
            "default" : 100
          },
          "enable_batch" : {
            "type" : "boolean",
            "summary" : "Enable batch",
            "label" : "Enable batch",
            "description" : "Batch mode enabled.",
            "deprecated" : true,
            "default" : true
          },
          "batch_size" : {
            "type" : "string",
            "summary" : "Max batch size",
            "label" : "Max batch size",
            "description" : "Maximum batch count. If equal to 1, there's effectively no batching.",
            "default" : 1
          },
          "batch_time" : {
            "type" : "duration",
            "summary" : "Max batch wait time",
            "label" : "Max batch wait time",
            "description" : "Maximum waiting interval when accumulating a batch at a low message rates for more efficient resource usage.",
            "default" : "0ms"
          },
          "enable_queue" : {
            "type" : "boolean",
            "summary" : "Enable disk buffer queue",
            "label" : "Enable disk buffer queue",
            "description" : "Enable disk buffer queue (only applicable for egress bridges).<br/>When Enabled, messages will be buffered on disk when the bridge connection is down.<br/>When disabled the messages are buffered in RAM only.",
            "deprecated" : true,
            "default" : false
          },
          "max_buffer_bytes" : {
            "type" : "byteSize",
            "summary" : "Max buffer queue size",
            "label" : "Max buffer queue size",
            "description" : "Maximum number of bytes to buffer for each buffer worker.",
            "default" : "256MB"
          }
        }
      },
      "bridge_mongodb.post_rs" : {
        "type" : "object",
        "properties" : {
          "mongo_type" : {
            "type" : "enum",
            "symbols" : [
              "rs"
            ],
            "summary" : "Replica set",
            "label" : "Replica set",
            "description" : "Replica set. Must be set to 'rs' when MongoDB server is running in 'replica set' mode.",
            "default" : "rs"
          },
          "servers" : {
            "type" : "string",
            "summary" : "Servers",
            "label" : "Servers",
            "description" : "A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`<br/>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.<br/>A host entry has the following form: `Host[:Port]`.<br/>The MongoDB default port 27017 is used if `[:Port]` is not specified."
          },
          "w_mode" : {
            "type" : "enum",
            "symbols" : [
              "unsafe",
              "safe"
            ],
            "summary" : "Write Mode",
            "label" : "Write Mode",
            "description" : "Write mode.",
            "default" : "unsafe"
          },
          "r_mode" : {
            "type" : "enum",
            "symbols" : [
              "master",
              "slave_ok"
            ],
            "summary" : "Read Mode",
            "label" : "Read Mode",
            "description" : "Read mode.",
            "default" : "master"
          },
          "replica_set_name" : {
            "type" : "string",
            "summary" : "Replica Set Name",
            "label" : "Replica Set Name",
            "description" : "Name of the replica set."
          },
          "srv_record" : {
            "type" : "boolean",
            "summary" : "Srv Record",
            "label" : "Srv Record",
            "description" : "Use DNS SRV record.",
            "default" : false
          },
          "pool_size" : {
            "type" : "string",
            "summary" : "Connection Pool Size",
            "label" : "Connection Pool Size",
            "description" : "Size of the connection pool towards the bridge target service.",
            "default" : 8
          },
          "username" : {
            "type" : "string",
            "summary" : "Username",
            "label" : "Username",
            "description" : "EMQX's username in the external database."
          },
          "password" : {
            "type" : "string",
            "summary" : "Password",
            "label" : "Password",
            "format" : "password",
            "description" : "EMQX's password in the external database."
          },
          "auth_source" : {
            "type" : "string",
            "summary" : "Auth Source",
            "label" : "Auth Source",
            "description" : "Database name associated with the user's credentials."
          },
          "database" : {
            "type" : "string",
            "summary" : "Database Name",
            "label" : "Database Name",
            "description" : "Database name."
          },
          "topology" : {
            "$ref" : "#/components/schemas/emqx_connector_mongo.topology",
            "label" : "topology",
            "description" : "topology Description"
          },
          "ssl" : {
            "$ref" : "#/components/schemas/broker.ssl_client_opts",
            "summary" : "Enable SSL",
            "label" : "Enable SSL",
            "description" : "SSL connection settings.",
            "default" : {
              "enable" : false
            }
          },
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable or disable",
            "label" : "Enable or disable",
            "description" : "Enable or disable this MongoDB Bridge",
            "default" : true
          },
          "collection" : {
            "type" : "string",
            "summary" : "Collection to be used",
            "label" : "Collection to be used",
            "description" : "The collection where data will be stored into",
            "default" : "mqtt"
          },
          "payload_template" : {
            "type" : "string",
            "summary" : "Payload template",
            "label" : "Payload template",
            "description" : "The template for formatting the outgoing messages.  If undefined, rule engine will use JSON format to serialize all visible inputs, such as clientid, topic, payload etc."
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/resource_schema.creation_opts",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "type" : {
            "type" : "enum",
            "symbols" : [
              "mongodb_rs"
            ],
            "summary" : "Bridge Type",
            "label" : "Bridge Type",
            "description" : "The Bridge Type."
          },
          "name" : {
            "type" : "string",
            "summary" : "Bridge Name",
            "label" : "Bridge Name",
            "description" : "Bridge name."
          }
        },
        "required" : [
          "database",
          "name",
          "replica_set_name",
          "servers",
          "type"
        ]
      },
      "bridge_clickhouse.creation_opts" : {
        "type" : "object",
        "properties" : {
          "worker_pool_size" : {
            "type" : "number",
            "summary" : "Buffer Pool Size",
            "minimum" : 1,
            "label" : "Buffer Pool Size",
            "description" : "The number of buffer workers. Only applicable for egress type bridges.<br/>For bridges only have ingress direction data flow, it can be set to 0 otherwise must be greater than 0.",
            "default" : 16
          },
          "health_check_interval" : {
            "type" : "duration",
            "summary" : "Health Check Interval",
            "label" : "Health Check Interval",
            "description" : "Health check interval.",
            "default" : "15s"
          },
          "start_after_created" : {
            "type" : "boolean",
            "summary" : "Start After Created",
            "label" : "Start After Created",
            "description" : "Whether start the resource right after created.",
            "default" : "true"
          },
          "start_timeout" : {
            "type" : "duration",
            "summary" : "Start Timeout",
            "label" : "Start Timeout",
            "description" : "Time interval to wait for an auto-started resource to become healthy before responding resource creation requests.",
            "default" : "5s"
          },
          "auto_restart_interval" : {
            "oneOf" : [
              {
                "type" : "duration"
              },
              {
                "type" : "enum",
                "symbols" : [
                  "infinity"
                ]
              }
            ],
            "summary" : "Auto Restart Interval",
            "label" : "Auto Restart Interval",
            "description" : "The auto restart interval after the resource is disconnected.",
            "default" : "60s"
          },
          "query_mode" : {
            "type" : "enum",
            "symbols" : [
              "sync",
              "async"
            ],
            "summary" : "Query mode",
            "label" : "Query mode",
            "description" : "Query mode. Optional 'sync/async', default 'async'.",
            "default" : "async"
          },
          "request_timeout" : {
            "oneOf" : [
              {
                "type" : "duration"
              },
              {
                "type" : "enum",
                "symbols" : [
                  "infinity"
                ]
              }
            ],
            "summary" : "Request Expiry",
            "label" : "Request Expiry",
            "description" : "Starting from the moment when the request enters the buffer, if the request remains in the buffer for the specified time or is sent but does not receive a response or acknowledgement in time, the request is considered expired.",
            "default" : "15s"
          },
          "inflight_window" : {
            "type" : "string",
            "summary" : "Inflight window",
            "label" : "Inflight window",
            "description" : "Query inflight window. When query_mode is set to async, this config has to be set to 1 if messages from the same MQTT client have to be strictly ordered.",
            "default" : 100
          },
          "enable_batch" : {
            "type" : "boolean",
            "summary" : "Enable batch",
            "label" : "Enable batch",
            "description" : "Batch mode enabled.",
            "deprecated" : true,
            "default" : true
          },
          "batch_size" : {
            "type" : "string",
            "summary" : "Max batch size",
            "label" : "Max batch size",
            "description" : "Maximum batch count. If equal to 1, there's effectively no batching.",
            "default" : 1
          },
          "batch_time" : {
            "type" : "duration",
            "summary" : "Max batch wait time",
            "label" : "Max batch wait time",
            "description" : "Maximum waiting interval when accumulating a batch at a low message rates for more efficient resource usage.",
            "default" : "0ms"
          },
          "enable_queue" : {
            "type" : "boolean",
            "summary" : "Enable disk buffer queue",
            "label" : "Enable disk buffer queue",
            "description" : "Enable disk buffer queue (only applicable for egress bridges).<br/>When Enabled, messages will be buffered on disk when the bridge connection is down.<br/>When disabled the messages are buffered in RAM only.",
            "deprecated" : true,
            "default" : false
          },
          "max_buffer_bytes" : {
            "type" : "byteSize",
            "summary" : "Max buffer queue size",
            "label" : "Max buffer queue size",
            "description" : "Maximum number of bytes to buffer for each buffer worker.",
            "default" : "256MB"
          }
        }
      },
      "bridge_clickhouse.put" : {
        "type" : "object",
        "properties" : {
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "sql" : {
            "type" : "string",
            "summary" : "SQL Template",
            "label" : "SQL Template",
            "format" : "sql",
            "description" : "The template string can contain ${field} placeholders for message metadata and payload field. Make sure that the inserted values are formatted and escaped correctly. [Prepared Statement](https://docs.emqx.com/en/enterprise/v5.0/data-integration/data-bridges.html#Prepared-Statement) is not supported.",
            "default" : "INSERT INTO mqtt_test(payload, arrived) VALUES ('${payload}', ${timestamp})"
          },
          "batch_value_separator" : {
            "type" : "string",
            "summary" : "Batch Value Separator",
            "label" : "Batch Value Separator",
            "description" : "The default value ',' works for the VALUES format. You can also use other separator if other format is specified. See [INSERT INTO Statement](https://clickhouse.com/docs/en/sql-reference/statements/insert-into).",
            "default" : ", "
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "The MQTT topic filter to be forwarded to Clickhouse. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/bridge_clickhouse.creation_opts",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "url" : {
            "type" : "url",
            "summary" : "Server URL",
            "label" : "Server URL",
            "description" : "The HTTP URL to the Clickhouse server that you want to connect to (for example http://myhostname:8123)"
          },
          "connect_timeout" : {
            "type" : "duration",
            "summary" : "Clickhouse Timeout",
            "label" : "Clickhouse Timeout",
            "description" : "The timeout when connecting to the Clickhouse server.",
            "default" : "15s"
          },
          "database" : {
            "type" : "string",
            "summary" : "Database Name",
            "label" : "Database Name",
            "description" : "Database name."
          },
          "pool_size" : {
            "type" : "string",
            "summary" : "Connection Pool Size",
            "label" : "Connection Pool Size",
            "description" : "Size of the connection pool towards the bridge target service.",
            "default" : 8
          },
          "username" : {
            "type" : "string",
            "summary" : "Username",
            "label" : "Username",
            "description" : "EMQX's username in the external database."
          },
          "password" : {
            "type" : "string",
            "summary" : "Password",
            "label" : "Password",
            "format" : "password",
            "description" : "EMQX's password in the external database."
          },
          "auto_reconnect" : {
            "type" : "boolean",
            "summary" : "Deprecated. Auto Reconnect Database",
            "label" : "Deprecated. Auto Reconnect Database",
            "description" : "Deprecated. Enable automatic reconnect to the database.",
            "deprecated" : true,
            "default" : true
          }
        },
        "required" : [
          "database",
          "url"
        ]
      },
      "bridge_mongodb.put_rs" : {
        "type" : "object",
        "properties" : {
          "mongo_type" : {
            "type" : "enum",
            "symbols" : [
              "rs"
            ],
            "summary" : "Replica set",
            "label" : "Replica set",
            "description" : "Replica set. Must be set to 'rs' when MongoDB server is running in 'replica set' mode.",
            "default" : "rs"
          },
          "servers" : {
            "type" : "string",
            "summary" : "Servers",
            "label" : "Servers",
            "description" : "A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`<br/>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.<br/>A host entry has the following form: `Host[:Port]`.<br/>The MongoDB default port 27017 is used if `[:Port]` is not specified."
          },
          "w_mode" : {
            "type" : "enum",
            "symbols" : [
              "unsafe",
              "safe"
            ],
            "summary" : "Write Mode",
            "label" : "Write Mode",
            "description" : "Write mode.",
            "default" : "unsafe"
          },
          "r_mode" : {
            "type" : "enum",
            "symbols" : [
              "master",
              "slave_ok"
            ],
            "summary" : "Read Mode",
            "label" : "Read Mode",
            "description" : "Read mode.",
            "default" : "master"
          },
          "replica_set_name" : {
            "type" : "string",
            "summary" : "Replica Set Name",
            "label" : "Replica Set Name",
            "description" : "Name of the replica set."
          },
          "srv_record" : {
            "type" : "boolean",
            "summary" : "Srv Record",
            "label" : "Srv Record",
            "description" : "Use DNS SRV record.",
            "default" : false
          },
          "pool_size" : {
            "type" : "string",
            "summary" : "Connection Pool Size",
            "label" : "Connection Pool Size",
            "description" : "Size of the connection pool towards the bridge target service.",
            "default" : 8
          },
          "username" : {
            "type" : "string",
            "summary" : "Username",
            "label" : "Username",
            "description" : "EMQX's username in the external database."
          },
          "password" : {
            "type" : "string",
            "summary" : "Password",
            "label" : "Password",
            "format" : "password",
            "description" : "EMQX's password in the external database."
          },
          "auth_source" : {
            "type" : "string",
            "summary" : "Auth Source",
            "label" : "Auth Source",
            "description" : "Database name associated with the user's credentials."
          },
          "database" : {
            "type" : "string",
            "summary" : "Database Name",
            "label" : "Database Name",
            "description" : "Database name."
          },
          "topology" : {
            "$ref" : "#/components/schemas/emqx_connector_mongo.topology",
            "label" : "topology",
            "description" : "topology Description"
          },
          "ssl" : {
            "$ref" : "#/components/schemas/broker.ssl_client_opts",
            "summary" : "Enable SSL",
            "label" : "Enable SSL",
            "description" : "SSL connection settings.",
            "default" : {
              "enable" : false
            }
          },
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable or disable",
            "label" : "Enable or disable",
            "description" : "Enable or disable this MongoDB Bridge",
            "default" : true
          },
          "collection" : {
            "type" : "string",
            "summary" : "Collection to be used",
            "label" : "Collection to be used",
            "description" : "The collection where data will be stored into",
            "default" : "mqtt"
          },
          "payload_template" : {
            "type" : "string",
            "summary" : "Payload template",
            "label" : "Payload template",
            "description" : "The template for formatting the outgoing messages.  If undefined, rule engine will use JSON format to serialize all visible inputs, such as clientid, topic, payload etc."
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/resource_schema.creation_opts",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          }
        },
        "required" : [
          "database",
          "replica_set_name",
          "servers"
        ]
      },
      "bridge.metrics" : {
        "type" : "object",
        "properties" : {
          "dropped" : {
            "type" : "number",
            "summary" : "Dropped",
            "label" : "Dropped",
            "description" : "Count of messages dropped."
          },
          "dropped.other" : {
            "type" : "number",
            "summary" : "Dropped Other",
            "label" : "Dropped Other",
            "description" : "Count of messages dropped due to other reasons."
          },
          "dropped.queue_full" : {
            "type" : "number",
            "summary" : "Dropped Queue Full",
            "label" : "Dropped Queue Full",
            "description" : "Count of messages dropped due to the queue is full."
          },
          "dropped.resource_not_found" : {
            "type" : "number",
            "summary" : "Dropped Resource NotFound",
            "label" : "Dropped Resource NotFound",
            "description" : "Count of messages dropped due to the resource is not found."
          },
          "dropped.resource_stopped" : {
            "type" : "number",
            "summary" : "Dropped Resource Stopped",
            "label" : "Dropped Resource Stopped",
            "description" : "Count of messages dropped due to the resource is stopped."
          },
          "matched" : {
            "type" : "number",
            "summary" : "Matched",
            "label" : "Matched",
            "description" : "Count of this bridge is matched and queried."
          },
          "queuing" : {
            "type" : "number",
            "summary" : "Queued",
            "label" : "Queued",
            "description" : "Count of messages that are currently queuing."
          },
          "retried" : {
            "type" : "number",
            "summary" : "Retried",
            "label" : "Retried",
            "description" : "Times of retried."
          },
          "failed" : {
            "type" : "number",
            "summary" : "Sent Failed",
            "label" : "Sent Failed",
            "description" : "Count of messages that sent failed."
          },
          "inflight" : {
            "type" : "number",
            "summary" : "Sent Inflight",
            "label" : "Sent Inflight",
            "description" : "Count of messages that were sent asynchronously but ACKs are not yet received."
          },
          "success" : {
            "type" : "number",
            "summary" : "Sent Success",
            "label" : "Sent Success",
            "description" : "Count of messages that sent successfully."
          },
          "rate" : {
            "type" : "number",
            "summary" : "Rate",
            "label" : "Rate",
            "description" : "The rate of matched, times/second"
          },
          "rate_max" : {
            "type" : "number",
            "summary" : "Max Rate Of Matched",
            "label" : "Max Rate Of Matched",
            "description" : "The max rate of matched, times/second"
          },
          "rate_last5m" : {
            "type" : "number",
            "summary" : "Last 5 Minutes Rate",
            "label" : "Last 5 Minutes Rate",
            "description" : "The average rate of matched in the last 5 minutes, times/second"
          },
          "received" : {
            "type" : "number",
            "summary" : "Received",
            "label" : "Received",
            "description" : "Count of messages that is received from the remote system."
          }
        }
      },
      "bridge_influxdb.get_api_v1" : {
        "type" : "object",
        "properties" : {
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "The MQTT topic filter to be forwarded to the InfluxDB. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "write_syntax" : {
            "type" : "string",
            "summary" : "Write Syntax",
            "label" : "Write Syntax",
            "format" : "sql",
            "description" : "Conf of InfluxDB line protocol to write data points. It is a text-based format that provides the measurement, tag set, field set, and timestamp of a data point, and placeholder supported.<br/>See also [InfluxDB 2.3 Line Protocol](https://docs.influxdata.com/influxdb/v2.3/reference/syntax/line-protocol/) and<br/>[InfluxDB 1.8 Line Protocol](https://docs.influxdata.com/influxdb/v1.8/write_protocols/line_protocol_tutorial/) </br><br/>TLDR:</br><br/>```<br/><measurement>[,<tag_key>=<tag_value>[,<tag_key>=<tag_value>]] <field_key>=<field_value>[,<field_key>=<field_value>] [<timestamp>]<br/>```<br/>Please note that a placeholder for an integer value must be annotated with a suffix `i`. For example `${payload.int_value}i`."
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/resource_schema.creation_opts",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "server" : {
            "type" : "string",
            "summary" : "Server Host",
            "label" : "Server Host",
            "description" : "The IPv4 or IPv6 address or the hostname to connect to.</br><br/>A host entry has the following form: `Host[:Port]`.</br><br/>The InfluxDB default port 8086 is used if `[:Port]` is not specified.",
            "default" : "127.0.0.1:8086"
          },
          "precision" : {
            "type" : "enum",
            "symbols" : [
              "ns",
              "us",
              "ms",
              "s"
            ],
            "summary" : "Time Precision",
            "label" : "Time Precision",
            "description" : "InfluxDB time precision.",
            "default" : "ms"
          },
          "database" : {
            "type" : "string",
            "summary" : "Database",
            "label" : "Database",
            "description" : "InfluxDB database."
          },
          "username" : {
            "type" : "string",
            "summary" : "Username",
            "label" : "Username",
            "description" : "InfluxDB username."
          },
          "password" : {
            "type" : "string",
            "summary" : "Password",
            "label" : "Password",
            "format" : "password",
            "description" : "InfluxDB password."
          },
          "ssl" : {
            "$ref" : "#/components/schemas/broker.ssl_client_opts",
            "summary" : "Enable SSL",
            "label" : "Enable SSL",
            "description" : "SSL connection settings.",
            "default" : {
              "enable" : false
            }
          },
          "type" : {
            "type" : "enum",
            "symbols" : [
              "influxdb_api_v1"
            ],
            "summary" : "Bridge Type",
            "label" : "Bridge Type",
            "description" : "The Bridge Type."
          },
          "name" : {
            "type" : "string",
            "summary" : "Bridge Name",
            "label" : "Bridge Name",
            "description" : "Bridge name."
          },
          "status" : {
            "type" : "enum",
            "symbols" : [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "summary" : "Bridge Status",
            "label" : "Bridge Status",
            "description" : "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason" : {
            "type" : "string",
            "summary" : "Failure reason",
            "label" : "Failure reason",
            "example" : "Connection refused",
            "description" : "This is the reason given in case a bridge is failing to connect."
          },
          "node_status" : {
            "type" : "array",
            "summary" : "Node Status",
            "label" : "Node Status",
            "items" : {
              "$ref" : "#/components/schemas/bridge.node_status"
            },
            "description" : "Node status."
          }
        },
        "required" : [
          "database",
          "name",
          "type",
          "write_syntax"
        ]
      },
      "bridge_mysql.put" : {
        "type" : "object",
        "properties" : {
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "sql" : {
            "type" : "string",
            "summary" : "SQL Template",
            "label" : "SQL Template",
            "format" : "sql",
            "description" : "SQL Template",
            "default" : "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, FROM_UNIXTIME(${timestamp}/1000))"
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "The MQTT topic filter to be forwarded to MySQL. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/resource_schema.creation_opts",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "server" : {
            "type" : "string",
            "summary" : "Server Host",
            "label" : "Server Host",
            "description" : "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The MySQL default port 3306 is used if `[:Port]` is not specified."
          },
          "database" : {
            "type" : "string",
            "summary" : "Database Name",
            "label" : "Database Name",
            "description" : "Database name."
          },
          "pool_size" : {
            "type" : "string",
            "summary" : "Connection Pool Size",
            "label" : "Connection Pool Size",
            "description" : "Size of the connection pool towards the bridge target service.",
            "default" : 8
          },
          "username" : {
            "type" : "string",
            "summary" : "Username",
            "label" : "Username",
            "description" : "EMQX's username in the external database.",
            "default" : "root"
          },
          "password" : {
            "type" : "string",
            "summary" : "Password",
            "label" : "Password",
            "format" : "password",
            "description" : "EMQX's password in the external database."
          },
          "auto_reconnect" : {
            "type" : "boolean",
            "summary" : "Deprecated. Auto Reconnect Database",
            "label" : "Deprecated. Auto Reconnect Database",
            "description" : "Deprecated. Enable automatic reconnect to the database.",
            "deprecated" : true,
            "default" : true
          },
          "ssl" : {
            "$ref" : "#/components/schemas/broker.ssl_client_opts",
            "summary" : "Enable SSL",
            "label" : "Enable SSL",
            "description" : "SSL connection settings.",
            "default" : {
              "enable" : false
            }
          }
        },
        "required" : [
          "database",
          "server"
        ]
      },
      "connector-http.request" : {
        "type" : "object",
        "properties" : {
          "method" : {
            "type" : "string",
            "summary" : "HTTP Method",
            "label" : "HTTP Method",
            "description" : "HTTP method."
          },
          "path" : {
            "type" : "string",
            "summary" : "URL Path",
            "label" : "URL Path",
            "description" : "URL path."
          },
          "body" : {
            "type" : "string",
            "summary" : "HTTP Body",
            "label" : "HTTP Body",
            "description" : "HTTP request body."
          },
          "headers" : {
            "type" : "object",
            "summary" : "HTTP Headers",
            "label" : "HTTP Headers",
            "description" : "List of HTTP headers."
          },
          "max_retries" : {
            "type" : "number",
            "summary" : "Max Retries",
            "minimum" : 1,
            "label" : "Max Retries",
            "description" : "Max retry times if error on sending request."
          },
          "request_timeout" : {
            "type" : "duration",
            "summary" : "Request Timeout",
            "label" : "Request Timeout",
            "description" : "HTTP request timeout."
          }
        }
      },
      "bridge_mongodb.post_sharded" : {
        "type" : "object",
        "properties" : {
          "mongo_type" : {
            "type" : "enum",
            "symbols" : [
              "sharded"
            ],
            "summary" : "Sharded cluster",
            "label" : "Sharded cluster",
            "description" : "Sharded cluster. Must be set to 'sharded' when MongoDB server is running in 'sharded' mode.",
            "default" : "sharded"
          },
          "servers" : {
            "type" : "string",
            "summary" : "Servers",
            "label" : "Servers",
            "description" : "A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`<br/>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.<br/>A host entry has the following form: `Host[:Port]`.<br/>The MongoDB default port 27017 is used if `[:Port]` is not specified."
          },
          "w_mode" : {
            "type" : "enum",
            "symbols" : [
              "unsafe",
              "safe"
            ],
            "summary" : "Write Mode",
            "label" : "Write Mode",
            "description" : "Write mode.",
            "default" : "unsafe"
          },
          "srv_record" : {
            "type" : "boolean",
            "summary" : "Srv Record",
            "label" : "Srv Record",
            "description" : "Use DNS SRV record.",
            "default" : false
          },
          "pool_size" : {
            "type" : "string",
            "summary" : "Connection Pool Size",
            "label" : "Connection Pool Size",
            "description" : "Size of the connection pool towards the bridge target service.",
            "default" : 8
          },
          "username" : {
            "type" : "string",
            "summary" : "Username",
            "label" : "Username",
            "description" : "EMQX's username in the external database."
          },
          "password" : {
            "type" : "string",
            "summary" : "Password",
            "label" : "Password",
            "format" : "password",
            "description" : "EMQX's password in the external database."
          },
          "auth_source" : {
            "type" : "string",
            "summary" : "Auth Source",
            "label" : "Auth Source",
            "description" : "Database name associated with the user's credentials."
          },
          "database" : {
            "type" : "string",
            "summary" : "Database Name",
            "label" : "Database Name",
            "description" : "Database name."
          },
          "topology" : {
            "$ref" : "#/components/schemas/emqx_connector_mongo.topology",
            "label" : "topology",
            "description" : "topology Description"
          },
          "ssl" : {
            "$ref" : "#/components/schemas/broker.ssl_client_opts",
            "summary" : "Enable SSL",
            "label" : "Enable SSL",
            "description" : "SSL connection settings.",
            "default" : {
              "enable" : false
            }
          },
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable or disable",
            "label" : "Enable or disable",
            "description" : "Enable or disable this MongoDB Bridge",
            "default" : true
          },
          "collection" : {
            "type" : "string",
            "summary" : "Collection to be used",
            "label" : "Collection to be used",
            "description" : "The collection where data will be stored into",
            "default" : "mqtt"
          },
          "payload_template" : {
            "type" : "string",
            "summary" : "Payload template",
            "label" : "Payload template",
            "description" : "The template for formatting the outgoing messages.  If undefined, rule engine will use JSON format to serialize all visible inputs, such as clientid, topic, payload etc."
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/resource_schema.creation_opts",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "type" : {
            "type" : "enum",
            "symbols" : [
              "mongodb_sharded"
            ],
            "summary" : "Bridge Type",
            "label" : "Bridge Type",
            "description" : "The Bridge Type."
          },
          "name" : {
            "type" : "string",
            "summary" : "Bridge Name",
            "label" : "Bridge Name",
            "description" : "Bridge name."
          }
        },
        "required" : [
          "database",
          "name",
          "servers",
          "type"
        ]
      },
      "bridge.node_status" : {
        "type" : "object",
        "properties" : {
          "node" : {
            "type" : "string",
            "summary" : "Node Name",
            "label" : "Node Name",
            "example" : "emqx@127.0.0.1",
            "description" : "The node name."
          },
          "status" : {
            "type" : "enum",
            "symbols" : [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "label" : "status",
            "description" : "status Description"
          },
          "status_reason" : {
            "type" : "string",
            "summary" : "Failure reason",
            "label" : "Failure reason",
            "example" : "Connection refused",
            "description" : "This is the reason given in case a bridge is failing to connect."
          }
        }
      },
      "bridge_hstreamdb.post" : {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "enum",
            "symbols" : [
              "hstreamdb"
            ],
            "summary" : "Bridge Type",
            "label" : "Bridge Type",
            "description" : "The Bridge Type"
          },
          "name" : {
            "type" : "string",
            "summary" : "Bridge Name",
            "label" : "Bridge Name",
            "description" : "Bridge name, used as a human-readable description of the bridge."
          },
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "direction" : {
            "type" : "enum",
            "symbols" : [
              "egress"
            ],
            "summary" : "Bridge Direction",
            "label" : "Bridge Direction",
            "description" : "The direction of this bridge, MUST be 'egress'",
            "default" : "egress"
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "The MQTT topic filter to be forwarded to the HStreamDB. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "payload" : {
            "type" : "string",
            "summary" : "Payload",
            "label" : "Payload",
            "description" : "The payload to be forwarded to the HStreamDB. Placeholders supported.",
            "default" : "${payload}"
          },
          "connector" : {
            "oneOf" : [
              {
                "$ref" : "#/components/schemas/connector_hstreamdb.config"
              },
              {
                "type" : "string"
              }
            ],
            "summary" : "Connector Generic Configuration",
            "label" : "Connector Generic Configuration",
            "example" : "hstreamdb:demo",
            "description" : "Generic configuration for the connector."
          }
        },
        "required" : [
          "connector",
          "name",
          "type"
        ]
      },
      "connector-mqtt.egress_remote" : {
        "type" : "object",
        "properties" : {
          "topic" : {
            "type" : "string",
            "summary" : "Remote Topic",
            "label" : "Remote Topic",
            "description" : "Forward to which topic of the remote broker.<br/><br/>Template with variables is allowed."
          },
          "qos" : {
            "oneOf" : [
              {
                "type" : "string"
              },
              {
                "type" : "enum",
                "symbols" : [
                  0,
                  1,
                  2
                ]
              }
            ],
            "summary" : "Remote QoS",
            "label" : "Remote QoS",
            "description" : "The QoS of the MQTT message to be sent.<br/><br/>Template with variables is allowed.",
            "default" : 1
          },
          "retain" : {
            "oneOf" : [
              {
                "type" : "string"
              },
              {
                "type" : "boolean"
              }
            ],
            "summary" : "Retain Flag",
            "label" : "Retain Flag",
            "description" : "The 'retain' flag of the MQTT message to be sent.<br/><br/>Template with variables is allowed.",
            "default" : false
          },
          "payload" : {
            "type" : "string",
            "summary" : "Payload",
            "label" : "Payload",
            "description" : "The payload of the MQTT message to be sent.<br/><br/>Template with variables is allowed."
          }
        },
        "required" : [
          "topic"
        ]
      },
      "bridge_redis.get_sentinel" : {
        "type" : "object",
        "properties" : {
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "The MQTT topic filter to be forwarded to Redis. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "command_template" : {
            "type" : "array",
            "summary" : "Redis Command Template",
            "label" : "Redis Command Template",
            "items" : {
              "type" : "string"
            },
            "description" : "Redis command template used to export messages. Each list element stands for a command name or its argument.<br/>For example, to push payloads in a Redis list by key `msgs`, the elements should be the following:<br/>`rpush`, `msgs`, `${payload}`."
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/bridge_redis.creation_opts_redis_sentinel",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "servers" : {
            "type" : "string",
            "summary" : "Servers",
            "label" : "Servers",
            "description" : "A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`<br/>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.<br/>A host entry has the following form: `Host[:Port]`.<br/>The Redis default port 6379 is used if `[:Port]` is not specified."
          },
          "redis_type" : {
            "type" : "enum",
            "symbols" : [
              "sentinel"
            ],
            "summary" : "Sentinel Mode",
            "label" : "Sentinel Mode",
            "description" : "Sentinel mode. Must be set to 'sentinel' when Redis server is running in sentinel mode.",
            "default" : "sentinel"
          },
          "sentinel" : {
            "type" : "string",
            "summary" : "Cluster Name",
            "label" : "Cluster Name",
            "description" : "The cluster name in Redis sentinel mode."
          },
          "pool_size" : {
            "type" : "string",
            "summary" : "Connection Pool Size",
            "label" : "Connection Pool Size",
            "description" : "Size of the connection pool towards the bridge target service.",
            "default" : 8
          },
          "password" : {
            "type" : "string",
            "summary" : "Password",
            "label" : "Password",
            "format" : "password",
            "description" : "EMQX's password in the external database."
          },
          "database" : {
            "type" : "number",
            "summary" : "Database ID",
            "label" : "Database ID",
            "description" : "Redis database ID.",
            "default" : 0
          },
          "auto_reconnect" : {
            "type" : "boolean",
            "summary" : "Deprecated. Auto Reconnect Database",
            "label" : "Deprecated. Auto Reconnect Database",
            "description" : "Deprecated. Enable automatic reconnect to the database.",
            "deprecated" : true,
            "default" : true
          },
          "ssl" : {
            "$ref" : "#/components/schemas/broker.ssl_client_opts",
            "summary" : "Enable SSL",
            "label" : "Enable SSL",
            "description" : "SSL connection settings.",
            "default" : {
              "enable" : false
            }
          },
          "type" : {
            "type" : "enum",
            "symbols" : [
              "redis_sentinel"
            ],
            "summary" : "Bridge Type",
            "label" : "Bridge Type",
            "description" : "The Bridge Type"
          },
          "name" : {
            "type" : "string",
            "summary" : "Bridge Name",
            "label" : "Bridge Name",
            "description" : "Bridge name, used as a human-readable description of the bridge."
          },
          "status" : {
            "type" : "enum",
            "symbols" : [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "summary" : "Bridge Status",
            "label" : "Bridge Status",
            "description" : "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason" : {
            "type" : "string",
            "summary" : "Failure reason",
            "label" : "Failure reason",
            "example" : "Connection refused",
            "description" : "This is the reason given in case a bridge is failing to connect."
          },
          "node_status" : {
            "type" : "array",
            "summary" : "Node Status",
            "label" : "Node Status",
            "items" : {
              "$ref" : "#/components/schemas/bridge.node_status"
            },
            "description" : "Node status."
          }
        },
        "required" : [
          "command_template",
          "name",
          "sentinel",
          "servers",
          "type"
        ]
      },
      "bridge.node_metrics" : {
        "type" : "object",
        "properties" : {
          "node" : {
            "type" : "string",
            "summary" : "Node Name",
            "label" : "Node Name",
            "example" : "emqx@127.0.0.1",
            "description" : "The node name."
          },
          "metrics" : {
            "$ref" : "#/components/schemas/bridge.metrics",
            "label" : "metrics",
            "description" : "metrics Description"
          }
        }
      },
      "bridge_sqlserver.get" : {
        "type" : "object",
        "properties" : {
          "status" : {
            "type" : "enum",
            "symbols" : [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "summary" : "Bridge Status",
            "label" : "Bridge Status",
            "description" : "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason" : {
            "type" : "string",
            "summary" : "Failure reason",
            "label" : "Failure reason",
            "example" : "Connection refused",
            "description" : "This is the reason given in case a bridge is failing to connect."
          },
          "node_status" : {
            "type" : "array",
            "summary" : "Node Status",
            "label" : "Node Status",
            "items" : {
              "$ref" : "#/components/schemas/bridge.node_status"
            },
            "description" : "Node status."
          },
          "type" : {
            "type" : "enum",
            "symbols" : [
              "sqlserver"
            ],
            "summary" : "Bridge Type",
            "label" : "Bridge Type",
            "description" : "The Bridge Type"
          },
          "name" : {
            "type" : "string",
            "summary" : "Bridge Name",
            "label" : "Bridge Name",
            "description" : "Bridge name."
          },
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "sql" : {
            "type" : "string",
            "summary" : "SQL Template",
            "label" : "SQL Template",
            "format" : "sql",
            "description" : "SQL Template",
            "default" : "insert into t_mqtt_msg(msgid, topic, qos, payload) values ( ${id}, ${topic}, ${qos}, ${payload} )"
          },
          "driver" : {
            "type" : "string",
            "summary" : "SQL Server Driver Name",
            "label" : "SQL Server Driver Name",
            "description" : "SQL Server Driver Name",
            "default" : "ms-sql"
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "The MQTT topic filter to be forwarded to Microsoft SQL Server. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/bridge_sqlserver.creation_opts",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "server" : {
            "type" : "string",
            "summary" : "Server Host",
            "label" : "Server Host",
            "description" : "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The SQL Server default port 1433 is used if `[:Port]` is not specified."
          },
          "database" : {
            "type" : "string",
            "summary" : "Database Name",
            "label" : "Database Name",
            "description" : "Database name."
          },
          "pool_size" : {
            "type" : "string",
            "summary" : "Connection Pool Size",
            "label" : "Connection Pool Size",
            "description" : "Size of the connection pool towards the bridge target service.",
            "default" : 8
          },
          "username" : {
            "type" : "string",
            "summary" : "Username",
            "label" : "Username",
            "description" : "EMQX's username in the external database.",
            "default" : "sa"
          },
          "password" : {
            "type" : "string",
            "summary" : "Password",
            "label" : "Password",
            "format" : "password",
            "description" : "EMQX's password in the external database."
          },
          "auto_reconnect" : {
            "type" : "boolean",
            "summary" : "Deprecated. Auto Reconnect Database",
            "label" : "Deprecated. Auto Reconnect Database",
            "description" : "Deprecated. Enable automatic reconnect to the database.",
            "deprecated" : true,
            "default" : true
          }
        },
        "required" : [
          "database",
          "name",
          "server",
          "type"
        ]
      },
      "bridge_mqtt.creation_opts" : {
        "type" : "object",
        "properties" : {
          "worker_pool_size" : {
            "type" : "number",
            "summary" : "Buffer Pool Size",
            "minimum" : 1,
            "label" : "Buffer Pool Size",
            "description" : "The number of buffer workers. Only applicable for egress type bridges.<br/>For bridges only have ingress direction data flow, it can be set to 0 otherwise must be greater than 0.",
            "default" : 16
          },
          "health_check_interval" : {
            "type" : "duration",
            "summary" : "Health Check Interval",
            "label" : "Health Check Interval",
            "description" : "Health check interval.",
            "default" : "15s"
          },
          "start_after_created" : {
            "type" : "boolean",
            "summary" : "Start After Created",
            "label" : "Start After Created",
            "description" : "Whether start the resource right after created.",
            "default" : "true"
          },
          "start_timeout" : {
            "type" : "duration",
            "summary" : "Start Timeout",
            "label" : "Start Timeout",
            "description" : "Time interval to wait for an auto-started resource to become healthy before responding resource creation requests.",
            "default" : "5s"
          },
          "auto_restart_interval" : {
            "oneOf" : [
              {
                "type" : "duration"
              },
              {
                "type" : "enum",
                "symbols" : [
                  "infinity"
                ]
              }
            ],
            "summary" : "Auto Restart Interval",
            "label" : "Auto Restart Interval",
            "description" : "The auto restart interval after the resource is disconnected.",
            "default" : "60s"
          },
          "query_mode" : {
            "type" : "enum",
            "symbols" : [
              "sync",
              "async"
            ],
            "summary" : "Query mode",
            "label" : "Query mode",
            "description" : "Query mode. Optional 'sync/async', default 'async'.",
            "default" : "async"
          },
          "request_timeout" : {
            "oneOf" : [
              {
                "type" : "duration"
              },
              {
                "type" : "enum",
                "symbols" : [
                  "infinity"
                ]
              }
            ],
            "summary" : "Request Expiry",
            "label" : "Request Expiry",
            "description" : "Starting from the moment when the request enters the buffer, if the request remains in the buffer for the specified time or is sent but does not receive a response or acknowledgement in time, the request is considered expired.",
            "default" : "15s"
          },
          "inflight_window" : {
            "type" : "string",
            "summary" : "Inflight window",
            "label" : "Inflight window",
            "description" : "Query inflight window. When query_mode is set to async, this config has to be set to 1 if messages from the same MQTT client have to be strictly ordered.",
            "default" : 100
          },
          "enable_queue" : {
            "type" : "boolean",
            "summary" : "Enable disk buffer queue",
            "label" : "Enable disk buffer queue",
            "description" : "Enable disk buffer queue (only applicable for egress bridges).<br/>When Enabled, messages will be buffered on disk when the bridge connection is down.<br/>When disabled the messages are buffered in RAM only.",
            "deprecated" : true,
            "default" : false
          },
          "max_buffer_bytes" : {
            "type" : "byteSize",
            "summary" : "Max buffer queue size",
            "label" : "Max buffer queue size",
            "description" : "Maximum number of bytes to buffer for each buffer worker.",
            "default" : "256MB"
          }
        }
      },
      "bridge_kafka.auth_username_password" : {
        "type" : "object",
        "properties" : {
          "mechanism" : {
            "type" : "enum",
            "symbols" : [
              "plain",
              "scram_sha_256",
              "scram_sha_512"
            ],
            "summary" : "Mechanism",
            "label" : "Mechanism",
            "description" : "SASL authentication mechanism."
          },
          "username" : {
            "type" : "string",
            "summary" : "Username",
            "label" : "Username",
            "description" : "SASL authentication username."
          },
          "password" : {
            "type" : "string",
            "summary" : "Password",
            "label" : "Password",
            "description" : "SASL authentication password."
          }
        },
        "required" : [
          "mechanism",
          "password",
          "username"
        ]
      },
      "bridge_dynamo.get" : {
        "type" : "object",
        "properties" : {
          "status" : {
            "type" : "enum",
            "symbols" : [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "summary" : "Bridge Status",
            "label" : "Bridge Status",
            "description" : "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason" : {
            "type" : "string",
            "summary" : "Failure reason",
            "label" : "Failure reason",
            "example" : "Connection refused",
            "description" : "This is the reason given in case a bridge is failing to connect."
          },
          "node_status" : {
            "type" : "array",
            "summary" : "Node Status",
            "label" : "Node Status",
            "items" : {
              "$ref" : "#/components/schemas/bridge.node_status"
            },
            "description" : "Node status."
          },
          "type" : {
            "type" : "enum",
            "symbols" : [
              "dynamo"
            ],
            "summary" : "Bridge Type",
            "label" : "Bridge Type",
            "description" : "The Bridge Type"
          },
          "name" : {
            "type" : "string",
            "summary" : "Bridge Name",
            "label" : "Bridge Name",
            "description" : "Bridge name."
          },
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "template" : {
            "type" : "string",
            "summary" : "Template",
            "label" : "Template",
            "description" : "Template, the default value is empty. When this value is empty the whole message will be stored in the database",
            "default" : ""
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "The MQTT topic filter to be forwarded to DynamoDB. All MQTT `PUBLISH` messages with the topic<br/>matching the `local_topic` will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also `local_topic` is<br/>configured, then both the data got from the rule and the MQTT messages that match `local_topic`<br/>will be forwarded."
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/bridge_dynamo.creation_opts",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "url" : {
            "type" : "string",
            "summary" : "DynamoDB Endpoint",
            "label" : "DynamoDB Endpoint",
            "description" : "The url of DynamoDB endpoint."
          },
          "table" : {
            "type" : "string",
            "summary" : "Table ",
            "label" : "Table ",
            "description" : "DynamoDB Table."
          },
          "aws_access_key_id" : {
            "type" : "string",
            "summary" : "AWS Access Key ID",
            "label" : "AWS Access Key ID",
            "description" : "Access Key ID for connecting to DynamoDB."
          },
          "aws_secret_access_key" : {
            "type" : "string",
            "summary" : "AWS Secret Access Key",
            "label" : "AWS Secret Access Key",
            "description" : "AWS Secret Access Key for connecting to DynamoDB."
          },
          "pool_size" : {
            "type" : "string",
            "summary" : "Connection Pool Size",
            "label" : "Connection Pool Size",
            "description" : "Size of the connection pool towards the bridge target service.",
            "default" : 8
          },
          "auto_reconnect" : {
            "type" : "boolean",
            "summary" : "Deprecated. Auto Reconnect Database",
            "label" : "Deprecated. Auto Reconnect Database",
            "description" : "Deprecated. Enable automatic reconnect to the database.",
            "deprecated" : true,
            "default" : true
          }
        },
        "required" : [
          "aws_access_key_id",
          "aws_secret_access_key",
          "name",
          "table",
          "type",
          "url"
        ]
      },
      "bridge_matrix.post" : {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "enum",
            "symbols" : [
              "matrix"
            ],
            "summary" : "Bridge Type",
            "label" : "Bridge Type",
            "description" : "The Bridge Type"
          },
          "name" : {
            "type" : "string",
            "summary" : "Bridge Name",
            "label" : "Bridge Name",
            "description" : "Bridge name."
          },
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "sql" : {
            "type" : "string",
            "summary" : "SQL Template",
            "label" : "SQL Template",
            "format" : "sql",
            "description" : "SQL Template",
            "default" : "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))"
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "The MQTT topic filter to be forwarded to PostgreSQL. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/resource_schema.creation_opts",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "server" : {
            "type" : "string",
            "summary" : "Server Host",
            "label" : "Server Host",
            "description" : "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The PostgreSQL default port 5432 is used if `[:Port]` is not specified."
          },
          "database" : {
            "type" : "string",
            "summary" : "Database Name",
            "label" : "Database Name",
            "description" : "Database name."
          },
          "pool_size" : {
            "type" : "string",
            "summary" : "Connection Pool Size",
            "label" : "Connection Pool Size",
            "description" : "Size of the connection pool towards the bridge target service.",
            "default" : 8
          },
          "username" : {
            "type" : "string",
            "summary" : "Username",
            "label" : "Username",
            "description" : "EMQX's username in the external database."
          },
          "password" : {
            "type" : "string",
            "summary" : "Password",
            "label" : "Password",
            "format" : "password",
            "description" : "EMQX's password in the external database."
          },
          "auto_reconnect" : {
            "type" : "boolean",
            "summary" : "Deprecated. Auto Reconnect Database",
            "label" : "Deprecated. Auto Reconnect Database",
            "description" : "Deprecated. Enable automatic reconnect to the database.",
            "deprecated" : true,
            "default" : true
          },
          "ssl" : {
            "$ref" : "#/components/schemas/broker.ssl_client_opts",
            "summary" : "Enable SSL",
            "label" : "Enable SSL",
            "description" : "SSL connection settings.",
            "default" : {
              "enable" : false
            }
          }
        },
        "required" : [
          "database",
          "name",
          "server",
          "type"
        ]
      },
      "bridge_influxdb.put_api_v1" : {
        "type" : "object",
        "properties" : {
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "The MQTT topic filter to be forwarded to the InfluxDB. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "write_syntax" : {
            "type" : "string",
            "summary" : "Write Syntax",
            "label" : "Write Syntax",
            "format" : "sql",
            "description" : "Conf of InfluxDB line protocol to write data points. It is a text-based format that provides the measurement, tag set, field set, and timestamp of a data point, and placeholder supported.<br/>See also [InfluxDB 2.3 Line Protocol](https://docs.influxdata.com/influxdb/v2.3/reference/syntax/line-protocol/) and<br/>[InfluxDB 1.8 Line Protocol](https://docs.influxdata.com/influxdb/v1.8/write_protocols/line_protocol_tutorial/) </br><br/>TLDR:</br><br/>```<br/><measurement>[,<tag_key>=<tag_value>[,<tag_key>=<tag_value>]] <field_key>=<field_value>[,<field_key>=<field_value>] [<timestamp>]<br/>```<br/>Please note that a placeholder for an integer value must be annotated with a suffix `i`. For example `${payload.int_value}i`."
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/resource_schema.creation_opts",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "server" : {
            "type" : "string",
            "summary" : "Server Host",
            "label" : "Server Host",
            "description" : "The IPv4 or IPv6 address or the hostname to connect to.</br><br/>A host entry has the following form: `Host[:Port]`.</br><br/>The InfluxDB default port 8086 is used if `[:Port]` is not specified.",
            "default" : "127.0.0.1:8086"
          },
          "precision" : {
            "type" : "enum",
            "symbols" : [
              "ns",
              "us",
              "ms",
              "s"
            ],
            "summary" : "Time Precision",
            "label" : "Time Precision",
            "description" : "InfluxDB time precision.",
            "default" : "ms"
          },
          "database" : {
            "type" : "string",
            "summary" : "Database",
            "label" : "Database",
            "description" : "InfluxDB database."
          },
          "username" : {
            "type" : "string",
            "summary" : "Username",
            "label" : "Username",
            "description" : "InfluxDB username."
          },
          "password" : {
            "type" : "string",
            "summary" : "Password",
            "label" : "Password",
            "format" : "password",
            "description" : "InfluxDB password."
          },
          "ssl" : {
            "$ref" : "#/components/schemas/broker.ssl_client_opts",
            "summary" : "Enable SSL",
            "label" : "Enable SSL",
            "description" : "SSL connection settings.",
            "default" : {
              "enable" : false
            }
          }
        },
        "required" : [
          "database",
          "write_syntax"
        ]
      },
      "bridge_pgsql.put" : {
        "type" : "object",
        "properties" : {
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "sql" : {
            "type" : "string",
            "summary" : "SQL Template",
            "label" : "SQL Template",
            "format" : "sql",
            "description" : "SQL Template",
            "default" : "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))"
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "The MQTT topic filter to be forwarded to PostgreSQL. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/resource_schema.creation_opts",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "server" : {
            "type" : "string",
            "summary" : "Server Host",
            "label" : "Server Host",
            "description" : "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The PostgreSQL default port 5432 is used if `[:Port]` is not specified."
          },
          "database" : {
            "type" : "string",
            "summary" : "Database Name",
            "label" : "Database Name",
            "description" : "Database name."
          },
          "pool_size" : {
            "type" : "string",
            "summary" : "Connection Pool Size",
            "label" : "Connection Pool Size",
            "description" : "Size of the connection pool towards the bridge target service.",
            "default" : 8
          },
          "username" : {
            "type" : "string",
            "summary" : "Username",
            "label" : "Username",
            "description" : "EMQX's username in the external database."
          },
          "password" : {
            "type" : "string",
            "summary" : "Password",
            "label" : "Password",
            "format" : "password",
            "description" : "EMQX's password in the external database."
          },
          "auto_reconnect" : {
            "type" : "boolean",
            "summary" : "Deprecated. Auto Reconnect Database",
            "label" : "Deprecated. Auto Reconnect Database",
            "description" : "Deprecated. Enable automatic reconnect to the database.",
            "deprecated" : true,
            "default" : true
          },
          "ssl" : {
            "$ref" : "#/components/schemas/broker.ssl_client_opts",
            "summary" : "Enable SSL",
            "label" : "Enable SSL",
            "description" : "SSL connection settings.",
            "default" : {
              "enable" : false
            }
          }
        },
        "required" : [
          "database",
          "server"
        ]
      },
      "bridge_pgsql.post" : {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "enum",
            "symbols" : [
              "pgsql"
            ],
            "summary" : "Bridge Type",
            "label" : "Bridge Type",
            "description" : "The Bridge Type"
          },
          "name" : {
            "type" : "string",
            "summary" : "Bridge Name",
            "label" : "Bridge Name",
            "description" : "Bridge name."
          },
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "sql" : {
            "type" : "string",
            "summary" : "SQL Template",
            "label" : "SQL Template",
            "format" : "sql",
            "description" : "SQL Template",
            "default" : "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))"
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "The MQTT topic filter to be forwarded to PostgreSQL. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/resource_schema.creation_opts",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "server" : {
            "type" : "string",
            "summary" : "Server Host",
            "label" : "Server Host",
            "description" : "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The PostgreSQL default port 5432 is used if `[:Port]` is not specified."
          },
          "database" : {
            "type" : "string",
            "summary" : "Database Name",
            "label" : "Database Name",
            "description" : "Database name."
          },
          "pool_size" : {
            "type" : "string",
            "summary" : "Connection Pool Size",
            "label" : "Connection Pool Size",
            "description" : "Size of the connection pool towards the bridge target service.",
            "default" : 8
          },
          "username" : {
            "type" : "string",
            "summary" : "Username",
            "label" : "Username",
            "description" : "EMQX's username in the external database."
          },
          "password" : {
            "type" : "string",
            "summary" : "Password",
            "label" : "Password",
            "format" : "password",
            "description" : "EMQX's password in the external database."
          },
          "auto_reconnect" : {
            "type" : "boolean",
            "summary" : "Deprecated. Auto Reconnect Database",
            "label" : "Deprecated. Auto Reconnect Database",
            "description" : "Deprecated. Enable automatic reconnect to the database.",
            "deprecated" : true,
            "default" : true
          },
          "ssl" : {
            "$ref" : "#/components/schemas/broker.ssl_client_opts",
            "summary" : "Enable SSL",
            "label" : "Enable SSL",
            "description" : "SSL connection settings.",
            "default" : {
              "enable" : false
            }
          }
        },
        "required" : [
          "database",
          "name",
          "server",
          "type"
        ]
      },
      "bridge_gcp_pubsub.put" : {
        "type" : "object",
        "properties" : {
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/resource_schema.creation_opts",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "connect_timeout" : {
            "type" : "duration",
            "summary" : "Connect Timeout",
            "label" : "Connect Timeout",
            "description" : "The timeout when connecting to the HTTP server.",
            "default" : "15s"
          },
          "pool_size" : {
            "type" : "string",
            "summary" : "Pool Size",
            "label" : "Pool Size",
            "description" : "The pool size.",
            "default" : 8
          },
          "pipelining" : {
            "type" : "string",
            "summary" : "HTTP Pipelineing",
            "label" : "HTTP Pipelineing",
            "description" : "A positive integer. Whether to send HTTP requests continuously, when set to 1, it means that after each HTTP request is sent, you need to wait for the server to return and then continue to send the next request.",
            "default" : 100
          },
          "max_retries" : {
            "type" : "number",
            "summary" : "Max Retries",
            "minimum" : 1,
            "label" : "Max Retries",
            "description" : "Max retry times if an error occurs when sending a request.",
            "default" : 2
          },
          "request_timeout" : {
            "type" : "duration",
            "summary" : "Request Timeout",
            "label" : "Request Timeout",
            "description" : "Deprecated: Configure the request timeout in the buffer settings.",
            "deprecated" : true,
            "default" : "15s"
          },
          "payload_template" : {
            "type" : "string",
            "summary" : "Payload template",
            "label" : "Payload template",
            "description" : "The template for formatting the outgoing messages.  If undefined, will send all the available context in JSON format.",
            "default" : ""
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "The MQTT topic filter to be forwarded to GCP PubSub. All MQTT 'PUBLISH' messages with the topic<br/>matching `local_topic` will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "pubsub_topic" : {
            "type" : "string",
            "summary" : "GCP PubSub Topic",
            "label" : "GCP PubSub Topic",
            "description" : "The GCP PubSub topic to publish messages to."
          },
          "service_account_json" : {
            "type" : "string",
            "summary" : "GCP Service Account Credentials",
            "label" : "GCP Service Account Credentials",
            "description" : "JSON containing the GCP Service Account credentials to be used with PubSub.<br/>When a GCP Service Account is created (as described in https://developers.google.com/identity/protocols/oauth2/service-account#creatinganaccount), you have the option of downloading the credentials in JSON form.  That's the file needed."
          }
        },
        "required" : [
          "pubsub_topic",
          "service_account_json"
        ]
      },
      "bridge_hstreamdb.put" : {
        "type" : "object",
        "properties" : {
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "direction" : {
            "type" : "enum",
            "symbols" : [
              "egress"
            ],
            "summary" : "Bridge Direction",
            "label" : "Bridge Direction",
            "description" : "The direction of this bridge, MUST be 'egress'",
            "default" : "egress"
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "The MQTT topic filter to be forwarded to the HStreamDB. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "payload" : {
            "type" : "string",
            "summary" : "Payload",
            "label" : "Payload",
            "description" : "The payload to be forwarded to the HStreamDB. Placeholders supported.",
            "default" : "${payload}"
          },
          "connector" : {
            "oneOf" : [
              {
                "$ref" : "#/components/schemas/connector_hstreamdb.config"
              },
              {
                "type" : "string"
              }
            ],
            "summary" : "Connector Generic Configuration",
            "label" : "Connector Generic Configuration",
            "example" : "hstreamdb:demo",
            "description" : "Generic configuration for the connector."
          }
        },
        "required" : [
          "connector"
        ]
      },
      "bridge_mongodb.get_sharded" : {
        "type" : "object",
        "properties" : {
          "status" : {
            "type" : "enum",
            "symbols" : [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "summary" : "Bridge Status",
            "label" : "Bridge Status",
            "description" : "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason" : {
            "type" : "string",
            "summary" : "Failure reason",
            "label" : "Failure reason",
            "example" : "Connection refused",
            "description" : "This is the reason given in case a bridge is failing to connect."
          },
          "node_status" : {
            "type" : "array",
            "summary" : "Node Status",
            "label" : "Node Status",
            "items" : {
              "$ref" : "#/components/schemas/bridge.node_status"
            },
            "description" : "Node status."
          },
          "mongo_type" : {
            "type" : "enum",
            "symbols" : [
              "sharded"
            ],
            "summary" : "Sharded cluster",
            "label" : "Sharded cluster",
            "description" : "Sharded cluster. Must be set to 'sharded' when MongoDB server is running in 'sharded' mode.",
            "default" : "sharded"
          },
          "servers" : {
            "type" : "string",
            "summary" : "Servers",
            "label" : "Servers",
            "description" : "A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`<br/>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.<br/>A host entry has the following form: `Host[:Port]`.<br/>The MongoDB default port 27017 is used if `[:Port]` is not specified."
          },
          "w_mode" : {
            "type" : "enum",
            "symbols" : [
              "unsafe",
              "safe"
            ],
            "summary" : "Write Mode",
            "label" : "Write Mode",
            "description" : "Write mode.",
            "default" : "unsafe"
          },
          "srv_record" : {
            "type" : "boolean",
            "summary" : "Srv Record",
            "label" : "Srv Record",
            "description" : "Use DNS SRV record.",
            "default" : false
          },
          "pool_size" : {
            "type" : "string",
            "summary" : "Connection Pool Size",
            "label" : "Connection Pool Size",
            "description" : "Size of the connection pool towards the bridge target service.",
            "default" : 8
          },
          "username" : {
            "type" : "string",
            "summary" : "Username",
            "label" : "Username",
            "description" : "EMQX's username in the external database."
          },
          "password" : {
            "type" : "string",
            "summary" : "Password",
            "label" : "Password",
            "format" : "password",
            "description" : "EMQX's password in the external database."
          },
          "auth_source" : {
            "type" : "string",
            "summary" : "Auth Source",
            "label" : "Auth Source",
            "description" : "Database name associated with the user's credentials."
          },
          "database" : {
            "type" : "string",
            "summary" : "Database Name",
            "label" : "Database Name",
            "description" : "Database name."
          },
          "topology" : {
            "$ref" : "#/components/schemas/emqx_connector_mongo.topology",
            "label" : "topology",
            "description" : "topology Description"
          },
          "ssl" : {
            "$ref" : "#/components/schemas/broker.ssl_client_opts",
            "summary" : "Enable SSL",
            "label" : "Enable SSL",
            "description" : "SSL connection settings.",
            "default" : {
              "enable" : false
            }
          },
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable or disable",
            "label" : "Enable or disable",
            "description" : "Enable or disable this MongoDB Bridge",
            "default" : true
          },
          "collection" : {
            "type" : "string",
            "summary" : "Collection to be used",
            "label" : "Collection to be used",
            "description" : "The collection where data will be stored into",
            "default" : "mqtt"
          },
          "payload_template" : {
            "type" : "string",
            "summary" : "Payload template",
            "label" : "Payload template",
            "description" : "The template for formatting the outgoing messages.  If undefined, rule engine will use JSON format to serialize all visible inputs, such as clientid, topic, payload etc."
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/resource_schema.creation_opts",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "type" : {
            "type" : "enum",
            "symbols" : [
              "mongodb_sharded"
            ],
            "summary" : "Bridge Type",
            "label" : "Bridge Type",
            "description" : "The Bridge Type."
          },
          "name" : {
            "type" : "string",
            "summary" : "Bridge Name",
            "label" : "Bridge Name",
            "description" : "Bridge name."
          }
        },
        "required" : [
          "database",
          "name",
          "servers",
          "type"
        ]
      },
      "bridge_mongodb.post_single" : {
        "type" : "object",
        "properties" : {
          "mongo_type" : {
            "type" : "enum",
            "symbols" : [
              "single"
            ],
            "summary" : "Standalone instance",
            "label" : "Standalone instance",
            "description" : "Standalone instance. Must be set to 'single' when MongoDB server is running in standalone mode.",
            "default" : "single"
          },
          "server" : {
            "type" : "string",
            "summary" : "Server Host",
            "label" : "Server Host",
            "description" : "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The MongoDB default port 27017 is used if `[:Port]` is not specified."
          },
          "w_mode" : {
            "type" : "enum",
            "symbols" : [
              "unsafe",
              "safe"
            ],
            "summary" : "Write Mode",
            "label" : "Write Mode",
            "description" : "Write mode.",
            "default" : "unsafe"
          },
          "srv_record" : {
            "type" : "boolean",
            "summary" : "Srv Record",
            "label" : "Srv Record",
            "description" : "Use DNS SRV record.",
            "default" : false
          },
          "pool_size" : {
            "type" : "string",
            "summary" : "Connection Pool Size",
            "label" : "Connection Pool Size",
            "description" : "Size of the connection pool towards the bridge target service.",
            "default" : 8
          },
          "username" : {
            "type" : "string",
            "summary" : "Username",
            "label" : "Username",
            "description" : "EMQX's username in the external database."
          },
          "password" : {
            "type" : "string",
            "summary" : "Password",
            "label" : "Password",
            "format" : "password",
            "description" : "EMQX's password in the external database."
          },
          "auth_source" : {
            "type" : "string",
            "summary" : "Auth Source",
            "label" : "Auth Source",
            "description" : "Database name associated with the user's credentials."
          },
          "database" : {
            "type" : "string",
            "summary" : "Database Name",
            "label" : "Database Name",
            "description" : "Database name."
          },
          "topology" : {
            "$ref" : "#/components/schemas/emqx_connector_mongo.topology",
            "label" : "topology",
            "description" : "topology Description"
          },
          "ssl" : {
            "$ref" : "#/components/schemas/broker.ssl_client_opts",
            "summary" : "Enable SSL",
            "label" : "Enable SSL",
            "description" : "SSL connection settings.",
            "default" : {
              "enable" : false
            }
          },
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable or disable",
            "label" : "Enable or disable",
            "description" : "Enable or disable this MongoDB Bridge",
            "default" : true
          },
          "collection" : {
            "type" : "string",
            "summary" : "Collection to be used",
            "label" : "Collection to be used",
            "description" : "The collection where data will be stored into",
            "default" : "mqtt"
          },
          "payload_template" : {
            "type" : "string",
            "summary" : "Payload template",
            "label" : "Payload template",
            "description" : "The template for formatting the outgoing messages.  If undefined, rule engine will use JSON format to serialize all visible inputs, such as clientid, topic, payload etc."
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/resource_schema.creation_opts",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "type" : {
            "type" : "enum",
            "symbols" : [
              "mongodb_single"
            ],
            "summary" : "Bridge Type",
            "label" : "Bridge Type",
            "description" : "The Bridge Type."
          },
          "name" : {
            "type" : "string",
            "summary" : "Bridge Name",
            "label" : "Bridge Name",
            "description" : "Bridge name."
          }
        },
        "required" : [
          "database",
          "name",
          "server",
          "type"
        ]
      },
      "bridge_cassa.put" : {
        "type" : "object",
        "properties" : {
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "cql" : {
            "type" : "string",
            "summary" : "CQL Template",
            "label" : "CQL Template",
            "format" : "sql",
            "description" : "CQL Template",
            "default" : "insert into mqtt_msg(topic, msgid, sender, qos, payload, arrived, retain) values (${topic}, ${id}, ${clientid}, ${qos}, ${payload}, ${timestamp}, ${flags.retain})"
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "The MQTT topic filter to be forwarded to Cassandra. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/resource_schema.creation_opts",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "servers" : {
            "type" : "string",
            "summary" : "Servers",
            "label" : "Servers",
            "description" : "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port][,Host2:Port]`.<br/><br/>The Cassandra default port 9042 is used if `[:Port]` is not specified."
          },
          "keyspace" : {
            "type" : "string",
            "summary" : "Keyspace",
            "label" : "Keyspace",
            "description" : "Keyspace name to connect to."
          },
          "pool_size" : {
            "type" : "string",
            "summary" : "Connection Pool Size",
            "label" : "Connection Pool Size",
            "description" : "Size of the connection pool towards the bridge target service.",
            "default" : 8
          },
          "username" : {
            "type" : "string",
            "summary" : "Username",
            "label" : "Username",
            "description" : "EMQX's username in the external database."
          },
          "password" : {
            "type" : "string",
            "summary" : "Password",
            "label" : "Password",
            "format" : "password",
            "description" : "EMQX's password in the external database."
          },
          "auto_reconnect" : {
            "type" : "boolean",
            "summary" : "Deprecated. Auto Reconnect Database",
            "label" : "Deprecated. Auto Reconnect Database",
            "description" : "Deprecated. Enable automatic reconnect to the database.",
            "deprecated" : true,
            "default" : true
          },
          "ssl" : {
            "$ref" : "#/components/schemas/broker.ssl_client_opts",
            "summary" : "Enable SSL",
            "label" : "Enable SSL",
            "description" : "SSL connection settings.",
            "default" : {
              "enable" : false
            }
          }
        },
        "required" : [
          "keyspace",
          "servers"
        ]
      },
      "connector-mqtt.egress" : {
        "type" : "object",
        "properties" : {
          "local" : {
            "$ref" : "#/components/schemas/connector-mqtt.egress_local",
            "summary" : "Local Configs",
            "label" : "Local Configs",
            "description" : "The configs about receiving messages from local broker."
          },
          "remote" : {
            "$ref" : "#/components/schemas/connector-mqtt.egress_remote",
            "summary" : "Remote Configs",
            "label" : "Remote Configs",
            "description" : "The configs about sending message to the remote broker."
          }
        },
        "required" : [
          "remote"
        ]
      },
      "bridge_kafka.post_consumer" : {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "enum",
            "symbols" : [
              "kafka_consumer",
              "kafka"
            ],
            "summary" : "Bridge Type",
            "label" : "Bridge Type",
            "description" : "The Bridge Type"
          },
          "name" : {
            "type" : "string",
            "summary" : "Bridge Name",
            "label" : "Bridge Name",
            "description" : "Bridge name, used as a human-readable description of the bridge."
          },
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable or Disable",
            "label" : "Enable or Disable",
            "description" : "Enable (true) or disable (false) this Kafka bridge.",
            "default" : true
          },
          "bootstrap_hosts" : {
            "type" : "string",
            "summary" : "Bootstrap Hosts",
            "label" : "Bootstrap Hosts",
            "description" : "A comma separated list of Kafka <code>host[:port]</code> endpoints to bootstrap the client. Default port number is 9092."
          },
          "connect_timeout" : {
            "type" : "duration",
            "summary" : "Connect Timeout",
            "label" : "Connect Timeout",
            "description" : "Maximum wait time for TCP connection establishment (including authentication time if enabled).",
            "default" : "5s"
          },
          "min_metadata_refresh_interval" : {
            "type" : "duration",
            "summary" : "Min Metadata Refresh Interval",
            "label" : "Min Metadata Refresh Interval",
            "description" : "Minimum time interval the client has to wait before refreshing Kafka broker and topic metadata. Setting too small value may add extra load on Kafka.",
            "default" : "3s"
          },
          "metadata_request_timeout" : {
            "type" : "duration",
            "summary" : "Metadata Request Timeout",
            "label" : "Metadata Request Timeout",
            "description" : "Maximum wait time when fetching metadata from Kafka.",
            "default" : "5s"
          },
          "authentication" : {
            "oneOf" : [
              {
                "$ref" : "#/components/schemas/bridge_kafka.auth_gssapi_kerberos"
              },
              {
                "$ref" : "#/components/schemas/bridge_kafka.auth_username_password"
              },
              {
                "type" : "enum",
                "symbols" : [
                  "none"
                ]
              }
            ],
            "summary" : "Authentication",
            "label" : "Authentication",
            "description" : "Authentication configs.",
            "default" : "none"
          },
          "socket_opts" : {
            "$ref" : "#/components/schemas/bridge_kafka.socket_opts",
            "summary" : "Socket Options",
            "label" : "Socket Options",
            "description" : "Extra socket options."
          },
          "ssl" : {
            "$ref" : "#/components/schemas/broker.ssl_client_opts",
            "summary" : "Enable SSL",
            "label" : "Enable SSL",
            "description" : "SSL connection settings.",
            "default" : {
              "enable" : false
            }
          },
          "kafka" : {
            "$ref" : "#/components/schemas/bridge_kafka.consumer_kafka_opts",
            "summary" : "Kafka Consumer",
            "label" : "Kafka Consumer",
            "description" : "Kafka consumer configs."
          },
          "topic_mapping" : {
            "type" : "array",
            "summary" : "Topic Mapping",
            "label" : "Topic Mapping",
            "items" : {
              "$ref" : "#/components/schemas/bridge_kafka.consumer_topic_mapping"
            },
            "description" : "Defines the mapping between Kafka topics and MQTT topics. Must contain at least one item."
          },
          "key_encoding_mode" : {
            "type" : "enum",
            "symbols" : [
              "none",
              "base64"
            ],
            "summary" : "Key Encoding Mode",
            "label" : "Key Encoding Mode",
            "description" : "Defines how the key from the Kafka message is encoded before being forwarded via MQTT.<br/><code>none</code> Uses the key from the Kafka message unchanged.  Note: in this case, the key must be a valid UTF-8 string.<br/><code>base64</code> Uses base-64 encoding on the received key.",
            "default" : "none"
          },
          "value_encoding_mode" : {
            "type" : "enum",
            "symbols" : [
              "none",
              "base64"
            ],
            "summary" : "Value Encoding Mode",
            "label" : "Value Encoding Mode",
            "description" : "Defines how the value from the Kafka message is encoded before being forwarded via MQTT.<br/><code>none</code> Uses the value from the Kafka message unchanged.  Note: in this case, the value must be a valid UTF-8 string.<br/><code>base64</code> Uses base-64 encoding on the received value.",
            "default" : "none"
          }
        },
        "required" : [
          "bootstrap_hosts",
          "name",
          "topic_mapping",
          "type"
        ]
      },
      "bridge_dynamo.post" : {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "enum",
            "symbols" : [
              "dynamo"
            ],
            "summary" : "Bridge Type",
            "label" : "Bridge Type",
            "description" : "The Bridge Type"
          },
          "name" : {
            "type" : "string",
            "summary" : "Bridge Name",
            "label" : "Bridge Name",
            "description" : "Bridge name."
          },
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "template" : {
            "type" : "string",
            "summary" : "Template",
            "label" : "Template",
            "description" : "Template, the default value is empty. When this value is empty the whole message will be stored in the database",
            "default" : ""
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "The MQTT topic filter to be forwarded to DynamoDB. All MQTT `PUBLISH` messages with the topic<br/>matching the `local_topic` will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also `local_topic` is<br/>configured, then both the data got from the rule and the MQTT messages that match `local_topic`<br/>will be forwarded."
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/bridge_dynamo.creation_opts",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "url" : {
            "type" : "string",
            "summary" : "DynamoDB Endpoint",
            "label" : "DynamoDB Endpoint",
            "description" : "The url of DynamoDB endpoint."
          },
          "table" : {
            "type" : "string",
            "summary" : "Table ",
            "label" : "Table ",
            "description" : "DynamoDB Table."
          },
          "aws_access_key_id" : {
            "type" : "string",
            "summary" : "AWS Access Key ID",
            "label" : "AWS Access Key ID",
            "description" : "Access Key ID for connecting to DynamoDB."
          },
          "aws_secret_access_key" : {
            "type" : "string",
            "summary" : "AWS Secret Access Key",
            "label" : "AWS Secret Access Key",
            "description" : "AWS Secret Access Key for connecting to DynamoDB."
          },
          "pool_size" : {
            "type" : "string",
            "summary" : "Connection Pool Size",
            "label" : "Connection Pool Size",
            "description" : "Size of the connection pool towards the bridge target service.",
            "default" : 8
          },
          "auto_reconnect" : {
            "type" : "boolean",
            "summary" : "Deprecated. Auto Reconnect Database",
            "label" : "Deprecated. Auto Reconnect Database",
            "description" : "Deprecated. Enable automatic reconnect to the database.",
            "deprecated" : true,
            "default" : true
          }
        },
        "required" : [
          "aws_access_key_id",
          "aws_secret_access_key",
          "name",
          "table",
          "type",
          "url"
        ]
      },
      "bridge_clickhouse.get" : {
        "type" : "object",
        "properties" : {
          "status" : {
            "type" : "enum",
            "symbols" : [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "summary" : "Bridge Status",
            "label" : "Bridge Status",
            "description" : "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason" : {
            "type" : "string",
            "summary" : "Failure reason",
            "label" : "Failure reason",
            "example" : "Connection refused",
            "description" : "This is the reason given in case a bridge is failing to connect."
          },
          "node_status" : {
            "type" : "array",
            "summary" : "Node Status",
            "label" : "Node Status",
            "items" : {
              "$ref" : "#/components/schemas/bridge.node_status"
            },
            "description" : "Node status."
          },
          "type" : {
            "type" : "enum",
            "symbols" : [
              "clickhouse"
            ],
            "summary" : "Bridge Type",
            "label" : "Bridge Type",
            "description" : "The Bridge Type"
          },
          "name" : {
            "type" : "string",
            "summary" : "Bridge Name",
            "label" : "Bridge Name",
            "description" : "Bridge name."
          },
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "sql" : {
            "type" : "string",
            "summary" : "SQL Template",
            "label" : "SQL Template",
            "format" : "sql",
            "description" : "The template string can contain ${field} placeholders for message metadata and payload field. Make sure that the inserted values are formatted and escaped correctly. [Prepared Statement](https://docs.emqx.com/en/enterprise/v5.0/data-integration/data-bridges.html#Prepared-Statement) is not supported.",
            "default" : "INSERT INTO mqtt_test(payload, arrived) VALUES ('${payload}', ${timestamp})"
          },
          "batch_value_separator" : {
            "type" : "string",
            "summary" : "Batch Value Separator",
            "label" : "Batch Value Separator",
            "description" : "The default value ',' works for the VALUES format. You can also use other separator if other format is specified. See [INSERT INTO Statement](https://clickhouse.com/docs/en/sql-reference/statements/insert-into).",
            "default" : ", "
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "The MQTT topic filter to be forwarded to Clickhouse. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/bridge_clickhouse.creation_opts",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "url" : {
            "type" : "url",
            "summary" : "Server URL",
            "label" : "Server URL",
            "description" : "The HTTP URL to the Clickhouse server that you want to connect to (for example http://myhostname:8123)"
          },
          "connect_timeout" : {
            "type" : "duration",
            "summary" : "Clickhouse Timeout",
            "label" : "Clickhouse Timeout",
            "description" : "The timeout when connecting to the Clickhouse server.",
            "default" : "15s"
          },
          "database" : {
            "type" : "string",
            "summary" : "Database Name",
            "label" : "Database Name",
            "description" : "Database name."
          },
          "pool_size" : {
            "type" : "string",
            "summary" : "Connection Pool Size",
            "label" : "Connection Pool Size",
            "description" : "Size of the connection pool towards the bridge target service.",
            "default" : 8
          },
          "username" : {
            "type" : "string",
            "summary" : "Username",
            "label" : "Username",
            "description" : "EMQX's username in the external database."
          },
          "password" : {
            "type" : "string",
            "summary" : "Password",
            "label" : "Password",
            "format" : "password",
            "description" : "EMQX's password in the external database."
          },
          "auto_reconnect" : {
            "type" : "boolean",
            "summary" : "Deprecated. Auto Reconnect Database",
            "label" : "Deprecated. Auto Reconnect Database",
            "description" : "Deprecated. Enable automatic reconnect to the database.",
            "deprecated" : true,
            "default" : true
          }
        },
        "required" : [
          "database",
          "name",
          "type",
          "url"
        ]
      },
      "bridge_matrix.put" : {
        "type" : "object",
        "properties" : {
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "sql" : {
            "type" : "string",
            "summary" : "SQL Template",
            "label" : "SQL Template",
            "format" : "sql",
            "description" : "SQL Template",
            "default" : "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))"
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "The MQTT topic filter to be forwarded to PostgreSQL. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/resource_schema.creation_opts",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "server" : {
            "type" : "string",
            "summary" : "Server Host",
            "label" : "Server Host",
            "description" : "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The PostgreSQL default port 5432 is used if `[:Port]` is not specified."
          },
          "database" : {
            "type" : "string",
            "summary" : "Database Name",
            "label" : "Database Name",
            "description" : "Database name."
          },
          "pool_size" : {
            "type" : "string",
            "summary" : "Connection Pool Size",
            "label" : "Connection Pool Size",
            "description" : "Size of the connection pool towards the bridge target service.",
            "default" : 8
          },
          "username" : {
            "type" : "string",
            "summary" : "Username",
            "label" : "Username",
            "description" : "EMQX's username in the external database."
          },
          "password" : {
            "type" : "string",
            "summary" : "Password",
            "label" : "Password",
            "format" : "password",
            "description" : "EMQX's password in the external database."
          },
          "auto_reconnect" : {
            "type" : "boolean",
            "summary" : "Deprecated. Auto Reconnect Database",
            "label" : "Deprecated. Auto Reconnect Database",
            "description" : "Deprecated. Enable automatic reconnect to the database.",
            "deprecated" : true,
            "default" : true
          },
          "ssl" : {
            "$ref" : "#/components/schemas/broker.ssl_client_opts",
            "summary" : "Enable SSL",
            "label" : "Enable SSL",
            "description" : "SSL connection settings.",
            "default" : {
              "enable" : false
            }
          }
        },
        "required" : [
          "database",
          "server"
        ]
      },
      "bridge_mongodb.get_rs" : {
        "type" : "object",
        "properties" : {
          "status" : {
            "type" : "enum",
            "symbols" : [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "summary" : "Bridge Status",
            "label" : "Bridge Status",
            "description" : "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason" : {
            "type" : "string",
            "summary" : "Failure reason",
            "label" : "Failure reason",
            "example" : "Connection refused",
            "description" : "This is the reason given in case a bridge is failing to connect."
          },
          "node_status" : {
            "type" : "array",
            "summary" : "Node Status",
            "label" : "Node Status",
            "items" : {
              "$ref" : "#/components/schemas/bridge.node_status"
            },
            "description" : "Node status."
          },
          "mongo_type" : {
            "type" : "enum",
            "symbols" : [
              "rs"
            ],
            "summary" : "Replica set",
            "label" : "Replica set",
            "description" : "Replica set. Must be set to 'rs' when MongoDB server is running in 'replica set' mode.",
            "default" : "rs"
          },
          "servers" : {
            "type" : "string",
            "summary" : "Servers",
            "label" : "Servers",
            "description" : "A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`<br/>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.<br/>A host entry has the following form: `Host[:Port]`.<br/>The MongoDB default port 27017 is used if `[:Port]` is not specified."
          },
          "w_mode" : {
            "type" : "enum",
            "symbols" : [
              "unsafe",
              "safe"
            ],
            "summary" : "Write Mode",
            "label" : "Write Mode",
            "description" : "Write mode.",
            "default" : "unsafe"
          },
          "r_mode" : {
            "type" : "enum",
            "symbols" : [
              "master",
              "slave_ok"
            ],
            "summary" : "Read Mode",
            "label" : "Read Mode",
            "description" : "Read mode.",
            "default" : "master"
          },
          "replica_set_name" : {
            "type" : "string",
            "summary" : "Replica Set Name",
            "label" : "Replica Set Name",
            "description" : "Name of the replica set."
          },
          "srv_record" : {
            "type" : "boolean",
            "summary" : "Srv Record",
            "label" : "Srv Record",
            "description" : "Use DNS SRV record.",
            "default" : false
          },
          "pool_size" : {
            "type" : "string",
            "summary" : "Connection Pool Size",
            "label" : "Connection Pool Size",
            "description" : "Size of the connection pool towards the bridge target service.",
            "default" : 8
          },
          "username" : {
            "type" : "string",
            "summary" : "Username",
            "label" : "Username",
            "description" : "EMQX's username in the external database."
          },
          "password" : {
            "type" : "string",
            "summary" : "Password",
            "label" : "Password",
            "format" : "password",
            "description" : "EMQX's password in the external database."
          },
          "auth_source" : {
            "type" : "string",
            "summary" : "Auth Source",
            "label" : "Auth Source",
            "description" : "Database name associated with the user's credentials."
          },
          "database" : {
            "type" : "string",
            "summary" : "Database Name",
            "label" : "Database Name",
            "description" : "Database name."
          },
          "topology" : {
            "$ref" : "#/components/schemas/emqx_connector_mongo.topology",
            "label" : "topology",
            "description" : "topology Description"
          },
          "ssl" : {
            "$ref" : "#/components/schemas/broker.ssl_client_opts",
            "summary" : "Enable SSL",
            "label" : "Enable SSL",
            "description" : "SSL connection settings.",
            "default" : {
              "enable" : false
            }
          },
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable or disable",
            "label" : "Enable or disable",
            "description" : "Enable or disable this MongoDB Bridge",
            "default" : true
          },
          "collection" : {
            "type" : "string",
            "summary" : "Collection to be used",
            "label" : "Collection to be used",
            "description" : "The collection where data will be stored into",
            "default" : "mqtt"
          },
          "payload_template" : {
            "type" : "string",
            "summary" : "Payload template",
            "label" : "Payload template",
            "description" : "The template for formatting the outgoing messages.  If undefined, rule engine will use JSON format to serialize all visible inputs, such as clientid, topic, payload etc."
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/resource_schema.creation_opts",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "type" : {
            "type" : "enum",
            "symbols" : [
              "mongodb_rs"
            ],
            "summary" : "Bridge Type",
            "label" : "Bridge Type",
            "description" : "The Bridge Type."
          },
          "name" : {
            "type" : "string",
            "summary" : "Bridge Name",
            "label" : "Bridge Name",
            "description" : "Bridge name."
          }
        },
        "required" : [
          "database",
          "name",
          "replica_set_name",
          "servers",
          "type"
        ]
      },
      "bridge_kafka.put_consumer" : {
        "type" : "object",
        "properties" : {
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable or Disable",
            "label" : "Enable or Disable",
            "description" : "Enable (true) or disable (false) this Kafka bridge.",
            "default" : true
          },
          "bootstrap_hosts" : {
            "type" : "string",
            "summary" : "Bootstrap Hosts",
            "label" : "Bootstrap Hosts",
            "description" : "A comma separated list of Kafka <code>host[:port]</code> endpoints to bootstrap the client. Default port number is 9092."
          },
          "connect_timeout" : {
            "type" : "duration",
            "summary" : "Connect Timeout",
            "label" : "Connect Timeout",
            "description" : "Maximum wait time for TCP connection establishment (including authentication time if enabled).",
            "default" : "5s"
          },
          "min_metadata_refresh_interval" : {
            "type" : "duration",
            "summary" : "Min Metadata Refresh Interval",
            "label" : "Min Metadata Refresh Interval",
            "description" : "Minimum time interval the client has to wait before refreshing Kafka broker and topic metadata. Setting too small value may add extra load on Kafka.",
            "default" : "3s"
          },
          "metadata_request_timeout" : {
            "type" : "duration",
            "summary" : "Metadata Request Timeout",
            "label" : "Metadata Request Timeout",
            "description" : "Maximum wait time when fetching metadata from Kafka.",
            "default" : "5s"
          },
          "authentication" : {
            "oneOf" : [
              {
                "$ref" : "#/components/schemas/bridge_kafka.auth_gssapi_kerberos"
              },
              {
                "$ref" : "#/components/schemas/bridge_kafka.auth_username_password"
              },
              {
                "type" : "enum",
                "symbols" : [
                  "none"
                ]
              }
            ],
            "summary" : "Authentication",
            "label" : "Authentication",
            "description" : "Authentication configs.",
            "default" : "none"
          },
          "socket_opts" : {
            "$ref" : "#/components/schemas/bridge_kafka.socket_opts",
            "summary" : "Socket Options",
            "label" : "Socket Options",
            "description" : "Extra socket options."
          },
          "ssl" : {
            "$ref" : "#/components/schemas/broker.ssl_client_opts",
            "summary" : "Enable SSL",
            "label" : "Enable SSL",
            "description" : "SSL connection settings.",
            "default" : {
              "enable" : false
            }
          },
          "kafka" : {
            "$ref" : "#/components/schemas/bridge_kafka.consumer_kafka_opts",
            "summary" : "Kafka Consumer",
            "label" : "Kafka Consumer",
            "description" : "Kafka consumer configs."
          },
          "topic_mapping" : {
            "type" : "array",
            "summary" : "Topic Mapping",
            "label" : "Topic Mapping",
            "items" : {
              "$ref" : "#/components/schemas/bridge_kafka.consumer_topic_mapping"
            },
            "description" : "Defines the mapping between Kafka topics and MQTT topics. Must contain at least one item."
          },
          "key_encoding_mode" : {
            "type" : "enum",
            "symbols" : [
              "none",
              "base64"
            ],
            "summary" : "Key Encoding Mode",
            "label" : "Key Encoding Mode",
            "description" : "Defines how the key from the Kafka message is encoded before being forwarded via MQTT.<br/><code>none</code> Uses the key from the Kafka message unchanged.  Note: in this case, the key must be a valid UTF-8 string.<br/><code>base64</code> Uses base-64 encoding on the received key.",
            "default" : "none"
          },
          "value_encoding_mode" : {
            "type" : "enum",
            "symbols" : [
              "none",
              "base64"
            ],
            "summary" : "Value Encoding Mode",
            "label" : "Value Encoding Mode",
            "description" : "Defines how the value from the Kafka message is encoded before being forwarded via MQTT.<br/><code>none</code> Uses the value from the Kafka message unchanged.  Note: in this case, the value must be a valid UTF-8 string.<br/><code>base64</code> Uses base-64 encoding on the received value.",
            "default" : "none"
          }
        },
        "required" : [
          "bootstrap_hosts",
          "topic_mapping"
        ]
      },
      "bridge_mongodb.put_single" : {
        "type" : "object",
        "properties" : {
          "mongo_type" : {
            "type" : "enum",
            "symbols" : [
              "single"
            ],
            "summary" : "Standalone instance",
            "label" : "Standalone instance",
            "description" : "Standalone instance. Must be set to 'single' when MongoDB server is running in standalone mode.",
            "default" : "single"
          },
          "server" : {
            "type" : "string",
            "summary" : "Server Host",
            "label" : "Server Host",
            "description" : "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The MongoDB default port 27017 is used if `[:Port]` is not specified."
          },
          "w_mode" : {
            "type" : "enum",
            "symbols" : [
              "unsafe",
              "safe"
            ],
            "summary" : "Write Mode",
            "label" : "Write Mode",
            "description" : "Write mode.",
            "default" : "unsafe"
          },
          "srv_record" : {
            "type" : "boolean",
            "summary" : "Srv Record",
            "label" : "Srv Record",
            "description" : "Use DNS SRV record.",
            "default" : false
          },
          "pool_size" : {
            "type" : "string",
            "summary" : "Connection Pool Size",
            "label" : "Connection Pool Size",
            "description" : "Size of the connection pool towards the bridge target service.",
            "default" : 8
          },
          "username" : {
            "type" : "string",
            "summary" : "Username",
            "label" : "Username",
            "description" : "EMQX's username in the external database."
          },
          "password" : {
            "type" : "string",
            "summary" : "Password",
            "label" : "Password",
            "format" : "password",
            "description" : "EMQX's password in the external database."
          },
          "auth_source" : {
            "type" : "string",
            "summary" : "Auth Source",
            "label" : "Auth Source",
            "description" : "Database name associated with the user's credentials."
          },
          "database" : {
            "type" : "string",
            "summary" : "Database Name",
            "label" : "Database Name",
            "description" : "Database name."
          },
          "topology" : {
            "$ref" : "#/components/schemas/emqx_connector_mongo.topology",
            "label" : "topology",
            "description" : "topology Description"
          },
          "ssl" : {
            "$ref" : "#/components/schemas/broker.ssl_client_opts",
            "summary" : "Enable SSL",
            "label" : "Enable SSL",
            "description" : "SSL connection settings.",
            "default" : {
              "enable" : false
            }
          },
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable or disable",
            "label" : "Enable or disable",
            "description" : "Enable or disable this MongoDB Bridge",
            "default" : true
          },
          "collection" : {
            "type" : "string",
            "summary" : "Collection to be used",
            "label" : "Collection to be used",
            "description" : "The collection where data will be stored into",
            "default" : "mqtt"
          },
          "payload_template" : {
            "type" : "string",
            "summary" : "Payload template",
            "label" : "Payload template",
            "description" : "The template for formatting the outgoing messages.  If undefined, rule engine will use JSON format to serialize all visible inputs, such as clientid, topic, payload etc."
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/resource_schema.creation_opts",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          }
        },
        "required" : [
          "database",
          "server"
        ]
      },
      "bridge_webhook.get" : {
        "type" : "object",
        "properties" : {
          "status" : {
            "type" : "enum",
            "symbols" : [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "summary" : "Bridge Status",
            "label" : "Bridge Status",
            "description" : "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason" : {
            "type" : "string",
            "summary" : "Failure reason",
            "label" : "Failure reason",
            "example" : "Connection refused",
            "description" : "This is the reason given in case a bridge is failing to connect."
          },
          "node_status" : {
            "type" : "array",
            "summary" : "Node Status",
            "label" : "Node Status",
            "items" : {
              "$ref" : "#/components/schemas/bridge.node_status"
            },
            "description" : "Node status."
          },
          "type" : {
            "type" : "enum",
            "symbols" : [
              "webhook"
            ],
            "summary" : "Bridge Type",
            "label" : "Bridge Type",
            "description" : "The Bridge Type"
          },
          "name" : {
            "type" : "string",
            "summary" : "Bridge Name",
            "label" : "Bridge Name",
            "description" : "Bridge name, used as a human-readable description of the bridge."
          },
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/bridge_webhook.creation_opts",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "connect_timeout" : {
            "type" : "duration",
            "summary" : "Connect Timeout",
            "label" : "Connect Timeout",
            "description" : "The timeout when connecting to the HTTP server.",
            "default" : "15s"
          },
          "retry_interval" : {
            "type" : "duration",
            "label" : "retry_interval",
            "description" : "retry_interval Description",
            "deprecated" : true
          },
          "pool_type" : {
            "type" : "enum",
            "symbols" : [
              "random",
              "hash"
            ],
            "summary" : "Pool Type",
            "label" : "Pool Type",
            "description" : "The type of the pool. Can be one of `random`, `hash`.",
            "default" : "random"
          },
          "pool_size" : {
            "type" : "string",
            "summary" : "Pool Size",
            "label" : "Pool Size",
            "description" : "The pool size.",
            "default" : 8
          },
          "enable_pipelining" : {
            "type" : "string",
            "summary" : "HTTP Pipelineing",
            "label" : "HTTP Pipelineing",
            "description" : "A positive integer. Whether to send HTTP requests continuously, when set to 1, it means that after each HTTP request is sent, you need to wait for the server to return and then continue to send the next request.",
            "default" : 100
          },
          "request" : {
            "$ref" : "#/components/schemas/connector-http.request",
            "summary" : "Request",
            "label" : "Request",
            "description" : "Configure HTTP request parameters."
          },
          "ssl" : {
            "$ref" : "#/components/schemas/broker.ssl_client_opts",
            "summary" : "Enable SSL",
            "label" : "Enable SSL",
            "description" : "SSL connection settings.",
            "default" : {
              "enable" : false
            }
          },
          "url" : {
            "type" : "string",
            "summary" : "HTTP Bridge",
            "label" : "HTTP Bridge",
            "description" : "The URL of the HTTP Bridge.<br/><br/>Template with variables is allowed in the path, but variables cannot be used in the scheme, host,<br/>or port part.<br/><br/>For example, <code> http://localhost:9901/${topic} </code> is allowed, but<br/><code> http://${host}:9901/message </code> or <code> http://localhost:${port}/message </code><br/>is not allowed."
          },
          "direction" : {
            "type" : "enum",
            "symbols" : [
              "egress"
            ],
            "summary" : "Bridge Direction",
            "label" : "Bridge Direction",
            "description" : "Deprecated, The direction of this bridge, MUST be 'egress'",
            "deprecated" : true
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "The MQTT topic filter to be forwarded to the HTTP server. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "method" : {
            "type" : "enum",
            "symbols" : [
              "post",
              "put",
              "get",
              "delete"
            ],
            "summary" : "HTTP Method",
            "label" : "HTTP Method",
            "description" : "The method of the HTTP request. All the available methods are: post, put, get, delete.<br/><br/>Template with variables is allowed.",
            "default" : "post"
          },
          "headers" : {
            "type" : "object",
            "summary" : "HTTP Header",
            "label" : "HTTP Header",
            "description" : "The headers of the HTTP request.<br/><br/>Template with variables is allowed.",
            "default" : {
              "keep-alive" : "timeout=5",
              "content-type" : "application/json",
              "connection" : "keep-alive",
              "cache-control" : "no-cache",
              "accept" : "application/json"
            }
          },
          "body" : {
            "type" : "string",
            "summary" : "HTTP Body",
            "label" : "HTTP Body",
            "description" : "The body of the HTTP request.<br/><br/>If not provided, the body will be a JSON object of all the available fields.<br/><br/>There, 'all the available fields' means the context of a MQTT message when<br/>this webhook is triggered by receiving a MQTT message (the `local_topic` is set),<br/>or the context of the event when this webhook is triggered by a rule (i.e. this<br/>webhook is used as an action of a rule).<br/><br/>Template with variables is allowed."
          },
          "max_retries" : {
            "type" : "number",
            "summary" : "HTTP Request Max Retries",
            "minimum" : 1,
            "label" : "HTTP Request Max Retries",
            "description" : "HTTP request max retry times if failed.",
            "default" : 2
          },
          "request_timeout" : {
            "type" : "duration",
            "summary" : "HTTP Request Timeout",
            "label" : "HTTP Request Timeout",
            "description" : "HTTP request timeout.",
            "default" : "15s"
          }
        },
        "required" : [
          "name",
          "type",
          "url"
        ]
      },
      "bridge_redis.put_cluster" : {
        "type" : "object",
        "properties" : {
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "The MQTT topic filter to be forwarded to Redis. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "command_template" : {
            "type" : "array",
            "summary" : "Redis Command Template",
            "label" : "Redis Command Template",
            "items" : {
              "type" : "string"
            },
            "description" : "Redis command template used to export messages. Each list element stands for a command name or its argument.<br/>For example, to push payloads in a Redis list by key `msgs`, the elements should be the following:<br/>`rpush`, `msgs`, `${payload}`."
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/bridge_redis.creation_opts_redis_cluster",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "servers" : {
            "type" : "string",
            "summary" : "Servers",
            "label" : "Servers",
            "description" : "A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`<br/>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.<br/>A host entry has the following form: `Host[:Port]`.<br/>The Redis default port 6379 is used if `[:Port]` is not specified."
          },
          "redis_type" : {
            "type" : "enum",
            "symbols" : [
              "cluster"
            ],
            "summary" : "Cluster Mode",
            "label" : "Cluster Mode",
            "description" : "Cluster mode. Must be set to 'cluster' when Redis server is running in clustered mode.",
            "default" : "cluster"
          },
          "pool_size" : {
            "type" : "string",
            "summary" : "Connection Pool Size",
            "label" : "Connection Pool Size",
            "description" : "Size of the connection pool towards the bridge target service.",
            "default" : 8
          },
          "password" : {
            "type" : "string",
            "summary" : "Password",
            "label" : "Password",
            "format" : "password",
            "description" : "EMQX's password in the external database."
          },
          "auto_reconnect" : {
            "type" : "boolean",
            "summary" : "Deprecated. Auto Reconnect Database",
            "label" : "Deprecated. Auto Reconnect Database",
            "description" : "Deprecated. Enable automatic reconnect to the database.",
            "deprecated" : true,
            "default" : true
          },
          "ssl" : {
            "$ref" : "#/components/schemas/broker.ssl_client_opts",
            "summary" : "Enable SSL",
            "label" : "Enable SSL",
            "description" : "SSL connection settings.",
            "default" : {
              "enable" : false
            }
          }
        },
        "required" : [
          "command_template",
          "servers"
        ]
      },
      "bridge_rocketmq.post" : {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "enum",
            "symbols" : [
              "rocketmq"
            ],
            "summary" : "Bridge Type",
            "label" : "Bridge Type",
            "description" : "The Bridge Type"
          },
          "name" : {
            "type" : "string",
            "summary" : "Bridge Name",
            "label" : "Bridge Name",
            "description" : "Bridge name."
          },
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "template" : {
            "type" : "string",
            "summary" : "Template",
            "label" : "Template",
            "description" : "Template, the default value is empty. When this value is empty the whole message will be stored in the RocketMQ.<br><br/>            The template can be any valid string with placeholders, example:<br><br/>            - ${id}, ${username}, ${clientid}, ${timestamp}<br><br/>            - {\"id\" : ${id}, \"username\" : ${username}}",
            "default" : ""
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "The MQTT topic filter to be forwarded to RocketMQ. All MQTT `PUBLISH` messages with the topic<br/>matching the `local_topic` will be forwarded.</br><br/>NOTE: if the bridge is used as a rule action, `local_topic` should be left empty otherwise the messages will be duplicated."
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/resource_schema.creation_opts",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "servers" : {
            "type" : "string",
            "summary" : "Server Host",
            "label" : "Server Host",
            "description" : "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The RocketMQ default port 9876 is used if `[:Port]` is not specified."
          },
          "topic" : {
            "type" : "string",
            "summary" : "RocketMQ Topic",
            "label" : "RocketMQ Topic",
            "description" : "RocketMQ Topic",
            "default" : "TopicTest"
          },
          "access_key" : {
            "type" : "string",
            "summary" : "AccessKey",
            "label" : "AccessKey",
            "description" : "RocketMQ server `accessKey`.",
            "default" : ""
          },
          "secret_key" : {
            "type" : "string",
            "summary" : "SecretKey",
            "label" : "SecretKey",
            "description" : "RocketMQ server `secretKey`.",
            "default" : ""
          },
          "security_token" : {
            "type" : "string",
            "summary" : "Security Token",
            "label" : "Security Token",
            "description" : "RocketMQ Server Security Token",
            "default" : ""
          },
          "sync_timeout" : {
            "type" : "duration",
            "summary" : "Sync Timeout",
            "label" : "Sync Timeout",
            "description" : "Timeout of RocketMQ driver synchronous call.",
            "default" : "3s"
          },
          "refresh_interval" : {
            "type" : "duration",
            "summary" : "Topic Route Refresh Interval",
            "label" : "Topic Route Refresh Interval",
            "description" : "RocketMQ Topic Route Refresh Interval.",
            "default" : "3s"
          },
          "send_buffer" : {
            "type" : "byteSize",
            "summary" : "Send Buffer Size",
            "label" : "Send Buffer Size",
            "description" : "The socket send buffer size of the RocketMQ driver client.",
            "default" : "1024KB"
          },
          "pool_size" : {
            "type" : "string",
            "summary" : "Connection Pool Size",
            "label" : "Connection Pool Size",
            "description" : "Size of the connection pool towards the bridge target service.",
            "default" : 8
          },
          "auto_reconnect" : {
            "type" : "boolean",
            "summary" : "Deprecated. Auto Reconnect Database",
            "label" : "Deprecated. Auto Reconnect Database",
            "description" : "Deprecated. Enable automatic reconnect to the database.",
            "deprecated" : true,
            "default" : true
          }
        },
        "required" : [
          "name",
          "servers",
          "type"
        ]
      },
      "bridge_clickhouse.post" : {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "enum",
            "symbols" : [
              "clickhouse"
            ],
            "summary" : "Bridge Type",
            "label" : "Bridge Type",
            "description" : "The Bridge Type"
          },
          "name" : {
            "type" : "string",
            "summary" : "Bridge Name",
            "label" : "Bridge Name",
            "description" : "Bridge name."
          },
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "sql" : {
            "type" : "string",
            "summary" : "SQL Template",
            "label" : "SQL Template",
            "format" : "sql",
            "description" : "The template string can contain ${field} placeholders for message metadata and payload field. Make sure that the inserted values are formatted and escaped correctly. [Prepared Statement](https://docs.emqx.com/en/enterprise/v5.0/data-integration/data-bridges.html#Prepared-Statement) is not supported.",
            "default" : "INSERT INTO mqtt_test(payload, arrived) VALUES ('${payload}', ${timestamp})"
          },
          "batch_value_separator" : {
            "type" : "string",
            "summary" : "Batch Value Separator",
            "label" : "Batch Value Separator",
            "description" : "The default value ',' works for the VALUES format. You can also use other separator if other format is specified. See [INSERT INTO Statement](https://clickhouse.com/docs/en/sql-reference/statements/insert-into).",
            "default" : ", "
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "The MQTT topic filter to be forwarded to Clickhouse. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/bridge_clickhouse.creation_opts",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "url" : {
            "type" : "url",
            "summary" : "Server URL",
            "label" : "Server URL",
            "description" : "The HTTP URL to the Clickhouse server that you want to connect to (for example http://myhostname:8123)"
          },
          "connect_timeout" : {
            "type" : "duration",
            "summary" : "Clickhouse Timeout",
            "label" : "Clickhouse Timeout",
            "description" : "The timeout when connecting to the Clickhouse server.",
            "default" : "15s"
          },
          "database" : {
            "type" : "string",
            "summary" : "Database Name",
            "label" : "Database Name",
            "description" : "Database name."
          },
          "pool_size" : {
            "type" : "string",
            "summary" : "Connection Pool Size",
            "label" : "Connection Pool Size",
            "description" : "Size of the connection pool towards the bridge target service.",
            "default" : 8
          },
          "username" : {
            "type" : "string",
            "summary" : "Username",
            "label" : "Username",
            "description" : "EMQX's username in the external database."
          },
          "password" : {
            "type" : "string",
            "summary" : "Password",
            "label" : "Password",
            "format" : "password",
            "description" : "EMQX's password in the external database."
          },
          "auto_reconnect" : {
            "type" : "boolean",
            "summary" : "Deprecated. Auto Reconnect Database",
            "label" : "Deprecated. Auto Reconnect Database",
            "description" : "Deprecated. Enable automatic reconnect to the database.",
            "deprecated" : true,
            "default" : true
          }
        },
        "required" : [
          "database",
          "name",
          "type",
          "url"
        ]
      },
      "bridge_kafka.consumer_topic_mapping" : {
        "type" : "object",
        "properties" : {
          "kafka_topic" : {
            "type" : "string",
            "summary" : "Kafka Topic",
            "label" : "Kafka Topic",
            "description" : "Kafka topic to consume from."
          },
          "mqtt_topic" : {
            "type" : "string",
            "summary" : "MQTT Topic",
            "label" : "MQTT Topic",
            "description" : "Local topic to which consumed Kafka messages should be published to."
          },
          "qos" : {
            "type" : "enum",
            "symbols" : [
              0,
              1,
              2
            ],
            "summary" : "QoS",
            "label" : "QoS",
            "description" : "MQTT QoS used to publish messages consumed from Kafka.",
            "default" : 0
          },
          "payload_template" : {
            "type" : "string",
            "summary" : "MQTT Payload Template",
            "label" : "MQTT Payload Template",
            "description" : "The template for transforming the incoming Kafka message.  By default, it will use JSON format to serialize inputs from the Kafka message.  Such fields are:<br/><code>headers</code>: an object containing string key-value pairs.<br/><code>key</code>: Kafka message key (uses the chosen key encoding).<br/><code>offset</code>: offset for the message.<br/><code>topic</code>: Kafka topic.<br/><code>ts</code>: message timestamp.<br/><code>ts_type</code>: message timestamp type, which is one of <code>create</code>, <code>append</code> or <code>undefined</code>.<br/><code>value</code>: Kafka message value (uses the chosen value encoding).",
            "default" : "${.}"
          }
        },
        "required" : [
          "kafka_topic",
          "mqtt_topic"
        ]
      },
      "bridge_influxdb.post_api_v2" : {
        "type" : "object",
        "properties" : {
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "The MQTT topic filter to be forwarded to the InfluxDB. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "write_syntax" : {
            "type" : "string",
            "summary" : "Write Syntax",
            "label" : "Write Syntax",
            "format" : "sql",
            "description" : "Conf of InfluxDB line protocol to write data points. It is a text-based format that provides the measurement, tag set, field set, and timestamp of a data point, and placeholder supported.<br/>See also [InfluxDB 2.3 Line Protocol](https://docs.influxdata.com/influxdb/v2.3/reference/syntax/line-protocol/) and<br/>[InfluxDB 1.8 Line Protocol](https://docs.influxdata.com/influxdb/v1.8/write_protocols/line_protocol_tutorial/) </br><br/>TLDR:</br><br/>```<br/><measurement>[,<tag_key>=<tag_value>[,<tag_key>=<tag_value>]] <field_key>=<field_value>[,<field_key>=<field_value>] [<timestamp>]<br/>```<br/>Please note that a placeholder for an integer value must be annotated with a suffix `i`. For example `${payload.int_value}i`."
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/resource_schema.creation_opts",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "server" : {
            "type" : "string",
            "summary" : "Server Host",
            "label" : "Server Host",
            "description" : "The IPv4 or IPv6 address or the hostname to connect to.</br><br/>A host entry has the following form: `Host[:Port]`.</br><br/>The InfluxDB default port 8086 is used if `[:Port]` is not specified.",
            "default" : "127.0.0.1:8086"
          },
          "precision" : {
            "type" : "enum",
            "symbols" : [
              "ns",
              "us",
              "ms",
              "s"
            ],
            "summary" : "Time Precision",
            "label" : "Time Precision",
            "description" : "InfluxDB time precision.",
            "default" : "ms"
          },
          "bucket" : {
            "type" : "string",
            "summary" : "Bucket",
            "label" : "Bucket",
            "description" : "InfluxDB bucket name."
          },
          "org" : {
            "type" : "string",
            "summary" : "Organization",
            "label" : "Organization",
            "description" : "Organization name of InfluxDB."
          },
          "token" : {
            "type" : "string",
            "summary" : "Token",
            "label" : "Token",
            "description" : "InfluxDB token."
          },
          "ssl" : {
            "$ref" : "#/components/schemas/broker.ssl_client_opts",
            "summary" : "Enable SSL",
            "label" : "Enable SSL",
            "description" : "SSL connection settings.",
            "default" : {
              "enable" : false
            }
          },
          "type" : {
            "type" : "enum",
            "symbols" : [
              "influxdb_api_v2"
            ],
            "summary" : "Bridge Type",
            "label" : "Bridge Type",
            "description" : "The Bridge Type."
          },
          "name" : {
            "type" : "string",
            "summary" : "Bridge Name",
            "label" : "Bridge Name",
            "description" : "Bridge name."
          }
        },
        "required" : [
          "bucket",
          "name",
          "org",
          "token",
          "type",
          "write_syntax"
        ]
      },
      "emqx_connector_mongo.topology" : {
        "type" : "object",
        "properties" : {
          "pool_size" : {
            "type" : "string",
            "summary" : "Connection Pool Size",
            "label" : "Connection Pool Size",
            "description" : "Size of the connection pool towards the bridge target service.",
            "default" : 8
          },
          "max_overflow" : {
            "type" : "number",
            "summary" : "Max Overflow",
            "minimum" : 1,
            "label" : "Max Overflow",
            "description" : "Max Overflow.",
            "default" : 0
          },
          "overflow_ttl" : {
            "type" : "duration",
            "summary" : "Overflow TTL",
            "label" : "Overflow TTL",
            "description" : "Period of time before workers that exceed the configured pool size (\"overflow\") to be terminated."
          },
          "overflow_check_period" : {
            "type" : "duration",
            "summary" : "Overflow Check Period",
            "label" : "Overflow Check Period",
            "description" : "Period for checking if there are more workers than configured (\"overflow\")."
          },
          "local_threshold_ms" : {
            "type" : "duration",
            "summary" : "Local Threshold",
            "label" : "Local Threshold",
            "description" : "The size of the latency window for selecting among multiple suitable MongoDB instances."
          },
          "connect_timeout_ms" : {
            "type" : "duration",
            "summary" : "Connect Timeout",
            "label" : "Connect Timeout",
            "description" : "The duration to attempt a connection before timing out."
          },
          "socket_timeout_ms" : {
            "type" : "duration",
            "summary" : "Socket Timeout",
            "label" : "Socket Timeout",
            "description" : "The duration to attempt to send or to receive on a socket before the attempt times out."
          },
          "server_selection_timeout_ms" : {
            "type" : "duration",
            "summary" : "Server Selection Timeout",
            "label" : "Server Selection Timeout",
            "description" : "Specifies how long to block for server selection before throwing an exception."
          },
          "wait_queue_timeout_ms" : {
            "type" : "duration",
            "summary" : "Wait Queue Timeout",
            "label" : "Wait Queue Timeout",
            "description" : "The maximum duration that a worker can wait for a connection to become available."
          },
          "heartbeat_frequency_ms" : {
            "type" : "duration",
            "summary" : "Heartbeat period",
            "label" : "Heartbeat period",
            "description" : "Controls when the driver checks the state of the MongoDB deployment. Specify the interval between checks, counted from the end of the previous check until the beginning of the next one. If the number of connections is increased (which will happen, for example, if you increase the pool size), you may need to increase this period as well to avoid creating too many log entries in the MongoDB log file.",
            "default" : "200s"
          },
          "min_heartbeat_frequency_ms" : {
            "type" : "duration",
            "summary" : "Minimum Heartbeat Period",
            "label" : "Minimum Heartbeat Period",
            "description" : "Controls the minimum amount of time to wait between heartbeats."
          }
        }
      },
      "bridge_kafka.post_producer" : {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "enum",
            "symbols" : [
              "kafka_consumer",
              "kafka"
            ],
            "summary" : "Bridge Type",
            "label" : "Bridge Type",
            "description" : "The Bridge Type"
          },
          "name" : {
            "type" : "string",
            "summary" : "Bridge Name",
            "label" : "Bridge Name",
            "description" : "Bridge name, used as a human-readable description of the bridge."
          },
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable or Disable",
            "label" : "Enable or Disable",
            "description" : "Enable (true) or disable (false) this Kafka bridge.",
            "default" : true
          },
          "bootstrap_hosts" : {
            "type" : "string",
            "summary" : "Bootstrap Hosts",
            "label" : "Bootstrap Hosts",
            "description" : "A comma separated list of Kafka <code>host[:port]</code> endpoints to bootstrap the client. Default port number is 9092."
          },
          "connect_timeout" : {
            "type" : "duration",
            "summary" : "Connect Timeout",
            "label" : "Connect Timeout",
            "description" : "Maximum wait time for TCP connection establishment (including authentication time if enabled).",
            "default" : "5s"
          },
          "min_metadata_refresh_interval" : {
            "type" : "duration",
            "summary" : "Min Metadata Refresh Interval",
            "label" : "Min Metadata Refresh Interval",
            "description" : "Minimum time interval the client has to wait before refreshing Kafka broker and topic metadata. Setting too small value may add extra load on Kafka.",
            "default" : "3s"
          },
          "metadata_request_timeout" : {
            "type" : "duration",
            "summary" : "Metadata Request Timeout",
            "label" : "Metadata Request Timeout",
            "description" : "Maximum wait time when fetching metadata from Kafka.",
            "default" : "5s"
          },
          "authentication" : {
            "oneOf" : [
              {
                "$ref" : "#/components/schemas/bridge_kafka.auth_gssapi_kerberos"
              },
              {
                "$ref" : "#/components/schemas/bridge_kafka.auth_username_password"
              },
              {
                "type" : "enum",
                "symbols" : [
                  "none"
                ]
              }
            ],
            "summary" : "Authentication",
            "label" : "Authentication",
            "description" : "Authentication configs.",
            "default" : "none"
          },
          "socket_opts" : {
            "$ref" : "#/components/schemas/bridge_kafka.socket_opts",
            "summary" : "Socket Options",
            "label" : "Socket Options",
            "description" : "Extra socket options."
          },
          "ssl" : {
            "$ref" : "#/components/schemas/broker.ssl_client_opts",
            "summary" : "Enable SSL",
            "label" : "Enable SSL",
            "description" : "SSL connection settings.",
            "default" : {
              "enable" : false
            }
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Source MQTT Topic",
            "label" : "Source MQTT Topic",
            "description" : "MQTT topic or topic filter as data source (bridge input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in Kafka."
          },
          "kafka" : {
            "$ref" : "#/components/schemas/bridge_kafka.producer_kafka_opts",
            "summary" : "Kafka Producer",
            "label" : "Kafka Producer",
            "description" : "Kafka producer configs."
          }
        },
        "required" : [
          "bootstrap_hosts",
          "kafka",
          "name",
          "type"
        ]
      },
      "bridge_kafka.get_producer" : {
        "type" : "object",
        "properties" : {
          "status" : {
            "type" : "enum",
            "symbols" : [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "summary" : "Bridge Status",
            "label" : "Bridge Status",
            "description" : "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason" : {
            "type" : "string",
            "summary" : "Failure reason",
            "label" : "Failure reason",
            "example" : "Connection refused",
            "description" : "This is the reason given in case a bridge is failing to connect."
          },
          "node_status" : {
            "type" : "array",
            "summary" : "Node Status",
            "label" : "Node Status",
            "items" : {
              "$ref" : "#/components/schemas/bridge.node_status"
            },
            "description" : "Node status."
          },
          "type" : {
            "type" : "enum",
            "symbols" : [
              "kafka_consumer",
              "kafka"
            ],
            "summary" : "Bridge Type",
            "label" : "Bridge Type",
            "description" : "The Bridge Type"
          },
          "name" : {
            "type" : "string",
            "summary" : "Bridge Name",
            "label" : "Bridge Name",
            "description" : "Bridge name, used as a human-readable description of the bridge."
          },
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable or Disable",
            "label" : "Enable or Disable",
            "description" : "Enable (true) or disable (false) this Kafka bridge.",
            "default" : true
          },
          "bootstrap_hosts" : {
            "type" : "string",
            "summary" : "Bootstrap Hosts",
            "label" : "Bootstrap Hosts",
            "description" : "A comma separated list of Kafka <code>host[:port]</code> endpoints to bootstrap the client. Default port number is 9092."
          },
          "connect_timeout" : {
            "type" : "duration",
            "summary" : "Connect Timeout",
            "label" : "Connect Timeout",
            "description" : "Maximum wait time for TCP connection establishment (including authentication time if enabled).",
            "default" : "5s"
          },
          "min_metadata_refresh_interval" : {
            "type" : "duration",
            "summary" : "Min Metadata Refresh Interval",
            "label" : "Min Metadata Refresh Interval",
            "description" : "Minimum time interval the client has to wait before refreshing Kafka broker and topic metadata. Setting too small value may add extra load on Kafka.",
            "default" : "3s"
          },
          "metadata_request_timeout" : {
            "type" : "duration",
            "summary" : "Metadata Request Timeout",
            "label" : "Metadata Request Timeout",
            "description" : "Maximum wait time when fetching metadata from Kafka.",
            "default" : "5s"
          },
          "authentication" : {
            "oneOf" : [
              {
                "$ref" : "#/components/schemas/bridge_kafka.auth_gssapi_kerberos"
              },
              {
                "$ref" : "#/components/schemas/bridge_kafka.auth_username_password"
              },
              {
                "type" : "enum",
                "symbols" : [
                  "none"
                ]
              }
            ],
            "summary" : "Authentication",
            "label" : "Authentication",
            "description" : "Authentication configs.",
            "default" : "none"
          },
          "socket_opts" : {
            "$ref" : "#/components/schemas/bridge_kafka.socket_opts",
            "summary" : "Socket Options",
            "label" : "Socket Options",
            "description" : "Extra socket options."
          },
          "ssl" : {
            "$ref" : "#/components/schemas/broker.ssl_client_opts",
            "summary" : "Enable SSL",
            "label" : "Enable SSL",
            "description" : "SSL connection settings.",
            "default" : {
              "enable" : false
            }
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Source MQTT Topic",
            "label" : "Source MQTT Topic",
            "description" : "MQTT topic or topic filter as data source (bridge input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in Kafka."
          },
          "kafka" : {
            "$ref" : "#/components/schemas/bridge_kafka.producer_kafka_opts",
            "summary" : "Kafka Producer",
            "label" : "Kafka Producer",
            "description" : "Kafka producer configs."
          }
        },
        "required" : [
          "bootstrap_hosts",
          "kafka",
          "name",
          "type"
        ]
      },
      "bridge_gcp_pubsub.get" : {
        "type" : "object",
        "properties" : {
          "status" : {
            "type" : "enum",
            "symbols" : [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "summary" : "Bridge Status",
            "label" : "Bridge Status",
            "description" : "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason" : {
            "type" : "string",
            "summary" : "Failure reason",
            "label" : "Failure reason",
            "example" : "Connection refused",
            "description" : "This is the reason given in case a bridge is failing to connect."
          },
          "node_status" : {
            "type" : "array",
            "summary" : "Node Status",
            "label" : "Node Status",
            "items" : {
              "$ref" : "#/components/schemas/bridge.node_status"
            },
            "description" : "Node status."
          },
          "type" : {
            "type" : "enum",
            "symbols" : [
              "gcp_pubsub"
            ],
            "summary" : "Bridge Type",
            "label" : "Bridge Type",
            "description" : "The Bridge Type"
          },
          "name" : {
            "type" : "string",
            "summary" : "Bridge Name",
            "label" : "Bridge Name",
            "description" : "Bridge name, used as a human-readable description of the bridge."
          },
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/resource_schema.creation_opts",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "connect_timeout" : {
            "type" : "duration",
            "summary" : "Connect Timeout",
            "label" : "Connect Timeout",
            "description" : "The timeout when connecting to the HTTP server.",
            "default" : "15s"
          },
          "pool_size" : {
            "type" : "string",
            "summary" : "Pool Size",
            "label" : "Pool Size",
            "description" : "The pool size.",
            "default" : 8
          },
          "pipelining" : {
            "type" : "string",
            "summary" : "HTTP Pipelineing",
            "label" : "HTTP Pipelineing",
            "description" : "A positive integer. Whether to send HTTP requests continuously, when set to 1, it means that after each HTTP request is sent, you need to wait for the server to return and then continue to send the next request.",
            "default" : 100
          },
          "max_retries" : {
            "type" : "number",
            "summary" : "Max Retries",
            "minimum" : 1,
            "label" : "Max Retries",
            "description" : "Max retry times if an error occurs when sending a request.",
            "default" : 2
          },
          "request_timeout" : {
            "type" : "duration",
            "summary" : "Request Timeout",
            "label" : "Request Timeout",
            "description" : "Deprecated: Configure the request timeout in the buffer settings.",
            "deprecated" : true,
            "default" : "15s"
          },
          "payload_template" : {
            "type" : "string",
            "summary" : "Payload template",
            "label" : "Payload template",
            "description" : "The template for formatting the outgoing messages.  If undefined, will send all the available context in JSON format.",
            "default" : ""
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "The MQTT topic filter to be forwarded to GCP PubSub. All MQTT 'PUBLISH' messages with the topic<br/>matching `local_topic` will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "pubsub_topic" : {
            "type" : "string",
            "summary" : "GCP PubSub Topic",
            "label" : "GCP PubSub Topic",
            "description" : "The GCP PubSub topic to publish messages to."
          },
          "service_account_json" : {
            "type" : "string",
            "summary" : "GCP Service Account Credentials",
            "label" : "GCP Service Account Credentials",
            "description" : "JSON containing the GCP Service Account credentials to be used with PubSub.<br/>When a GCP Service Account is created (as described in https://developers.google.com/identity/protocols/oauth2/service-account#creatinganaccount), you have the option of downloading the credentials in JSON form.  That's the file needed."
          }
        },
        "required" : [
          "name",
          "pubsub_topic",
          "service_account_json",
          "type"
        ]
      },
      "bridge_redis.creation_opts_redis_cluster" : {
        "type" : "object",
        "properties" : {
          "worker_pool_size" : {
            "type" : "number",
            "summary" : "Buffer Pool Size",
            "minimum" : 1,
            "label" : "Buffer Pool Size",
            "description" : "The number of buffer workers. Only applicable for egress type bridges.<br/>For bridges only have ingress direction data flow, it can be set to 0 otherwise must be greater than 0.",
            "default" : 16
          },
          "health_check_interval" : {
            "type" : "duration",
            "summary" : "Health Check Interval",
            "label" : "Health Check Interval",
            "description" : "Health check interval.",
            "default" : "15s"
          },
          "start_after_created" : {
            "type" : "boolean",
            "summary" : "Start After Created",
            "label" : "Start After Created",
            "description" : "Whether start the resource right after created.",
            "default" : "true"
          },
          "start_timeout" : {
            "type" : "duration",
            "summary" : "Start Timeout",
            "label" : "Start Timeout",
            "description" : "Time interval to wait for an auto-started resource to become healthy before responding resource creation requests.",
            "default" : "5s"
          },
          "auto_restart_interval" : {
            "oneOf" : [
              {
                "type" : "duration"
              },
              {
                "type" : "enum",
                "symbols" : [
                  "infinity"
                ]
              }
            ],
            "summary" : "Auto Restart Interval",
            "label" : "Auto Restart Interval",
            "description" : "The auto restart interval after the resource is disconnected.",
            "default" : "60s"
          },
          "query_mode" : {
            "type" : "enum",
            "symbols" : [
              "sync",
              "async"
            ],
            "summary" : "Query mode",
            "label" : "Query mode",
            "description" : "Query mode. Optional 'sync/async', default 'async'.",
            "default" : "async"
          },
          "request_timeout" : {
            "oneOf" : [
              {
                "type" : "duration"
              },
              {
                "type" : "enum",
                "symbols" : [
                  "infinity"
                ]
              }
            ],
            "summary" : "Request Expiry",
            "label" : "Request Expiry",
            "description" : "Starting from the moment when the request enters the buffer, if the request remains in the buffer for the specified time or is sent but does not receive a response or acknowledgement in time, the request is considered expired.",
            "default" : "15s"
          },
          "inflight_window" : {
            "type" : "string",
            "summary" : "Inflight window",
            "label" : "Inflight window",
            "description" : "Query inflight window. When query_mode is set to async, this config has to be set to 1 if messages from the same MQTT client have to be strictly ordered.",
            "default" : 100
          },
          "enable_queue" : {
            "type" : "boolean",
            "summary" : "Enable disk buffer queue",
            "label" : "Enable disk buffer queue",
            "description" : "Enable disk buffer queue (only applicable for egress bridges).<br/>When Enabled, messages will be buffered on disk when the bridge connection is down.<br/>When disabled the messages are buffered in RAM only.",
            "deprecated" : true,
            "default" : false
          },
          "max_buffer_bytes" : {
            "type" : "byteSize",
            "summary" : "Max buffer queue size",
            "label" : "Max buffer queue size",
            "description" : "Maximum number of bytes to buffer for each buffer worker.",
            "default" : "256MB"
          }
        }
      },
      "connector-mqtt.ingress_remote" : {
        "type" : "object",
        "properties" : {
          "topic" : {
            "type" : "string",
            "summary" : "Remote Topic",
            "label" : "Remote Topic",
            "description" : "Receive messages from which topic of the remote broker"
          },
          "qos" : {
            "type" : "enum",
            "symbols" : [
              0,
              1,
              2
            ],
            "summary" : "Remote QoS",
            "label" : "Remote QoS",
            "description" : "The QoS level to be used when subscribing to the remote broker",
            "default" : 1
          }
        },
        "required" : [
          "topic"
        ]
      },
      "broker.ssl_client_opts" : {
        "type" : "object",
        "properties" : {
          "cacertfile" : {
            "type" : "string",
            "summary" : "CACertfile",
            "label" : "CACertfile",
            "description" : "Trusted PEM format CA certificates bundle file.<br/><br/>The certificates in this file are used to verify the TLS peer's certificates.<br/>Append new certificates to the file if new CAs are to be trusted.<br/>There is no need to restart EMQX to have the updated file loaded, because<br/>the system regularly checks if file has been updated (and reload).<br/><br/>NOTE: invalidating (deleting) a certificate from the file will not affect<br/>already established connections."
          },
          "certfile" : {
            "type" : "string",
            "summary" : "Certfile",
            "label" : "Certfile",
            "description" : "PEM format certificates chain file.<br/><br/>The certificates in this file should be in reversed order of the certificate<br/>issue chain. That is, the host's certificate should be placed in the beginning<br/>of the file, followed by the immediate issuer certificate and so on.<br/>Although the root CA certificate is optional, it should be placed at the end of<br/>the file if it is to be added."
          },
          "keyfile" : {
            "type" : "string",
            "summary" : "Keyfile",
            "label" : "Keyfile",
            "description" : "PEM format private key file."
          },
          "verify" : {
            "type" : "enum",
            "symbols" : [
              "verify_peer",
              "verify_none"
            ],
            "summary" : "Verify peer",
            "label" : "Verify peer",
            "description" : "Enable or disable peer verification.",
            "default" : "verify_none"
          },
          "reuse_sessions" : {
            "type" : "boolean",
            "summary" : "TLS session reuse",
            "label" : "TLS session reuse",
            "description" : "Enable TLS session reuse.",
            "default" : true
          },
          "depth" : {
            "type" : "number",
            "summary" : "CACert Depth",
            "label" : "CACert Depth",
            "description" : "Maximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path.<br/>So, if depth is 0 the PEER must be signed by the trusted ROOT-CA directly;<br/><br/>if 1 the path can be PEER, Intermediate-CA, ROOT-CA;<br/><br/>if 2 the path can be PEER, Intermediate-CA1, Intermediate-CA2, ROOT-CA.",
            "default" : 10
          },
          "password" : {
            "type" : "string",
            "summary" : "Keyfile passphrase",
            "label" : "Keyfile passphrase",
            "format" : "password",
            "example" : "",
            "description" : "String containing the user's password. Only used if the private key file is password-protected."
          },
          "versions" : {
            "type" : "array",
            "summary" : "SSL versions",
            "label" : "SSL versions",
            "items" : {
              "type" : "string"
            },
            "description" : "All TLS/DTLS versions to be supported.<br/><br/>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config.<br/><br/>In case PSK cipher suites are intended, make sure to configure<br/><code>['tlsv1.2', 'tlsv1.1']</code> here.",
            "default" : [
              "tlsv1.3",
              "tlsv1.2",
              "tlsv1.1",
              "tlsv1"
            ]
          },
          "ciphers" : {
            "type" : "array",
            "summary" : "",
            "label" : "",
            "items" : {
              "type" : "string"
            },
            "description" : "This config holds TLS cipher suite names separated by comma,<br/>or as an array of strings. e.g.<br/><code>\"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256\"</code> or<br/><code>[\"TLS_AES_256_GCM_SHA384\",\"TLS_AES_128_GCM_SHA256\"]</code>.<br/><br/><br/>Ciphers (and their ordering) define the way in which the<br/>client and server encrypts information over the network connection.<br/>Selecting a good cipher suite is critical for the<br/>application's data security, confidentiality and performance.<br/><br/>The names should be in OpenSSL string format (not RFC format).<br/>All default values and examples provided by EMQX config<br/>documentation are all in OpenSSL format.<br/><br/><br/>NOTE: Certain cipher suites are only compatible with<br/>specific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')<br/>incompatible cipher suites will be silently dropped.<br/>For instance, if only 'tlsv1.3' is given in the <code>versions</code>,<br/>configuring cipher suites for other versions will have no effect.<br/><br/><br/><br/>NOTE: PSK ciphers are suppressed by 'tlsv1.3' version config<br/><br/>If PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.<br/><br/>PSK cipher suites: <code>\"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,<br/>RSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,<br/>RSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,<br/>RSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA\"</code>",
            "default" : ""
          },
          "secure_renegotiate" : {
            "type" : "boolean",
            "summary" : "SSL renegotiate",
            "label" : "SSL renegotiate",
            "description" : "SSL parameter renegotiation is a feature that allows a client and a server<br/>to renegotiate the parameters of the SSL connection on the fly.<br/>RFC 5746 defines a more secure way of doing this. By enabling secure renegotiation,<br/>you drop support for the insecure renegotiation, prone to MitM attacks.",
            "default" : true
          },
          "hibernate_after" : {
            "type" : "duration",
            "summary" : "hibernate after",
            "label" : "hibernate after",
            "description" : "Hibernate the SSL process after idling for amount of time reducing its memory footprint.",
            "default" : "5s"
          },
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable TLS.",
            "label" : "Enable TLS.",
            "description" : "Enable TLS.",
            "default" : false
          },
          "server_name_indication" : {
            "oneOf" : [
              {
                "type" : "string"
              },
              {
                "type" : "enum",
                "symbols" : [
                  "disable"
                ]
              }
            ],
            "summary" : "Server Name Indication",
            "label" : "Server Name Indication",
            "example" : "disable",
            "description" : "Specify the host name to be used in TLS Server Name Indication extension.<br/><br/>For instance, when connecting to \"server.example.net\", the genuine server<br/>which accepts the connection and performs TLS handshake may differ from the<br/>host the TLS client initially connects to, e.g. when connecting to an IP address<br/>or when the host has multiple resolvable DNS records <br/><br/>If not specified, it will default to the host name string which is used<br/>to establish the connection, unless it is IP addressed used.<br/><br/>The host name is then also used in the host name verification of the peer<br/>certificate.<br/> The special value 'disable' prevents the Server Name<br/>Indication extension from being sent and disables the hostname<br/>verification check."
          }
        }
      },
      "bridge_redis.get_single" : {
        "type" : "object",
        "properties" : {
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "The MQTT topic filter to be forwarded to Redis. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "command_template" : {
            "type" : "array",
            "summary" : "Redis Command Template",
            "label" : "Redis Command Template",
            "items" : {
              "type" : "string"
            },
            "description" : "Redis command template used to export messages. Each list element stands for a command name or its argument.<br/>For example, to push payloads in a Redis list by key `msgs`, the elements should be the following:<br/>`rpush`, `msgs`, `${payload}`."
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/bridge_redis.creation_opts_redis_single",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "server" : {
            "type" : "string",
            "summary" : "Server Host",
            "label" : "Server Host",
            "description" : "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The Redis default port 6379 is used if `[:Port]` is not specified."
          },
          "redis_type" : {
            "type" : "enum",
            "symbols" : [
              "single"
            ],
            "summary" : "Single Mode",
            "label" : "Single Mode",
            "description" : "Single mode. Must be set to 'single' when Redis server is running in single mode.",
            "default" : "single"
          },
          "pool_size" : {
            "type" : "string",
            "summary" : "Connection Pool Size",
            "label" : "Connection Pool Size",
            "description" : "Size of the connection pool towards the bridge target service.",
            "default" : 8
          },
          "password" : {
            "type" : "string",
            "summary" : "Password",
            "label" : "Password",
            "format" : "password",
            "description" : "EMQX's password in the external database."
          },
          "database" : {
            "type" : "number",
            "summary" : "Database ID",
            "label" : "Database ID",
            "description" : "Redis database ID.",
            "default" : 0
          },
          "auto_reconnect" : {
            "type" : "boolean",
            "summary" : "Deprecated. Auto Reconnect Database",
            "label" : "Deprecated. Auto Reconnect Database",
            "description" : "Deprecated. Enable automatic reconnect to the database.",
            "deprecated" : true,
            "default" : true
          },
          "ssl" : {
            "$ref" : "#/components/schemas/broker.ssl_client_opts",
            "summary" : "Enable SSL",
            "label" : "Enable SSL",
            "description" : "SSL connection settings.",
            "default" : {
              "enable" : false
            }
          },
          "type" : {
            "type" : "enum",
            "symbols" : [
              "redis_single"
            ],
            "summary" : "Bridge Type",
            "label" : "Bridge Type",
            "description" : "The Bridge Type"
          },
          "name" : {
            "type" : "string",
            "summary" : "Bridge Name",
            "label" : "Bridge Name",
            "description" : "Bridge name, used as a human-readable description of the bridge."
          },
          "status" : {
            "type" : "enum",
            "symbols" : [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "summary" : "Bridge Status",
            "label" : "Bridge Status",
            "description" : "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason" : {
            "type" : "string",
            "summary" : "Failure reason",
            "label" : "Failure reason",
            "example" : "Connection refused",
            "description" : "This is the reason given in case a bridge is failing to connect."
          },
          "node_status" : {
            "type" : "array",
            "summary" : "Node Status",
            "label" : "Node Status",
            "items" : {
              "$ref" : "#/components/schemas/bridge.node_status"
            },
            "description" : "Node status."
          }
        },
        "required" : [
          "command_template",
          "name",
          "server",
          "type"
        ]
      },
      "bridge_webhook.creation_opts" : {
        "type" : "object",
        "properties" : {
          "worker_pool_size" : {
            "type" : "number",
            "summary" : "Buffer Pool Size",
            "minimum" : 1,
            "label" : "Buffer Pool Size",
            "description" : "The number of buffer workers. Only applicable for egress type bridges.<br/>For bridges only have ingress direction data flow, it can be set to 0 otherwise must be greater than 0.",
            "default" : 16
          },
          "health_check_interval" : {
            "type" : "duration",
            "summary" : "Health Check Interval",
            "label" : "Health Check Interval",
            "description" : "Health check interval.",
            "default" : "15s"
          },
          "start_after_created" : {
            "type" : "boolean",
            "summary" : "Start After Created",
            "label" : "Start After Created",
            "description" : "Whether start the resource right after created.",
            "default" : "true"
          },
          "start_timeout" : {
            "type" : "duration",
            "summary" : "Start Timeout",
            "label" : "Start Timeout",
            "description" : "Time interval to wait for an auto-started resource to become healthy before responding resource creation requests.",
            "default" : "5s"
          },
          "auto_restart_interval" : {
            "oneOf" : [
              {
                "type" : "duration"
              },
              {
                "type" : "enum",
                "symbols" : [
                  "infinity"
                ]
              }
            ],
            "summary" : "Auto Restart Interval",
            "label" : "Auto Restart Interval",
            "description" : "The auto restart interval after the resource is disconnected.",
            "default" : "60s"
          },
          "query_mode" : {
            "type" : "enum",
            "symbols" : [
              "sync",
              "async"
            ],
            "summary" : "Query mode",
            "label" : "Query mode",
            "description" : "Query mode. Optional 'sync/async', default 'async'.",
            "default" : "async"
          },
          "request_timeout" : {
            "oneOf" : [
              {
                "type" : "duration"
              },
              {
                "type" : "enum",
                "symbols" : [
                  "infinity"
                ]
              }
            ],
            "summary" : "Request Expiry",
            "label" : "Request Expiry",
            "description" : "Starting from the moment when the request enters the buffer, if the request remains in the buffer for the specified time or is sent but does not receive a response or acknowledgement in time, the request is considered expired.",
            "default" : "15s"
          },
          "inflight_window" : {
            "type" : "string",
            "summary" : "Inflight window",
            "label" : "Inflight window",
            "description" : "Query inflight window. When query_mode is set to async, this config has to be set to 1 if messages from the same MQTT client have to be strictly ordered.",
            "default" : 100
          },
          "enable_queue" : {
            "type" : "boolean",
            "summary" : "Enable disk buffer queue",
            "label" : "Enable disk buffer queue",
            "description" : "Enable disk buffer queue (only applicable for egress bridges).<br/>When Enabled, messages will be buffered on disk when the bridge connection is down.<br/>When disabled the messages are buffered in RAM only.",
            "deprecated" : true,
            "default" : false
          },
          "max_buffer_bytes" : {
            "type" : "byteSize",
            "summary" : "Max buffer queue size",
            "label" : "Max buffer queue size",
            "description" : "Maximum number of bytes to buffer for each buffer worker.",
            "default" : "256MB"
          }
        }
      },
      "bridge_redis.get_cluster" : {
        "type" : "object",
        "properties" : {
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "The MQTT topic filter to be forwarded to Redis. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "command_template" : {
            "type" : "array",
            "summary" : "Redis Command Template",
            "label" : "Redis Command Template",
            "items" : {
              "type" : "string"
            },
            "description" : "Redis command template used to export messages. Each list element stands for a command name or its argument.<br/>For example, to push payloads in a Redis list by key `msgs`, the elements should be the following:<br/>`rpush`, `msgs`, `${payload}`."
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/bridge_redis.creation_opts_redis_cluster",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "servers" : {
            "type" : "string",
            "summary" : "Servers",
            "label" : "Servers",
            "description" : "A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`<br/>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.<br/>A host entry has the following form: `Host[:Port]`.<br/>The Redis default port 6379 is used if `[:Port]` is not specified."
          },
          "redis_type" : {
            "type" : "enum",
            "symbols" : [
              "cluster"
            ],
            "summary" : "Cluster Mode",
            "label" : "Cluster Mode",
            "description" : "Cluster mode. Must be set to 'cluster' when Redis server is running in clustered mode.",
            "default" : "cluster"
          },
          "pool_size" : {
            "type" : "string",
            "summary" : "Connection Pool Size",
            "label" : "Connection Pool Size",
            "description" : "Size of the connection pool towards the bridge target service.",
            "default" : 8
          },
          "password" : {
            "type" : "string",
            "summary" : "Password",
            "label" : "Password",
            "format" : "password",
            "description" : "EMQX's password in the external database."
          },
          "auto_reconnect" : {
            "type" : "boolean",
            "summary" : "Deprecated. Auto Reconnect Database",
            "label" : "Deprecated. Auto Reconnect Database",
            "description" : "Deprecated. Enable automatic reconnect to the database.",
            "deprecated" : true,
            "default" : true
          },
          "ssl" : {
            "$ref" : "#/components/schemas/broker.ssl_client_opts",
            "summary" : "Enable SSL",
            "label" : "Enable SSL",
            "description" : "SSL connection settings.",
            "default" : {
              "enable" : false
            }
          },
          "type" : {
            "type" : "enum",
            "symbols" : [
              "redis_cluster"
            ],
            "summary" : "Bridge Type",
            "label" : "Bridge Type",
            "description" : "The Bridge Type"
          },
          "name" : {
            "type" : "string",
            "summary" : "Bridge Name",
            "label" : "Bridge Name",
            "description" : "Bridge name, used as a human-readable description of the bridge."
          },
          "status" : {
            "type" : "enum",
            "symbols" : [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "summary" : "Bridge Status",
            "label" : "Bridge Status",
            "description" : "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason" : {
            "type" : "string",
            "summary" : "Failure reason",
            "label" : "Failure reason",
            "example" : "Connection refused",
            "description" : "This is the reason given in case a bridge is failing to connect."
          },
          "node_status" : {
            "type" : "array",
            "summary" : "Node Status",
            "label" : "Node Status",
            "items" : {
              "$ref" : "#/components/schemas/bridge.node_status"
            },
            "description" : "Node status."
          }
        },
        "required" : [
          "command_template",
          "name",
          "servers",
          "type"
        ]
      },
      "bridge_timescale.get" : {
        "type" : "object",
        "properties" : {
          "status" : {
            "type" : "enum",
            "symbols" : [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "summary" : "Bridge Status",
            "label" : "Bridge Status",
            "description" : "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason" : {
            "type" : "string",
            "summary" : "Failure reason",
            "label" : "Failure reason",
            "example" : "Connection refused",
            "description" : "This is the reason given in case a bridge is failing to connect."
          },
          "node_status" : {
            "type" : "array",
            "summary" : "Node Status",
            "label" : "Node Status",
            "items" : {
              "$ref" : "#/components/schemas/bridge.node_status"
            },
            "description" : "Node status."
          },
          "type" : {
            "type" : "enum",
            "symbols" : [
              "pgsql"
            ],
            "summary" : "Bridge Type",
            "label" : "Bridge Type",
            "description" : "The Bridge Type"
          },
          "name" : {
            "type" : "string",
            "summary" : "Bridge Name",
            "label" : "Bridge Name",
            "description" : "Bridge name."
          },
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "sql" : {
            "type" : "string",
            "summary" : "SQL Template",
            "label" : "SQL Template",
            "format" : "sql",
            "description" : "SQL Template",
            "default" : "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))"
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "The MQTT topic filter to be forwarded to PostgreSQL. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/resource_schema.creation_opts",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "server" : {
            "type" : "string",
            "summary" : "Server Host",
            "label" : "Server Host",
            "description" : "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The PostgreSQL default port 5432 is used if `[:Port]` is not specified."
          },
          "database" : {
            "type" : "string",
            "summary" : "Database Name",
            "label" : "Database Name",
            "description" : "Database name."
          },
          "pool_size" : {
            "type" : "string",
            "summary" : "Connection Pool Size",
            "label" : "Connection Pool Size",
            "description" : "Size of the connection pool towards the bridge target service.",
            "default" : 8
          },
          "username" : {
            "type" : "string",
            "summary" : "Username",
            "label" : "Username",
            "description" : "EMQX's username in the external database."
          },
          "password" : {
            "type" : "string",
            "summary" : "Password",
            "label" : "Password",
            "format" : "password",
            "description" : "EMQX's password in the external database."
          },
          "auto_reconnect" : {
            "type" : "boolean",
            "summary" : "Deprecated. Auto Reconnect Database",
            "label" : "Deprecated. Auto Reconnect Database",
            "description" : "Deprecated. Enable automatic reconnect to the database.",
            "deprecated" : true,
            "default" : true
          },
          "ssl" : {
            "$ref" : "#/components/schemas/broker.ssl_client_opts",
            "summary" : "Enable SSL",
            "label" : "Enable SSL",
            "description" : "SSL connection settings.",
            "default" : {
              "enable" : false
            }
          }
        },
        "required" : [
          "database",
          "name",
          "server",
          "type"
        ]
      },
      "bridge_dynamo.creation_opts" : {
        "type" : "object",
        "properties" : {
          "worker_pool_size" : {
            "type" : "number",
            "summary" : "Buffer Pool Size",
            "minimum" : 1,
            "label" : "Buffer Pool Size",
            "description" : "The number of buffer workers. Only applicable for egress type bridges.<br/>For bridges only have ingress direction data flow, it can be set to 0 otherwise must be greater than 0.",
            "default" : 16
          },
          "health_check_interval" : {
            "type" : "duration",
            "summary" : "Health Check Interval",
            "label" : "Health Check Interval",
            "description" : "Health check interval.",
            "default" : "15s"
          },
          "start_after_created" : {
            "type" : "boolean",
            "summary" : "Start After Created",
            "label" : "Start After Created",
            "description" : "Whether start the resource right after created.",
            "default" : "true"
          },
          "start_timeout" : {
            "type" : "duration",
            "summary" : "Start Timeout",
            "label" : "Start Timeout",
            "description" : "Time interval to wait for an auto-started resource to become healthy before responding resource creation requests.",
            "default" : "5s"
          },
          "auto_restart_interval" : {
            "oneOf" : [
              {
                "type" : "duration"
              },
              {
                "type" : "enum",
                "symbols" : [
                  "infinity"
                ]
              }
            ],
            "summary" : "Auto Restart Interval",
            "label" : "Auto Restart Interval",
            "description" : "The auto restart interval after the resource is disconnected.",
            "default" : "60s"
          },
          "query_mode" : {
            "type" : "enum",
            "symbols" : [
              "sync",
              "async"
            ],
            "summary" : "Query mode",
            "label" : "Query mode",
            "description" : "Query mode. Optional 'sync/async', default 'async'.",
            "default" : "async"
          },
          "request_timeout" : {
            "oneOf" : [
              {
                "type" : "duration"
              },
              {
                "type" : "enum",
                "symbols" : [
                  "infinity"
                ]
              }
            ],
            "summary" : "Request Expiry",
            "label" : "Request Expiry",
            "description" : "Starting from the moment when the request enters the buffer, if the request remains in the buffer for the specified time or is sent but does not receive a response or acknowledgement in time, the request is considered expired.",
            "default" : "15s"
          },
          "inflight_window" : {
            "type" : "string",
            "summary" : "Inflight window",
            "label" : "Inflight window",
            "description" : "Query inflight window. When query_mode is set to async, this config has to be set to 1 if messages from the same MQTT client have to be strictly ordered.",
            "default" : 100
          },
          "enable_batch" : {
            "type" : "boolean",
            "summary" : "Enable batch",
            "label" : "Enable batch",
            "description" : "Batch mode enabled.",
            "deprecated" : true,
            "default" : true
          },
          "batch_size" : {
            "type" : "string",
            "summary" : "Max batch size",
            "label" : "Max batch size",
            "description" : "Maximum batch count. If equal to 1, there's effectively no batching.",
            "default" : 1
          },
          "batch_time" : {
            "type" : "duration",
            "summary" : "Max batch wait time",
            "label" : "Max batch wait time",
            "description" : "Maximum waiting interval when accumulating a batch at a low message rates for more efficient resource usage.",
            "default" : "0ms"
          },
          "enable_queue" : {
            "type" : "boolean",
            "summary" : "Enable disk buffer queue",
            "label" : "Enable disk buffer queue",
            "description" : "Enable disk buffer queue (only applicable for egress bridges).<br/>When Enabled, messages will be buffered on disk when the bridge connection is down.<br/>When disabled the messages are buffered in RAM only.",
            "deprecated" : true,
            "default" : false
          },
          "max_buffer_bytes" : {
            "type" : "byteSize",
            "summary" : "Max buffer queue size",
            "label" : "Max buffer queue size",
            "description" : "Maximum number of bytes to buffer for each buffer worker.",
            "default" : "256MB"
          }
        }
      },
      "bridge_mysql.get" : {
        "type" : "object",
        "properties" : {
          "status" : {
            "type" : "enum",
            "symbols" : [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "summary" : "Bridge Status",
            "label" : "Bridge Status",
            "description" : "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason" : {
            "type" : "string",
            "summary" : "Failure reason",
            "label" : "Failure reason",
            "example" : "Connection refused",
            "description" : "This is the reason given in case a bridge is failing to connect."
          },
          "node_status" : {
            "type" : "array",
            "summary" : "Node Status",
            "label" : "Node Status",
            "items" : {
              "$ref" : "#/components/schemas/bridge.node_status"
            },
            "description" : "Node status."
          },
          "type" : {
            "type" : "enum",
            "symbols" : [
              "mysql"
            ],
            "summary" : "Bridge Type",
            "label" : "Bridge Type",
            "description" : "The Bridge Type"
          },
          "name" : {
            "type" : "string",
            "summary" : "Bridge Name",
            "label" : "Bridge Name",
            "description" : "Bridge name, used as a human-readable description of the bridge."
          },
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "sql" : {
            "type" : "string",
            "summary" : "SQL Template",
            "label" : "SQL Template",
            "format" : "sql",
            "description" : "SQL Template",
            "default" : "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, FROM_UNIXTIME(${timestamp}/1000))"
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "The MQTT topic filter to be forwarded to MySQL. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/resource_schema.creation_opts",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "server" : {
            "type" : "string",
            "summary" : "Server Host",
            "label" : "Server Host",
            "description" : "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The MySQL default port 3306 is used if `[:Port]` is not specified."
          },
          "database" : {
            "type" : "string",
            "summary" : "Database Name",
            "label" : "Database Name",
            "description" : "Database name."
          },
          "pool_size" : {
            "type" : "string",
            "summary" : "Connection Pool Size",
            "label" : "Connection Pool Size",
            "description" : "Size of the connection pool towards the bridge target service.",
            "default" : 8
          },
          "username" : {
            "type" : "string",
            "summary" : "Username",
            "label" : "Username",
            "description" : "EMQX's username in the external database.",
            "default" : "root"
          },
          "password" : {
            "type" : "string",
            "summary" : "Password",
            "label" : "Password",
            "format" : "password",
            "description" : "EMQX's password in the external database."
          },
          "auto_reconnect" : {
            "type" : "boolean",
            "summary" : "Deprecated. Auto Reconnect Database",
            "label" : "Deprecated. Auto Reconnect Database",
            "description" : "Deprecated. Enable automatic reconnect to the database.",
            "deprecated" : true,
            "default" : true
          },
          "ssl" : {
            "$ref" : "#/components/schemas/broker.ssl_client_opts",
            "summary" : "Enable SSL",
            "label" : "Enable SSL",
            "description" : "SSL connection settings.",
            "default" : {
              "enable" : false
            }
          }
        },
        "required" : [
          "database",
          "name",
          "server",
          "type"
        ]
      },
      "bridge_redis.post_cluster" : {
        "type" : "object",
        "properties" : {
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "The MQTT topic filter to be forwarded to Redis. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "command_template" : {
            "type" : "array",
            "summary" : "Redis Command Template",
            "label" : "Redis Command Template",
            "items" : {
              "type" : "string"
            },
            "description" : "Redis command template used to export messages. Each list element stands for a command name or its argument.<br/>For example, to push payloads in a Redis list by key `msgs`, the elements should be the following:<br/>`rpush`, `msgs`, `${payload}`."
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/bridge_redis.creation_opts_redis_cluster",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "servers" : {
            "type" : "string",
            "summary" : "Servers",
            "label" : "Servers",
            "description" : "A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`<br/>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.<br/>A host entry has the following form: `Host[:Port]`.<br/>The Redis default port 6379 is used if `[:Port]` is not specified."
          },
          "redis_type" : {
            "type" : "enum",
            "symbols" : [
              "cluster"
            ],
            "summary" : "Cluster Mode",
            "label" : "Cluster Mode",
            "description" : "Cluster mode. Must be set to 'cluster' when Redis server is running in clustered mode.",
            "default" : "cluster"
          },
          "pool_size" : {
            "type" : "string",
            "summary" : "Connection Pool Size",
            "label" : "Connection Pool Size",
            "description" : "Size of the connection pool towards the bridge target service.",
            "default" : 8
          },
          "password" : {
            "type" : "string",
            "summary" : "Password",
            "label" : "Password",
            "format" : "password",
            "description" : "EMQX's password in the external database."
          },
          "auto_reconnect" : {
            "type" : "boolean",
            "summary" : "Deprecated. Auto Reconnect Database",
            "label" : "Deprecated. Auto Reconnect Database",
            "description" : "Deprecated. Enable automatic reconnect to the database.",
            "deprecated" : true,
            "default" : true
          },
          "ssl" : {
            "$ref" : "#/components/schemas/broker.ssl_client_opts",
            "summary" : "Enable SSL",
            "label" : "Enable SSL",
            "description" : "SSL connection settings.",
            "default" : {
              "enable" : false
            }
          },
          "type" : {
            "type" : "enum",
            "symbols" : [
              "redis_cluster"
            ],
            "summary" : "Bridge Type",
            "label" : "Bridge Type",
            "description" : "The Bridge Type"
          },
          "name" : {
            "type" : "string",
            "summary" : "Bridge Name",
            "label" : "Bridge Name",
            "description" : "Bridge name, used as a human-readable description of the bridge."
          }
        },
        "required" : [
          "command_template",
          "name",
          "servers",
          "type"
        ]
      },
      "bridge_mqtt.put" : {
        "type" : "object",
        "properties" : {
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/bridge_mqtt.creation_opts",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "mode" : {
            "type" : "enum",
            "symbols" : [
              "cluster_shareload"
            ],
            "summary" : "MQTT Bridge Mode",
            "label" : "MQTT Bridge Mode",
            "description" : "The mode of the MQTT Bridge.<br/><br/>- cluster_shareload: create an MQTT connection on each node in the emqx cluster.<br/><br/>In 'cluster_shareload' mode, the incoming load from the remote broker is shared by<br/>using shared subscription.<br/><br/>Note that the 'clientid' is suffixed by the node name, this is to avoid<br/>clientid conflicts between different nodes. And we can only use shared subscription<br/>topic filters for <code>remote.topic</code> of ingress connections.",
            "default" : "cluster_shareload"
          },
          "server" : {
            "type" : "string",
            "summary" : "Broker IP And Port",
            "label" : "Broker IP And Port",
            "description" : "The host and port of the remote MQTT broker"
          },
          "clientid_prefix" : {
            "type" : "string",
            "summary" : "Clientid Prefix",
            "label" : "Clientid Prefix",
            "description" : "Optional prefix to prepend to the clientid used by egress bridges."
          },
          "reconnect_interval" : {
            "type" : "string",
            "label" : "reconnect_interval",
            "description" : "reconnect_interval Description",
            "deprecated" : true
          },
          "proto_ver" : {
            "type" : "enum",
            "symbols" : [
              "v3",
              "v4",
              "v5"
            ],
            "summary" : "Protocol Version",
            "label" : "Protocol Version",
            "description" : "The MQTT protocol version",
            "default" : "v4"
          },
          "bridge_mode" : {
            "type" : "boolean",
            "summary" : "Bridge Mode",
            "label" : "Bridge Mode",
            "description" : "If enable bridge mode.<br/>NOTE: This setting is only for MQTT protocol version older than 5.0, and the remote MQTT<br/>broker MUST support this feature.<br/>If bridge_mode is set to true, the bridge will indicate to the remote broker that it is a bridge not an ordinary client.<br/>This means that loop detection will be more effective and that retained messages will be propagated correctly.",
            "default" : false
          },
          "username" : {
            "type" : "string",
            "summary" : "Username",
            "label" : "Username",
            "description" : "The username of the MQTT protocol"
          },
          "password" : {
            "type" : "string",
            "summary" : "Password",
            "label" : "Password",
            "format" : "password",
            "description" : "The password of the MQTT protocol"
          },
          "clean_start" : {
            "type" : "boolean",
            "summary" : "Clean Session",
            "label" : "Clean Session",
            "description" : "Whether to start a clean session when reconnecting a remote broker for ingress bridge",
            "default" : true
          },
          "keepalive" : {
            "type" : "string",
            "label" : "keepalive",
            "description" : "MQTT Keepalive. Time interval is a string that contains a number followed by time unit:<br/>- `ms` for milliseconds,<br/>- `s` for seconds,<br/>- `m` for minutes,<br/>- `h` for hours;<br/><br/>or combination of whereof: `1h5m0s`",
            "default" : "300s"
          },
          "retry_interval" : {
            "type" : "string",
            "label" : "retry_interval",
            "description" : "Message retry interval. Delay for the MQTT bridge to retry sending the QoS1/QoS2 messages in case of ACK not received. Time interval is a string that contains a number followed by time unit:<br/>- `ms` for milliseconds,<br/>- `s` for seconds,<br/>- `m` for minutes,<br/>- `h` for hours;<br/><br/>or combination of whereof: `1h5m0s`",
            "default" : "15s"
          },
          "max_inflight" : {
            "type" : "number",
            "summary" : "Max Inflight Message",
            "minimum" : 1,
            "label" : "Max Inflight Message",
            "description" : "Max inflight (sent, but un-acked) messages of the MQTT protocol",
            "default" : 32
          },
          "ssl" : {
            "$ref" : "#/components/schemas/broker.ssl_client_opts",
            "summary" : "Enable SSL",
            "label" : "Enable SSL",
            "description" : "SSL connection settings.",
            "default" : {
              "enable" : false
            }
          },
          "ingress" : {
            "$ref" : "#/components/schemas/connector-mqtt.ingress",
            "summary" : "Ingress Configs",
            "label" : "Ingress Configs",
            "description" : "The ingress config defines how this bridge receive messages from the remote MQTT broker, and then<br/>        send them to the local broker.<br/><br/>        Template with variables is allowed in 'remote.qos', 'local.topic', 'local.qos', 'local.retain', 'local.payload'.<br/><br/>        NOTE: if this bridge is used as the input of a rule, and also 'local.topic' is<br/>        configured, then messages got from the remote broker will be sent to both the 'local.topic' and<br/>        the rule."
          },
          "egress" : {
            "$ref" : "#/components/schemas/connector-mqtt.egress",
            "summary" : "Egress Configs",
            "label" : "Egress Configs",
            "description" : "The egress config defines how this bridge forwards messages from the local broker to the remote broker.<br/><br/>Template with variables is allowed in 'remote.topic', 'local.qos', 'local.retain', 'local.payload'.<br/><br/>NOTE: if this bridge is used as the action of a rule, and also 'local.topic'<br/>is configured, then both the data got from the rule and the MQTT messages that matches<br/>'local.topic' will be forwarded."
          }
        },
        "required" : [
          "server"
        ]
      },
      "bridge_hstreamdb.get" : {
        "type" : "object",
        "properties" : {
          "status" : {
            "type" : "enum",
            "symbols" : [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "summary" : "Bridge Status",
            "label" : "Bridge Status",
            "description" : "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason" : {
            "type" : "string",
            "summary" : "Failure reason",
            "label" : "Failure reason",
            "example" : "Connection refused",
            "description" : "This is the reason given in case a bridge is failing to connect."
          },
          "node_status" : {
            "type" : "array",
            "summary" : "Node Status",
            "label" : "Node Status",
            "items" : {
              "$ref" : "#/components/schemas/bridge.node_status"
            },
            "description" : "Node status."
          },
          "type" : {
            "type" : "enum",
            "symbols" : [
              "hstreamdb"
            ],
            "summary" : "Bridge Type",
            "label" : "Bridge Type",
            "description" : "The Bridge Type"
          },
          "name" : {
            "type" : "string",
            "summary" : "Bridge Name",
            "label" : "Bridge Name",
            "description" : "Bridge name, used as a human-readable description of the bridge."
          },
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "direction" : {
            "type" : "enum",
            "symbols" : [
              "egress"
            ],
            "summary" : "Bridge Direction",
            "label" : "Bridge Direction",
            "description" : "The direction of this bridge, MUST be 'egress'",
            "default" : "egress"
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "The MQTT topic filter to be forwarded to the HStreamDB. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "payload" : {
            "type" : "string",
            "summary" : "Payload",
            "label" : "Payload",
            "description" : "The payload to be forwarded to the HStreamDB. Placeholders supported.",
            "default" : "${payload}"
          },
          "connector" : {
            "oneOf" : [
              {
                "$ref" : "#/components/schemas/connector_hstreamdb.config"
              },
              {
                "type" : "string"
              }
            ],
            "summary" : "Connector Generic Configuration",
            "label" : "Connector Generic Configuration",
            "example" : "hstreamdb:demo",
            "description" : "Generic configuration for the connector."
          }
        },
        "required" : [
          "connector",
          "name",
          "type"
        ]
      },
      "bridge_redis.creation_opts_redis_sentinel" : {
        "type" : "object",
        "properties" : {
          "worker_pool_size" : {
            "type" : "number",
            "summary" : "Buffer Pool Size",
            "minimum" : 1,
            "label" : "Buffer Pool Size",
            "description" : "The number of buffer workers. Only applicable for egress type bridges.<br/>For bridges only have ingress direction data flow, it can be set to 0 otherwise must be greater than 0.",
            "default" : 16
          },
          "health_check_interval" : {
            "type" : "duration",
            "summary" : "Health Check Interval",
            "label" : "Health Check Interval",
            "description" : "Health check interval.",
            "default" : "15s"
          },
          "start_after_created" : {
            "type" : "boolean",
            "summary" : "Start After Created",
            "label" : "Start After Created",
            "description" : "Whether start the resource right after created.",
            "default" : "true"
          },
          "start_timeout" : {
            "type" : "duration",
            "summary" : "Start Timeout",
            "label" : "Start Timeout",
            "description" : "Time interval to wait for an auto-started resource to become healthy before responding resource creation requests.",
            "default" : "5s"
          },
          "auto_restart_interval" : {
            "oneOf" : [
              {
                "type" : "duration"
              },
              {
                "type" : "enum",
                "symbols" : [
                  "infinity"
                ]
              }
            ],
            "summary" : "Auto Restart Interval",
            "label" : "Auto Restart Interval",
            "description" : "The auto restart interval after the resource is disconnected.",
            "default" : "60s"
          },
          "query_mode" : {
            "type" : "enum",
            "symbols" : [
              "sync",
              "async"
            ],
            "summary" : "Query mode",
            "label" : "Query mode",
            "description" : "Query mode. Optional 'sync/async', default 'async'.",
            "default" : "async"
          },
          "request_timeout" : {
            "oneOf" : [
              {
                "type" : "duration"
              },
              {
                "type" : "enum",
                "symbols" : [
                  "infinity"
                ]
              }
            ],
            "summary" : "Request Expiry",
            "label" : "Request Expiry",
            "description" : "Starting from the moment when the request enters the buffer, if the request remains in the buffer for the specified time or is sent but does not receive a response or acknowledgement in time, the request is considered expired.",
            "default" : "15s"
          },
          "inflight_window" : {
            "type" : "string",
            "summary" : "Inflight window",
            "label" : "Inflight window",
            "description" : "Query inflight window. When query_mode is set to async, this config has to be set to 1 if messages from the same MQTT client have to be strictly ordered.",
            "default" : 100
          },
          "enable_batch" : {
            "type" : "boolean",
            "summary" : "Enable batch",
            "label" : "Enable batch",
            "description" : "Batch mode enabled.",
            "deprecated" : true,
            "default" : true
          },
          "batch_size" : {
            "type" : "string",
            "summary" : "Max batch size",
            "label" : "Max batch size",
            "description" : "Maximum batch count. If equal to 1, there's effectively no batching.",
            "default" : 1
          },
          "batch_time" : {
            "type" : "duration",
            "summary" : "Max batch wait time",
            "label" : "Max batch wait time",
            "description" : "Maximum waiting interval when accumulating a batch at a low message rates for more efficient resource usage.",
            "default" : "0ms"
          },
          "enable_queue" : {
            "type" : "boolean",
            "summary" : "Enable disk buffer queue",
            "label" : "Enable disk buffer queue",
            "description" : "Enable disk buffer queue (only applicable for egress bridges).<br/>When Enabled, messages will be buffered on disk when the bridge connection is down.<br/>When disabled the messages are buffered in RAM only.",
            "deprecated" : true,
            "default" : false
          },
          "max_buffer_bytes" : {
            "type" : "byteSize",
            "summary" : "Max buffer queue size",
            "label" : "Max buffer queue size",
            "description" : "Maximum number of bytes to buffer for each buffer worker.",
            "default" : "256MB"
          }
        }
      },
      "bridge_sqlserver.post" : {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "enum",
            "symbols" : [
              "sqlserver"
            ],
            "summary" : "Bridge Type",
            "label" : "Bridge Type",
            "description" : "The Bridge Type"
          },
          "name" : {
            "type" : "string",
            "summary" : "Bridge Name",
            "label" : "Bridge Name",
            "description" : "Bridge name."
          },
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "sql" : {
            "type" : "string",
            "summary" : "SQL Template",
            "label" : "SQL Template",
            "format" : "sql",
            "description" : "SQL Template",
            "default" : "insert into t_mqtt_msg(msgid, topic, qos, payload) values ( ${id}, ${topic}, ${qos}, ${payload} )"
          },
          "driver" : {
            "type" : "string",
            "summary" : "SQL Server Driver Name",
            "label" : "SQL Server Driver Name",
            "description" : "SQL Server Driver Name",
            "default" : "ms-sql"
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "The MQTT topic filter to be forwarded to Microsoft SQL Server. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/bridge_sqlserver.creation_opts",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "server" : {
            "type" : "string",
            "summary" : "Server Host",
            "label" : "Server Host",
            "description" : "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The SQL Server default port 1433 is used if `[:Port]` is not specified."
          },
          "database" : {
            "type" : "string",
            "summary" : "Database Name",
            "label" : "Database Name",
            "description" : "Database name."
          },
          "pool_size" : {
            "type" : "string",
            "summary" : "Connection Pool Size",
            "label" : "Connection Pool Size",
            "description" : "Size of the connection pool towards the bridge target service.",
            "default" : 8
          },
          "username" : {
            "type" : "string",
            "summary" : "Username",
            "label" : "Username",
            "description" : "EMQX's username in the external database.",
            "default" : "sa"
          },
          "password" : {
            "type" : "string",
            "summary" : "Password",
            "label" : "Password",
            "format" : "password",
            "description" : "EMQX's password in the external database."
          },
          "auto_reconnect" : {
            "type" : "boolean",
            "summary" : "Deprecated. Auto Reconnect Database",
            "label" : "Deprecated. Auto Reconnect Database",
            "description" : "Deprecated. Enable automatic reconnect to the database.",
            "deprecated" : true,
            "default" : true
          }
        },
        "required" : [
          "database",
          "name",
          "server",
          "type"
        ]
      },
      "bridge_pgsql.get" : {
        "type" : "object",
        "properties" : {
          "status" : {
            "type" : "enum",
            "symbols" : [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "summary" : "Bridge Status",
            "label" : "Bridge Status",
            "description" : "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason" : {
            "type" : "string",
            "summary" : "Failure reason",
            "label" : "Failure reason",
            "example" : "Connection refused",
            "description" : "This is the reason given in case a bridge is failing to connect."
          },
          "node_status" : {
            "type" : "array",
            "summary" : "Node Status",
            "label" : "Node Status",
            "items" : {
              "$ref" : "#/components/schemas/bridge.node_status"
            },
            "description" : "Node status."
          },
          "type" : {
            "type" : "enum",
            "symbols" : [
              "pgsql"
            ],
            "summary" : "Bridge Type",
            "label" : "Bridge Type",
            "description" : "The Bridge Type"
          },
          "name" : {
            "type" : "string",
            "summary" : "Bridge Name",
            "label" : "Bridge Name",
            "description" : "Bridge name."
          },
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "sql" : {
            "type" : "string",
            "summary" : "SQL Template",
            "label" : "SQL Template",
            "format" : "sql",
            "description" : "SQL Template",
            "default" : "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))"
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "The MQTT topic filter to be forwarded to PostgreSQL. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/resource_schema.creation_opts",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "server" : {
            "type" : "string",
            "summary" : "Server Host",
            "label" : "Server Host",
            "description" : "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The PostgreSQL default port 5432 is used if `[:Port]` is not specified."
          },
          "database" : {
            "type" : "string",
            "summary" : "Database Name",
            "label" : "Database Name",
            "description" : "Database name."
          },
          "pool_size" : {
            "type" : "string",
            "summary" : "Connection Pool Size",
            "label" : "Connection Pool Size",
            "description" : "Size of the connection pool towards the bridge target service.",
            "default" : 8
          },
          "username" : {
            "type" : "string",
            "summary" : "Username",
            "label" : "Username",
            "description" : "EMQX's username in the external database."
          },
          "password" : {
            "type" : "string",
            "summary" : "Password",
            "label" : "Password",
            "format" : "password",
            "description" : "EMQX's password in the external database."
          },
          "auto_reconnect" : {
            "type" : "boolean",
            "summary" : "Deprecated. Auto Reconnect Database",
            "label" : "Deprecated. Auto Reconnect Database",
            "description" : "Deprecated. Enable automatic reconnect to the database.",
            "deprecated" : true,
            "default" : true
          },
          "ssl" : {
            "$ref" : "#/components/schemas/broker.ssl_client_opts",
            "summary" : "Enable SSL",
            "label" : "Enable SSL",
            "description" : "SSL connection settings.",
            "default" : {
              "enable" : false
            }
          }
        },
        "required" : [
          "database",
          "name",
          "server",
          "type"
        ]
      },
      "bridge_matrix.get" : {
        "type" : "object",
        "properties" : {
          "status" : {
            "type" : "enum",
            "symbols" : [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "summary" : "Bridge Status",
            "label" : "Bridge Status",
            "description" : "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason" : {
            "type" : "string",
            "summary" : "Failure reason",
            "label" : "Failure reason",
            "example" : "Connection refused",
            "description" : "This is the reason given in case a bridge is failing to connect."
          },
          "node_status" : {
            "type" : "array",
            "summary" : "Node Status",
            "label" : "Node Status",
            "items" : {
              "$ref" : "#/components/schemas/bridge.node_status"
            },
            "description" : "Node status."
          },
          "type" : {
            "type" : "enum",
            "symbols" : [
              "pgsql"
            ],
            "summary" : "Bridge Type",
            "label" : "Bridge Type",
            "description" : "The Bridge Type"
          },
          "name" : {
            "type" : "string",
            "summary" : "Bridge Name",
            "label" : "Bridge Name",
            "description" : "Bridge name."
          },
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "sql" : {
            "type" : "string",
            "summary" : "SQL Template",
            "label" : "SQL Template",
            "format" : "sql",
            "description" : "SQL Template",
            "default" : "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))"
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "The MQTT topic filter to be forwarded to PostgreSQL. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/resource_schema.creation_opts",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "server" : {
            "type" : "string",
            "summary" : "Server Host",
            "label" : "Server Host",
            "description" : "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The PostgreSQL default port 5432 is used if `[:Port]` is not specified."
          },
          "database" : {
            "type" : "string",
            "summary" : "Database Name",
            "label" : "Database Name",
            "description" : "Database name."
          },
          "pool_size" : {
            "type" : "string",
            "summary" : "Connection Pool Size",
            "label" : "Connection Pool Size",
            "description" : "Size of the connection pool towards the bridge target service.",
            "default" : 8
          },
          "username" : {
            "type" : "string",
            "summary" : "Username",
            "label" : "Username",
            "description" : "EMQX's username in the external database."
          },
          "password" : {
            "type" : "string",
            "summary" : "Password",
            "label" : "Password",
            "format" : "password",
            "description" : "EMQX's password in the external database."
          },
          "auto_reconnect" : {
            "type" : "boolean",
            "summary" : "Deprecated. Auto Reconnect Database",
            "label" : "Deprecated. Auto Reconnect Database",
            "description" : "Deprecated. Enable automatic reconnect to the database.",
            "deprecated" : true,
            "default" : true
          },
          "ssl" : {
            "$ref" : "#/components/schemas/broker.ssl_client_opts",
            "summary" : "Enable SSL",
            "label" : "Enable SSL",
            "description" : "SSL connection settings.",
            "default" : {
              "enable" : false
            }
          }
        },
        "required" : [
          "database",
          "name",
          "server",
          "type"
        ]
      },
      "bridge_mqtt.get" : {
        "type" : "object",
        "properties" : {
          "status" : {
            "type" : "enum",
            "symbols" : [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "summary" : "Bridge Status",
            "label" : "Bridge Status",
            "description" : "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason" : {
            "type" : "string",
            "summary" : "Failure reason",
            "label" : "Failure reason",
            "example" : "Connection refused",
            "description" : "This is the reason given in case a bridge is failing to connect."
          },
          "node_status" : {
            "type" : "array",
            "summary" : "Node Status",
            "label" : "Node Status",
            "items" : {
              "$ref" : "#/components/schemas/bridge.node_status"
            },
            "description" : "Node status."
          },
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/bridge_mqtt.creation_opts",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "mode" : {
            "type" : "enum",
            "symbols" : [
              "cluster_shareload"
            ],
            "summary" : "MQTT Bridge Mode",
            "label" : "MQTT Bridge Mode",
            "description" : "The mode of the MQTT Bridge.<br/><br/>- cluster_shareload: create an MQTT connection on each node in the emqx cluster.<br/><br/>In 'cluster_shareload' mode, the incoming load from the remote broker is shared by<br/>using shared subscription.<br/><br/>Note that the 'clientid' is suffixed by the node name, this is to avoid<br/>clientid conflicts between different nodes. And we can only use shared subscription<br/>topic filters for <code>remote.topic</code> of ingress connections.",
            "default" : "cluster_shareload"
          },
          "server" : {
            "type" : "string",
            "summary" : "Broker IP And Port",
            "label" : "Broker IP And Port",
            "description" : "The host and port of the remote MQTT broker"
          },
          "clientid_prefix" : {
            "type" : "string",
            "summary" : "Clientid Prefix",
            "label" : "Clientid Prefix",
            "description" : "Optional prefix to prepend to the clientid used by egress bridges."
          },
          "reconnect_interval" : {
            "type" : "string",
            "label" : "reconnect_interval",
            "description" : "reconnect_interval Description",
            "deprecated" : true
          },
          "proto_ver" : {
            "type" : "enum",
            "symbols" : [
              "v3",
              "v4",
              "v5"
            ],
            "summary" : "Protocol Version",
            "label" : "Protocol Version",
            "description" : "The MQTT protocol version",
            "default" : "v4"
          },
          "bridge_mode" : {
            "type" : "boolean",
            "summary" : "Bridge Mode",
            "label" : "Bridge Mode",
            "description" : "If enable bridge mode.<br/>NOTE: This setting is only for MQTT protocol version older than 5.0, and the remote MQTT<br/>broker MUST support this feature.<br/>If bridge_mode is set to true, the bridge will indicate to the remote broker that it is a bridge not an ordinary client.<br/>This means that loop detection will be more effective and that retained messages will be propagated correctly.",
            "default" : false
          },
          "username" : {
            "type" : "string",
            "summary" : "Username",
            "label" : "Username",
            "description" : "The username of the MQTT protocol"
          },
          "password" : {
            "type" : "string",
            "summary" : "Password",
            "label" : "Password",
            "format" : "password",
            "description" : "The password of the MQTT protocol"
          },
          "clean_start" : {
            "type" : "boolean",
            "summary" : "Clean Session",
            "label" : "Clean Session",
            "description" : "Whether to start a clean session when reconnecting a remote broker for ingress bridge",
            "default" : true
          },
          "keepalive" : {
            "type" : "string",
            "label" : "keepalive",
            "description" : "MQTT Keepalive. Time interval is a string that contains a number followed by time unit:<br/>- `ms` for milliseconds,<br/>- `s` for seconds,<br/>- `m` for minutes,<br/>- `h` for hours;<br/><br/>or combination of whereof: `1h5m0s`",
            "default" : "300s"
          },
          "retry_interval" : {
            "type" : "string",
            "label" : "retry_interval",
            "description" : "Message retry interval. Delay for the MQTT bridge to retry sending the QoS1/QoS2 messages in case of ACK not received. Time interval is a string that contains a number followed by time unit:<br/>- `ms` for milliseconds,<br/>- `s` for seconds,<br/>- `m` for minutes,<br/>- `h` for hours;<br/><br/>or combination of whereof: `1h5m0s`",
            "default" : "15s"
          },
          "max_inflight" : {
            "type" : "number",
            "summary" : "Max Inflight Message",
            "minimum" : 1,
            "label" : "Max Inflight Message",
            "description" : "Max inflight (sent, but un-acked) messages of the MQTT protocol",
            "default" : 32
          },
          "ssl" : {
            "$ref" : "#/components/schemas/broker.ssl_client_opts",
            "summary" : "Enable SSL",
            "label" : "Enable SSL",
            "description" : "SSL connection settings.",
            "default" : {
              "enable" : false
            }
          },
          "ingress" : {
            "$ref" : "#/components/schemas/connector-mqtt.ingress",
            "summary" : "Ingress Configs",
            "label" : "Ingress Configs",
            "description" : "The ingress config defines how this bridge receive messages from the remote MQTT broker, and then<br/>        send them to the local broker.<br/><br/>        Template with variables is allowed in 'remote.qos', 'local.topic', 'local.qos', 'local.retain', 'local.payload'.<br/><br/>        NOTE: if this bridge is used as the input of a rule, and also 'local.topic' is<br/>        configured, then messages got from the remote broker will be sent to both the 'local.topic' and<br/>        the rule."
          },
          "egress" : {
            "$ref" : "#/components/schemas/connector-mqtt.egress",
            "summary" : "Egress Configs",
            "label" : "Egress Configs",
            "description" : "The egress config defines how this bridge forwards messages from the local broker to the remote broker.<br/><br/>Template with variables is allowed in 'remote.topic', 'local.qos', 'local.retain', 'local.payload'.<br/><br/>NOTE: if this bridge is used as the action of a rule, and also 'local.topic'<br/>is configured, then both the data got from the rule and the MQTT messages that matches<br/>'local.topic' will be forwarded."
          }
        },
        "required" : [
          "server"
        ]
      },
      "bridge_dynamo.put" : {
        "type" : "object",
        "properties" : {
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "template" : {
            "type" : "string",
            "summary" : "Template",
            "label" : "Template",
            "description" : "Template, the default value is empty. When this value is empty the whole message will be stored in the database",
            "default" : ""
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "The MQTT topic filter to be forwarded to DynamoDB. All MQTT `PUBLISH` messages with the topic<br/>matching the `local_topic` will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also `local_topic` is<br/>configured, then both the data got from the rule and the MQTT messages that match `local_topic`<br/>will be forwarded."
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/bridge_dynamo.creation_opts",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "url" : {
            "type" : "string",
            "summary" : "DynamoDB Endpoint",
            "label" : "DynamoDB Endpoint",
            "description" : "The url of DynamoDB endpoint."
          },
          "table" : {
            "type" : "string",
            "summary" : "Table ",
            "label" : "Table ",
            "description" : "DynamoDB Table."
          },
          "aws_access_key_id" : {
            "type" : "string",
            "summary" : "AWS Access Key ID",
            "label" : "AWS Access Key ID",
            "description" : "Access Key ID for connecting to DynamoDB."
          },
          "aws_secret_access_key" : {
            "type" : "string",
            "summary" : "AWS Secret Access Key",
            "label" : "AWS Secret Access Key",
            "description" : "AWS Secret Access Key for connecting to DynamoDB."
          },
          "pool_size" : {
            "type" : "string",
            "summary" : "Connection Pool Size",
            "label" : "Connection Pool Size",
            "description" : "Size of the connection pool towards the bridge target service.",
            "default" : 8
          },
          "auto_reconnect" : {
            "type" : "boolean",
            "summary" : "Deprecated. Auto Reconnect Database",
            "label" : "Deprecated. Auto Reconnect Database",
            "description" : "Deprecated. Enable automatic reconnect to the database.",
            "deprecated" : true,
            "default" : true
          }
        },
        "required" : [
          "aws_access_key_id",
          "aws_secret_access_key",
          "table",
          "url"
        ]
      },
      "bridge_redis.put_sentinel" : {
        "type" : "object",
        "properties" : {
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "The MQTT topic filter to be forwarded to Redis. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "command_template" : {
            "type" : "array",
            "summary" : "Redis Command Template",
            "label" : "Redis Command Template",
            "items" : {
              "type" : "string"
            },
            "description" : "Redis command template used to export messages. Each list element stands for a command name or its argument.<br/>For example, to push payloads in a Redis list by key `msgs`, the elements should be the following:<br/>`rpush`, `msgs`, `${payload}`."
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/bridge_redis.creation_opts_redis_sentinel",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "servers" : {
            "type" : "string",
            "summary" : "Servers",
            "label" : "Servers",
            "description" : "A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`<br/>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.<br/>A host entry has the following form: `Host[:Port]`.<br/>The Redis default port 6379 is used if `[:Port]` is not specified."
          },
          "redis_type" : {
            "type" : "enum",
            "symbols" : [
              "sentinel"
            ],
            "summary" : "Sentinel Mode",
            "label" : "Sentinel Mode",
            "description" : "Sentinel mode. Must be set to 'sentinel' when Redis server is running in sentinel mode.",
            "default" : "sentinel"
          },
          "sentinel" : {
            "type" : "string",
            "summary" : "Cluster Name",
            "label" : "Cluster Name",
            "description" : "The cluster name in Redis sentinel mode."
          },
          "pool_size" : {
            "type" : "string",
            "summary" : "Connection Pool Size",
            "label" : "Connection Pool Size",
            "description" : "Size of the connection pool towards the bridge target service.",
            "default" : 8
          },
          "password" : {
            "type" : "string",
            "summary" : "Password",
            "label" : "Password",
            "format" : "password",
            "description" : "EMQX's password in the external database."
          },
          "database" : {
            "type" : "number",
            "summary" : "Database ID",
            "label" : "Database ID",
            "description" : "Redis database ID.",
            "default" : 0
          },
          "auto_reconnect" : {
            "type" : "boolean",
            "summary" : "Deprecated. Auto Reconnect Database",
            "label" : "Deprecated. Auto Reconnect Database",
            "description" : "Deprecated. Enable automatic reconnect to the database.",
            "deprecated" : true,
            "default" : true
          },
          "ssl" : {
            "$ref" : "#/components/schemas/broker.ssl_client_opts",
            "summary" : "Enable SSL",
            "label" : "Enable SSL",
            "description" : "SSL connection settings.",
            "default" : {
              "enable" : false
            }
          }
        },
        "required" : [
          "command_template",
          "sentinel",
          "servers"
        ]
      },
      "bridge_kafka.producer_kafka_opts" : {
        "type" : "object",
        "properties" : {
          "topic" : {
            "type" : "string",
            "summary" : "Kafka Topic Name",
            "label" : "Kafka Topic Name",
            "description" : "Kafka topic name"
          },
          "message" : {
            "$ref" : "#/components/schemas/bridge_kafka.kafka_message",
            "summary" : "Kafka Message Template",
            "label" : "Kafka Message Template",
            "description" : "Template to render a Kafka message."
          },
          "max_batch_bytes" : {
            "type" : "byteSize",
            "summary" : "Max Batch Bytes",
            "label" : "Max Batch Bytes",
            "description" : "Maximum bytes to collect in a Kafka message batch. Most of the Kafka brokers default to a limit of 1 MB batch size. EMQX's default value is less than 1 MB in order to compensate Kafka message encoding overheads (especially when each individual message is very small). When a single message is over the limit, it is still sent (as a single element batch).",
            "default" : "896KB"
          },
          "compression" : {
            "type" : "enum",
            "symbols" : [
              "no_compression",
              "snappy",
              "gzip"
            ],
            "summary" : "Compression",
            "label" : "Compression",
            "description" : "Compression method.",
            "default" : "no_compression"
          },
          "partition_strategy" : {
            "type" : "enum",
            "symbols" : [
              "random",
              "key_dispatch"
            ],
            "summary" : "Partition Strategy",
            "label" : "Partition Strategy",
            "description" : "Partition strategy is to tell the producer how to dispatch messages to Kafka partitions.<br/><br/><code>random</code>: Randomly pick a partition for each message<br/><code>key_dispatch</code>: Hash Kafka message key to a partition number",
            "default" : "random"
          },
          "required_acks" : {
            "type" : "enum",
            "symbols" : [
              "all_isr",
              "leader_only",
              "none"
            ],
            "summary" : "Required Acks",
            "label" : "Required Acks",
            "description" : "Required acknowledgements for Kafka partition leader to wait for its followers before it sends back the acknowledgement to EMQX Kafka producer<br/><br/><code>all_isr</code>: Require all in-sync replicas to acknowledge.<br/><code>leader_only</code>: Require only the partition-leader's acknowledgement.<br/><code>none</code>: No need for Kafka to acknowledge at all.",
            "default" : "all_isr"
          },
          "partition_count_refresh_interval" : {
            "type" : "duration",
            "summary" : "Partition Count Refresh Interval",
            "label" : "Partition Count Refresh Interval",
            "description" : "The time interval for Kafka producer to discover increased number of partitions.<br/>After the number of partitions is increased in Kafka, EMQX will start taking the <br/>discovered partitions into account when dispatching messages per <code>partition_strategy</code>.",
            "default" : "60s"
          },
          "max_inflight" : {
            "type" : "string",
            "summary" : "Max Inflight",
            "label" : "Max Inflight",
            "description" : "Maximum number of batches allowed for Kafka producer (per-partition) to send before receiving acknowledgement from Kafka. Greater value typically means better throughput. However, there can be a risk of message reordering when this value is greater than 1.",
            "default" : 10
          },
          "buffer" : {
            "$ref" : "#/components/schemas/bridge_kafka.producer_buffer",
            "summary" : "Message Buffer",
            "label" : "Message Buffer",
            "description" : "Configure producer message buffer.<br/><br/>Tell Kafka producer how to buffer messages when EMQX has more messages to send than Kafka can keep up, or when Kafka is down."
          }
        },
        "required" : [
          "topic"
        ]
      },
      "bridge_tdengine.put" : {
        "type" : "object",
        "properties" : {
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "sql" : {
            "type" : "string",
            "summary" : "SQL Template",
            "label" : "SQL Template",
            "format" : "sql",
            "description" : "SQL Template",
            "default" : "insert into t_mqtt_msg(ts, msgid, mqtt_topic, qos, payload, arrived) values (${ts}, ${id}, ${topic}, ${qos}, ${payload}, ${timestamp})"
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "The MQTT topic filter to be forwarded to TDengine. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/resource_schema.creation_opts",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "server" : {
            "type" : "string",
            "summary" : "Server Host",
            "label" : "Server Host",
            "description" : "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The TDengine default port 6041 is used if `[:Port]` is not specified."
          },
          "database" : {
            "type" : "string",
            "summary" : "Database Name",
            "label" : "Database Name",
            "description" : "Database name."
          },
          "pool_size" : {
            "type" : "string",
            "summary" : "Connection Pool Size",
            "label" : "Connection Pool Size",
            "description" : "Size of the connection pool towards the bridge target service.",
            "default" : 8
          },
          "username" : {
            "type" : "string",
            "summary" : "Username",
            "label" : "Username",
            "description" : "EMQX's username in the external database.",
            "default" : "root"
          },
          "password" : {
            "type" : "string",
            "summary" : "Password",
            "label" : "Password",
            "format" : "password",
            "description" : "EMQX's password in the external database."
          },
          "auto_reconnect" : {
            "type" : "boolean",
            "summary" : "Deprecated. Auto Reconnect Database",
            "label" : "Deprecated. Auto Reconnect Database",
            "description" : "Deprecated. Enable automatic reconnect to the database.",
            "deprecated" : true,
            "default" : true
          }
        },
        "required" : [
          "database",
          "password",
          "server"
        ]
      },
      "bridge_mqtt.post" : {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "enum",
            "symbols" : [
              "mqtt"
            ],
            "summary" : "Bridge Type",
            "label" : "Bridge Type",
            "description" : "The bridge type."
          },
          "name" : {
            "type" : "string",
            "summary" : "Bridge Name",
            "label" : "Bridge Name",
            "description" : "Bridge name, used as a human-readable description of the bridge."
          },
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/bridge_mqtt.creation_opts",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "mode" : {
            "type" : "enum",
            "symbols" : [
              "cluster_shareload"
            ],
            "summary" : "MQTT Bridge Mode",
            "label" : "MQTT Bridge Mode",
            "description" : "The mode of the MQTT Bridge.<br/><br/>- cluster_shareload: create an MQTT connection on each node in the emqx cluster.<br/><br/>In 'cluster_shareload' mode, the incoming load from the remote broker is shared by<br/>using shared subscription.<br/><br/>Note that the 'clientid' is suffixed by the node name, this is to avoid<br/>clientid conflicts between different nodes. And we can only use shared subscription<br/>topic filters for <code>remote.topic</code> of ingress connections.",
            "default" : "cluster_shareload"
          },
          "server" : {
            "type" : "string",
            "summary" : "Broker IP And Port",
            "label" : "Broker IP And Port",
            "description" : "The host and port of the remote MQTT broker"
          },
          "clientid_prefix" : {
            "type" : "string",
            "summary" : "Clientid Prefix",
            "label" : "Clientid Prefix",
            "description" : "Optional prefix to prepend to the clientid used by egress bridges."
          },
          "reconnect_interval" : {
            "type" : "string",
            "label" : "reconnect_interval",
            "description" : "reconnect_interval Description",
            "deprecated" : true
          },
          "proto_ver" : {
            "type" : "enum",
            "symbols" : [
              "v3",
              "v4",
              "v5"
            ],
            "summary" : "Protocol Version",
            "label" : "Protocol Version",
            "description" : "The MQTT protocol version",
            "default" : "v4"
          },
          "bridge_mode" : {
            "type" : "boolean",
            "summary" : "Bridge Mode",
            "label" : "Bridge Mode",
            "description" : "If enable bridge mode.<br/>NOTE: This setting is only for MQTT protocol version older than 5.0, and the remote MQTT<br/>broker MUST support this feature.<br/>If bridge_mode is set to true, the bridge will indicate to the remote broker that it is a bridge not an ordinary client.<br/>This means that loop detection will be more effective and that retained messages will be propagated correctly.",
            "default" : false
          },
          "username" : {
            "type" : "string",
            "summary" : "Username",
            "label" : "Username",
            "description" : "The username of the MQTT protocol"
          },
          "password" : {
            "type" : "string",
            "summary" : "Password",
            "label" : "Password",
            "format" : "password",
            "description" : "The password of the MQTT protocol"
          },
          "clean_start" : {
            "type" : "boolean",
            "summary" : "Clean Session",
            "label" : "Clean Session",
            "description" : "Whether to start a clean session when reconnecting a remote broker for ingress bridge",
            "default" : true
          },
          "keepalive" : {
            "type" : "string",
            "label" : "keepalive",
            "description" : "MQTT Keepalive. Time interval is a string that contains a number followed by time unit:<br/>- `ms` for milliseconds,<br/>- `s` for seconds,<br/>- `m` for minutes,<br/>- `h` for hours;<br/><br/>or combination of whereof: `1h5m0s`",
            "default" : "300s"
          },
          "retry_interval" : {
            "type" : "string",
            "label" : "retry_interval",
            "description" : "Message retry interval. Delay for the MQTT bridge to retry sending the QoS1/QoS2 messages in case of ACK not received. Time interval is a string that contains a number followed by time unit:<br/>- `ms` for milliseconds,<br/>- `s` for seconds,<br/>- `m` for minutes,<br/>- `h` for hours;<br/><br/>or combination of whereof: `1h5m0s`",
            "default" : "15s"
          },
          "max_inflight" : {
            "type" : "number",
            "summary" : "Max Inflight Message",
            "minimum" : 1,
            "label" : "Max Inflight Message",
            "description" : "Max inflight (sent, but un-acked) messages of the MQTT protocol",
            "default" : 32
          },
          "ssl" : {
            "$ref" : "#/components/schemas/broker.ssl_client_opts",
            "summary" : "Enable SSL",
            "label" : "Enable SSL",
            "description" : "SSL connection settings.",
            "default" : {
              "enable" : false
            }
          },
          "ingress" : {
            "$ref" : "#/components/schemas/connector-mqtt.ingress",
            "summary" : "Ingress Configs",
            "label" : "Ingress Configs",
            "description" : "The ingress config defines how this bridge receive messages from the remote MQTT broker, and then<br/>        send them to the local broker.<br/><br/>        Template with variables is allowed in 'remote.qos', 'local.topic', 'local.qos', 'local.retain', 'local.payload'.<br/><br/>        NOTE: if this bridge is used as the input of a rule, and also 'local.topic' is<br/>        configured, then messages got from the remote broker will be sent to both the 'local.topic' and<br/>        the rule."
          },
          "egress" : {
            "$ref" : "#/components/schemas/connector-mqtt.egress",
            "summary" : "Egress Configs",
            "label" : "Egress Configs",
            "description" : "The egress config defines how this bridge forwards messages from the local broker to the remote broker.<br/><br/>Template with variables is allowed in 'remote.topic', 'local.qos', 'local.retain', 'local.payload'.<br/><br/>NOTE: if this bridge is used as the action of a rule, and also 'local.topic'<br/>is configured, then both the data got from the rule and the MQTT messages that matches<br/>'local.topic' will be forwarded."
          }
        },
        "required" : [
          "name",
          "server",
          "type"
        ]
      },
      "bridge_kafka.kafka_message" : {
        "type" : "object",
        "properties" : {
          "key" : {
            "type" : "string",
            "summary" : "Message Key",
            "label" : "Message Key",
            "description" : "Template to render Kafka message key. If the template is rendered into a NULL value (i.e. there is no such data field in Rule Engine context) then Kafka's <code>NULL</code> (but not empty string) is used.",
            "default" : "${.clientid}"
          },
          "value" : {
            "type" : "string",
            "summary" : "Message Value",
            "label" : "Message Value",
            "description" : "Template to render Kafka message value. If the template is rendered into a NULL value (i.e. there is no such data field in Rule Engine context) then Kafka's <code>NULL</code> (but not empty string) is used.",
            "default" : "${.}"
          },
          "timestamp" : {
            "type" : "string",
            "summary" : "Message Timestamp",
            "label" : "Message Timestamp",
            "description" : "Which timestamp to use. The timestamp is expected to be a millisecond precision Unix epoch which can be in string format, e.g. <code>1661326462115</code> or <code>'1661326462115'</code>. When the desired data field for this template is not found, or if the found data is not a valid integer, the current system timestamp will be used.",
            "default" : "${.timestamp}"
          }
        }
      },
      "bridge_timescale.put" : {
        "type" : "object",
        "properties" : {
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "sql" : {
            "type" : "string",
            "summary" : "SQL Template",
            "label" : "SQL Template",
            "format" : "sql",
            "description" : "SQL Template",
            "default" : "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))"
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "The MQTT topic filter to be forwarded to PostgreSQL. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/resource_schema.creation_opts",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "server" : {
            "type" : "string",
            "summary" : "Server Host",
            "label" : "Server Host",
            "description" : "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The PostgreSQL default port 5432 is used if `[:Port]` is not specified."
          },
          "database" : {
            "type" : "string",
            "summary" : "Database Name",
            "label" : "Database Name",
            "description" : "Database name."
          },
          "pool_size" : {
            "type" : "string",
            "summary" : "Connection Pool Size",
            "label" : "Connection Pool Size",
            "description" : "Size of the connection pool towards the bridge target service.",
            "default" : 8
          },
          "username" : {
            "type" : "string",
            "summary" : "Username",
            "label" : "Username",
            "description" : "EMQX's username in the external database."
          },
          "password" : {
            "type" : "string",
            "summary" : "Password",
            "label" : "Password",
            "format" : "password",
            "description" : "EMQX's password in the external database."
          },
          "auto_reconnect" : {
            "type" : "boolean",
            "summary" : "Deprecated. Auto Reconnect Database",
            "label" : "Deprecated. Auto Reconnect Database",
            "description" : "Deprecated. Enable automatic reconnect to the database.",
            "deprecated" : true,
            "default" : true
          },
          "ssl" : {
            "$ref" : "#/components/schemas/broker.ssl_client_opts",
            "summary" : "Enable SSL",
            "label" : "Enable SSL",
            "description" : "SSL connection settings.",
            "default" : {
              "enable" : false
            }
          }
        },
        "required" : [
          "database",
          "server"
        ]
      },
      "bridge_mongodb.get_single" : {
        "type" : "object",
        "properties" : {
          "status" : {
            "type" : "enum",
            "symbols" : [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "summary" : "Bridge Status",
            "label" : "Bridge Status",
            "description" : "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason" : {
            "type" : "string",
            "summary" : "Failure reason",
            "label" : "Failure reason",
            "example" : "Connection refused",
            "description" : "This is the reason given in case a bridge is failing to connect."
          },
          "node_status" : {
            "type" : "array",
            "summary" : "Node Status",
            "label" : "Node Status",
            "items" : {
              "$ref" : "#/components/schemas/bridge.node_status"
            },
            "description" : "Node status."
          },
          "mongo_type" : {
            "type" : "enum",
            "symbols" : [
              "single"
            ],
            "summary" : "Standalone instance",
            "label" : "Standalone instance",
            "description" : "Standalone instance. Must be set to 'single' when MongoDB server is running in standalone mode.",
            "default" : "single"
          },
          "server" : {
            "type" : "string",
            "summary" : "Server Host",
            "label" : "Server Host",
            "description" : "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The MongoDB default port 27017 is used if `[:Port]` is not specified."
          },
          "w_mode" : {
            "type" : "enum",
            "symbols" : [
              "unsafe",
              "safe"
            ],
            "summary" : "Write Mode",
            "label" : "Write Mode",
            "description" : "Write mode.",
            "default" : "unsafe"
          },
          "srv_record" : {
            "type" : "boolean",
            "summary" : "Srv Record",
            "label" : "Srv Record",
            "description" : "Use DNS SRV record.",
            "default" : false
          },
          "pool_size" : {
            "type" : "string",
            "summary" : "Connection Pool Size",
            "label" : "Connection Pool Size",
            "description" : "Size of the connection pool towards the bridge target service.",
            "default" : 8
          },
          "username" : {
            "type" : "string",
            "summary" : "Username",
            "label" : "Username",
            "description" : "EMQX's username in the external database."
          },
          "password" : {
            "type" : "string",
            "summary" : "Password",
            "label" : "Password",
            "format" : "password",
            "description" : "EMQX's password in the external database."
          },
          "auth_source" : {
            "type" : "string",
            "summary" : "Auth Source",
            "label" : "Auth Source",
            "description" : "Database name associated with the user's credentials."
          },
          "database" : {
            "type" : "string",
            "summary" : "Database Name",
            "label" : "Database Name",
            "description" : "Database name."
          },
          "topology" : {
            "$ref" : "#/components/schemas/emqx_connector_mongo.topology",
            "label" : "topology",
            "description" : "topology Description"
          },
          "ssl" : {
            "$ref" : "#/components/schemas/broker.ssl_client_opts",
            "summary" : "Enable SSL",
            "label" : "Enable SSL",
            "description" : "SSL connection settings.",
            "default" : {
              "enable" : false
            }
          },
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable or disable",
            "label" : "Enable or disable",
            "description" : "Enable or disable this MongoDB Bridge",
            "default" : true
          },
          "collection" : {
            "type" : "string",
            "summary" : "Collection to be used",
            "label" : "Collection to be used",
            "description" : "The collection where data will be stored into",
            "default" : "mqtt"
          },
          "payload_template" : {
            "type" : "string",
            "summary" : "Payload template",
            "label" : "Payload template",
            "description" : "The template for formatting the outgoing messages.  If undefined, rule engine will use JSON format to serialize all visible inputs, such as clientid, topic, payload etc."
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/resource_schema.creation_opts",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "type" : {
            "type" : "enum",
            "symbols" : [
              "mongodb_single"
            ],
            "summary" : "Bridge Type",
            "label" : "Bridge Type",
            "description" : "The Bridge Type."
          },
          "name" : {
            "type" : "string",
            "summary" : "Bridge Name",
            "label" : "Bridge Name",
            "description" : "Bridge name."
          }
        },
        "required" : [
          "database",
          "name",
          "server",
          "type"
        ]
      },
      "bridge_rocketmq.get" : {
        "type" : "object",
        "properties" : {
          "status" : {
            "type" : "enum",
            "symbols" : [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "summary" : "Bridge Status",
            "label" : "Bridge Status",
            "description" : "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason" : {
            "type" : "string",
            "summary" : "Failure reason",
            "label" : "Failure reason",
            "example" : "Connection refused",
            "description" : "This is the reason given in case a bridge is failing to connect."
          },
          "node_status" : {
            "type" : "array",
            "summary" : "Node Status",
            "label" : "Node Status",
            "items" : {
              "$ref" : "#/components/schemas/bridge.node_status"
            },
            "description" : "Node status."
          },
          "type" : {
            "type" : "enum",
            "symbols" : [
              "rocketmq"
            ],
            "summary" : "Bridge Type",
            "label" : "Bridge Type",
            "description" : "The Bridge Type"
          },
          "name" : {
            "type" : "string",
            "summary" : "Bridge Name",
            "label" : "Bridge Name",
            "description" : "Bridge name."
          },
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "template" : {
            "type" : "string",
            "summary" : "Template",
            "label" : "Template",
            "description" : "Template, the default value is empty. When this value is empty the whole message will be stored in the RocketMQ.<br><br/>            The template can be any valid string with placeholders, example:<br><br/>            - ${id}, ${username}, ${clientid}, ${timestamp}<br><br/>            - {\"id\" : ${id}, \"username\" : ${username}}",
            "default" : ""
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "The MQTT topic filter to be forwarded to RocketMQ. All MQTT `PUBLISH` messages with the topic<br/>matching the `local_topic` will be forwarded.</br><br/>NOTE: if the bridge is used as a rule action, `local_topic` should be left empty otherwise the messages will be duplicated."
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/resource_schema.creation_opts",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "servers" : {
            "type" : "string",
            "summary" : "Server Host",
            "label" : "Server Host",
            "description" : "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The RocketMQ default port 9876 is used if `[:Port]` is not specified."
          },
          "topic" : {
            "type" : "string",
            "summary" : "RocketMQ Topic",
            "label" : "RocketMQ Topic",
            "description" : "RocketMQ Topic",
            "default" : "TopicTest"
          },
          "access_key" : {
            "type" : "string",
            "summary" : "AccessKey",
            "label" : "AccessKey",
            "description" : "RocketMQ server `accessKey`.",
            "default" : ""
          },
          "secret_key" : {
            "type" : "string",
            "summary" : "SecretKey",
            "label" : "SecretKey",
            "description" : "RocketMQ server `secretKey`.",
            "default" : ""
          },
          "security_token" : {
            "type" : "string",
            "summary" : "Security Token",
            "label" : "Security Token",
            "description" : "RocketMQ Server Security Token",
            "default" : ""
          },
          "sync_timeout" : {
            "type" : "duration",
            "summary" : "Sync Timeout",
            "label" : "Sync Timeout",
            "description" : "Timeout of RocketMQ driver synchronous call.",
            "default" : "3s"
          },
          "refresh_interval" : {
            "type" : "duration",
            "summary" : "Topic Route Refresh Interval",
            "label" : "Topic Route Refresh Interval",
            "description" : "RocketMQ Topic Route Refresh Interval.",
            "default" : "3s"
          },
          "send_buffer" : {
            "type" : "byteSize",
            "summary" : "Send Buffer Size",
            "label" : "Send Buffer Size",
            "description" : "The socket send buffer size of the RocketMQ driver client.",
            "default" : "1024KB"
          },
          "pool_size" : {
            "type" : "string",
            "summary" : "Connection Pool Size",
            "label" : "Connection Pool Size",
            "description" : "Size of the connection pool towards the bridge target service.",
            "default" : 8
          },
          "auto_reconnect" : {
            "type" : "boolean",
            "summary" : "Deprecated. Auto Reconnect Database",
            "label" : "Deprecated. Auto Reconnect Database",
            "description" : "Deprecated. Enable automatic reconnect to the database.",
            "deprecated" : true,
            "default" : true
          }
        },
        "required" : [
          "name",
          "servers",
          "type"
        ]
      },
      "bridge_kafka.socket_opts" : {
        "type" : "object",
        "properties" : {
          "sndbuf" : {
            "type" : "byteSize",
            "summary" : "Socket Send Buffer Size",
            "label" : "Socket Send Buffer Size",
            "description" : "Fine tune the socket send buffer. The default value is tuned for high throughput.",
            "default" : "1MB"
          },
          "recbuf" : {
            "type" : "byteSize",
            "summary" : "Socket Receive Buffer Size",
            "label" : "Socket Receive Buffer Size",
            "description" : "Fine tune the socket receive buffer. The default value is tuned for high throughput.",
            "default" : "1MB"
          }
        }
      },
      "bridge_redis.post_single" : {
        "type" : "object",
        "properties" : {
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "The MQTT topic filter to be forwarded to Redis. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "command_template" : {
            "type" : "array",
            "summary" : "Redis Command Template",
            "label" : "Redis Command Template",
            "items" : {
              "type" : "string"
            },
            "description" : "Redis command template used to export messages. Each list element stands for a command name or its argument.<br/>For example, to push payloads in a Redis list by key `msgs`, the elements should be the following:<br/>`rpush`, `msgs`, `${payload}`."
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/bridge_redis.creation_opts_redis_single",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "server" : {
            "type" : "string",
            "summary" : "Server Host",
            "label" : "Server Host",
            "description" : "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The Redis default port 6379 is used if `[:Port]` is not specified."
          },
          "redis_type" : {
            "type" : "enum",
            "symbols" : [
              "single"
            ],
            "summary" : "Single Mode",
            "label" : "Single Mode",
            "description" : "Single mode. Must be set to 'single' when Redis server is running in single mode.",
            "default" : "single"
          },
          "pool_size" : {
            "type" : "string",
            "summary" : "Connection Pool Size",
            "label" : "Connection Pool Size",
            "description" : "Size of the connection pool towards the bridge target service.",
            "default" : 8
          },
          "password" : {
            "type" : "string",
            "summary" : "Password",
            "label" : "Password",
            "format" : "password",
            "description" : "EMQX's password in the external database."
          },
          "database" : {
            "type" : "number",
            "summary" : "Database ID",
            "label" : "Database ID",
            "description" : "Redis database ID.",
            "default" : 0
          },
          "auto_reconnect" : {
            "type" : "boolean",
            "summary" : "Deprecated. Auto Reconnect Database",
            "label" : "Deprecated. Auto Reconnect Database",
            "description" : "Deprecated. Enable automatic reconnect to the database.",
            "deprecated" : true,
            "default" : true
          },
          "ssl" : {
            "$ref" : "#/components/schemas/broker.ssl_client_opts",
            "summary" : "Enable SSL",
            "label" : "Enable SSL",
            "description" : "SSL connection settings.",
            "default" : {
              "enable" : false
            }
          },
          "type" : {
            "type" : "enum",
            "symbols" : [
              "redis_single"
            ],
            "summary" : "Bridge Type",
            "label" : "Bridge Type",
            "description" : "The Bridge Type"
          },
          "name" : {
            "type" : "string",
            "summary" : "Bridge Name",
            "label" : "Bridge Name",
            "description" : "Bridge name, used as a human-readable description of the bridge."
          }
        },
        "required" : [
          "command_template",
          "name",
          "server",
          "type"
        ]
      },
      "connector-mqtt.ingress_local" : {
        "type" : "object",
        "properties" : {
          "topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "Send messages to which topic of the local broker.<br/><br/>Template with variables is allowed."
          },
          "qos" : {
            "oneOf" : [
              {
                "type" : "string"
              },
              {
                "type" : "enum",
                "symbols" : [
                  0,
                  1,
                  2
                ]
              }
            ],
            "summary" : "Local QoS",
            "label" : "Local QoS",
            "description" : "The QoS of the MQTT message to be sent.<br/><br/>Template with variables is allowed.",
            "default" : "${qos}"
          },
          "retain" : {
            "oneOf" : [
              {
                "type" : "string"
              },
              {
                "type" : "boolean"
              }
            ],
            "summary" : "Retain Flag",
            "label" : "Retain Flag",
            "description" : "The 'retain' flag of the MQTT message to be sent.<br/><br/>Template with variables is allowed.",
            "default" : "${retain}"
          },
          "payload" : {
            "type" : "string",
            "summary" : "Payload",
            "label" : "Payload",
            "description" : "The payload of the MQTT message to be sent.<br/><br/>Template with variables is allowed."
          }
        }
      },
      "bridge_mysql.post" : {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "enum",
            "symbols" : [
              "mysql"
            ],
            "summary" : "Bridge Type",
            "label" : "Bridge Type",
            "description" : "The Bridge Type"
          },
          "name" : {
            "type" : "string",
            "summary" : "Bridge Name",
            "label" : "Bridge Name",
            "description" : "Bridge name, used as a human-readable description of the bridge."
          },
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "sql" : {
            "type" : "string",
            "summary" : "SQL Template",
            "label" : "SQL Template",
            "format" : "sql",
            "description" : "SQL Template",
            "default" : "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, FROM_UNIXTIME(${timestamp}/1000))"
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "The MQTT topic filter to be forwarded to MySQL. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/resource_schema.creation_opts",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "server" : {
            "type" : "string",
            "summary" : "Server Host",
            "label" : "Server Host",
            "description" : "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The MySQL default port 3306 is used if `[:Port]` is not specified."
          },
          "database" : {
            "type" : "string",
            "summary" : "Database Name",
            "label" : "Database Name",
            "description" : "Database name."
          },
          "pool_size" : {
            "type" : "string",
            "summary" : "Connection Pool Size",
            "label" : "Connection Pool Size",
            "description" : "Size of the connection pool towards the bridge target service.",
            "default" : 8
          },
          "username" : {
            "type" : "string",
            "summary" : "Username",
            "label" : "Username",
            "description" : "EMQX's username in the external database.",
            "default" : "root"
          },
          "password" : {
            "type" : "string",
            "summary" : "Password",
            "label" : "Password",
            "format" : "password",
            "description" : "EMQX's password in the external database."
          },
          "auto_reconnect" : {
            "type" : "boolean",
            "summary" : "Deprecated. Auto Reconnect Database",
            "label" : "Deprecated. Auto Reconnect Database",
            "description" : "Deprecated. Enable automatic reconnect to the database.",
            "deprecated" : true,
            "default" : true
          },
          "ssl" : {
            "$ref" : "#/components/schemas/broker.ssl_client_opts",
            "summary" : "Enable SSL",
            "label" : "Enable SSL",
            "description" : "SSL connection settings.",
            "default" : {
              "enable" : false
            }
          }
        },
        "required" : [
          "database",
          "name",
          "server",
          "type"
        ]
      },
      "bridge_webhook.post" : {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "enum",
            "symbols" : [
              "webhook"
            ],
            "summary" : "Bridge Type",
            "label" : "Bridge Type",
            "description" : "The Bridge Type"
          },
          "name" : {
            "type" : "string",
            "summary" : "Bridge Name",
            "label" : "Bridge Name",
            "description" : "Bridge name, used as a human-readable description of the bridge."
          },
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/bridge_webhook.creation_opts",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "connect_timeout" : {
            "type" : "duration",
            "summary" : "Connect Timeout",
            "label" : "Connect Timeout",
            "description" : "The timeout when connecting to the HTTP server.",
            "default" : "15s"
          },
          "retry_interval" : {
            "type" : "duration",
            "label" : "retry_interval",
            "description" : "retry_interval Description",
            "deprecated" : true
          },
          "pool_type" : {
            "type" : "enum",
            "symbols" : [
              "random",
              "hash"
            ],
            "summary" : "Pool Type",
            "label" : "Pool Type",
            "description" : "The type of the pool. Can be one of `random`, `hash`.",
            "default" : "random"
          },
          "pool_size" : {
            "type" : "string",
            "summary" : "Pool Size",
            "label" : "Pool Size",
            "description" : "The pool size.",
            "default" : 8
          },
          "enable_pipelining" : {
            "type" : "string",
            "summary" : "HTTP Pipelineing",
            "label" : "HTTP Pipelineing",
            "description" : "A positive integer. Whether to send HTTP requests continuously, when set to 1, it means that after each HTTP request is sent, you need to wait for the server to return and then continue to send the next request.",
            "default" : 100
          },
          "request" : {
            "$ref" : "#/components/schemas/connector-http.request",
            "summary" : "Request",
            "label" : "Request",
            "description" : "Configure HTTP request parameters."
          },
          "ssl" : {
            "$ref" : "#/components/schemas/broker.ssl_client_opts",
            "summary" : "Enable SSL",
            "label" : "Enable SSL",
            "description" : "SSL connection settings.",
            "default" : {
              "enable" : false
            }
          },
          "url" : {
            "type" : "string",
            "summary" : "HTTP Bridge",
            "label" : "HTTP Bridge",
            "description" : "The URL of the HTTP Bridge.<br/><br/>Template with variables is allowed in the path, but variables cannot be used in the scheme, host,<br/>or port part.<br/><br/>For example, <code> http://localhost:9901/${topic} </code> is allowed, but<br/><code> http://${host}:9901/message </code> or <code> http://localhost:${port}/message </code><br/>is not allowed."
          },
          "direction" : {
            "type" : "enum",
            "symbols" : [
              "egress"
            ],
            "summary" : "Bridge Direction",
            "label" : "Bridge Direction",
            "description" : "Deprecated, The direction of this bridge, MUST be 'egress'",
            "deprecated" : true
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "The MQTT topic filter to be forwarded to the HTTP server. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "method" : {
            "type" : "enum",
            "symbols" : [
              "post",
              "put",
              "get",
              "delete"
            ],
            "summary" : "HTTP Method",
            "label" : "HTTP Method",
            "description" : "The method of the HTTP request. All the available methods are: post, put, get, delete.<br/><br/>Template with variables is allowed.",
            "default" : "post"
          },
          "headers" : {
            "type" : "object",
            "summary" : "HTTP Header",
            "label" : "HTTP Header",
            "description" : "The headers of the HTTP request.<br/><br/>Template with variables is allowed.",
            "default" : {
              "keep-alive" : "timeout=5",
              "content-type" : "application/json",
              "connection" : "keep-alive",
              "cache-control" : "no-cache",
              "accept" : "application/json"
            }
          },
          "body" : {
            "type" : "string",
            "summary" : "HTTP Body",
            "label" : "HTTP Body",
            "description" : "The body of the HTTP request.<br/><br/>If not provided, the body will be a JSON object of all the available fields.<br/><br/>There, 'all the available fields' means the context of a MQTT message when<br/>this webhook is triggered by receiving a MQTT message (the `local_topic` is set),<br/>or the context of the event when this webhook is triggered by a rule (i.e. this<br/>webhook is used as an action of a rule).<br/><br/>Template with variables is allowed."
          },
          "max_retries" : {
            "type" : "number",
            "summary" : "HTTP Request Max Retries",
            "minimum" : 1,
            "label" : "HTTP Request Max Retries",
            "description" : "HTTP request max retry times if failed.",
            "default" : 2
          },
          "request_timeout" : {
            "type" : "duration",
            "summary" : "HTTP Request Timeout",
            "label" : "HTTP Request Timeout",
            "description" : "HTTP request timeout.",
            "default" : "15s"
          }
        },
        "required" : [
          "name",
          "type",
          "url"
        ]
      },
      "bridge_sqlserver.creation_opts" : {
        "type" : "object",
        "properties" : {
          "worker_pool_size" : {
            "type" : "number",
            "summary" : "Buffer Pool Size",
            "minimum" : 1,
            "label" : "Buffer Pool Size",
            "description" : "The number of buffer workers. Only applicable for egress type bridges.<br/>For bridges only have ingress direction data flow, it can be set to 0 otherwise must be greater than 0.",
            "default" : 16
          },
          "health_check_interval" : {
            "type" : "duration",
            "summary" : "Health Check Interval",
            "label" : "Health Check Interval",
            "description" : "Health check interval.",
            "default" : "15s"
          },
          "start_after_created" : {
            "type" : "boolean",
            "summary" : "Start After Created",
            "label" : "Start After Created",
            "description" : "Whether start the resource right after created.",
            "default" : "true"
          },
          "start_timeout" : {
            "type" : "duration",
            "summary" : "Start Timeout",
            "label" : "Start Timeout",
            "description" : "Time interval to wait for an auto-started resource to become healthy before responding resource creation requests.",
            "default" : "5s"
          },
          "auto_restart_interval" : {
            "oneOf" : [
              {
                "type" : "duration"
              },
              {
                "type" : "enum",
                "symbols" : [
                  "infinity"
                ]
              }
            ],
            "summary" : "Auto Restart Interval",
            "label" : "Auto Restart Interval",
            "description" : "The auto restart interval after the resource is disconnected.",
            "default" : "60s"
          },
          "query_mode" : {
            "type" : "enum",
            "symbols" : [
              "sync",
              "async"
            ],
            "summary" : "Query mode",
            "label" : "Query mode",
            "description" : "Query mode. Optional 'sync/async', default 'async'.",
            "default" : "async"
          },
          "request_timeout" : {
            "oneOf" : [
              {
                "type" : "duration"
              },
              {
                "type" : "enum",
                "symbols" : [
                  "infinity"
                ]
              }
            ],
            "summary" : "Request Expiry",
            "label" : "Request Expiry",
            "description" : "Starting from the moment when the request enters the buffer, if the request remains in the buffer for the specified time or is sent but does not receive a response or acknowledgement in time, the request is considered expired.",
            "default" : "15s"
          },
          "inflight_window" : {
            "type" : "string",
            "summary" : "Inflight window",
            "label" : "Inflight window",
            "description" : "Query inflight window. When query_mode is set to async, this config has to be set to 1 if messages from the same MQTT client have to be strictly ordered.",
            "default" : 100
          },
          "enable_batch" : {
            "type" : "boolean",
            "summary" : "Enable batch",
            "label" : "Enable batch",
            "description" : "Batch mode enabled.",
            "deprecated" : true,
            "default" : true
          },
          "batch_size" : {
            "type" : "string",
            "summary" : "Max batch size",
            "label" : "Max batch size",
            "description" : "Maximum batch count. If equal to 1, there's effectively no batching.",
            "default" : 1
          },
          "batch_time" : {
            "type" : "duration",
            "summary" : "Max batch wait time",
            "label" : "Max batch wait time",
            "description" : "Maximum waiting interval when accumulating a batch at a low message rates for more efficient resource usage.",
            "default" : "0ms"
          },
          "enable_queue" : {
            "type" : "boolean",
            "summary" : "Enable disk buffer queue",
            "label" : "Enable disk buffer queue",
            "description" : "Enable disk buffer queue (only applicable for egress bridges).<br/>When Enabled, messages will be buffered on disk when the bridge connection is down.<br/>When disabled the messages are buffered in RAM only.",
            "deprecated" : true,
            "default" : false
          },
          "max_buffer_bytes" : {
            "type" : "byteSize",
            "summary" : "Max buffer queue size",
            "label" : "Max buffer queue size",
            "description" : "Maximum number of bytes to buffer for each buffer worker.",
            "default" : "256MB"
          }
        }
      },
      "bridge_kafka.auth_gssapi_kerberos" : {
        "type" : "object",
        "properties" : {
          "kerberos_principal" : {
            "type" : "string",
            "summary" : "Kerberos Principal",
            "label" : "Kerberos Principal",
            "description" : "SASL GSSAPI authentication Kerberos principal. For example <code>client_name@MY.KERBEROS.REALM.MYDOMAIN.COM</code>, NOTE: The realm in use has to be configured in /etc/krb5.conf in EMQX nodes."
          },
          "kerberos_keytab_file" : {
            "type" : "string",
            "summary" : "Kerberos keytab file",
            "label" : "Kerberos keytab file",
            "description" : "SASL GSSAPI authentication Kerberos keytab file path. NOTE: This file has to be placed in EMQX nodes, and the EMQX service runner user requires read permission."
          }
        },
        "required" : [
          "kerberos_keytab_file",
          "kerberos_principal"
        ]
      },
      "bridge_redis.put_single" : {
        "type" : "object",
        "properties" : {
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "The MQTT topic filter to be forwarded to Redis. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "command_template" : {
            "type" : "array",
            "summary" : "Redis Command Template",
            "label" : "Redis Command Template",
            "items" : {
              "type" : "string"
            },
            "description" : "Redis command template used to export messages. Each list element stands for a command name or its argument.<br/>For example, to push payloads in a Redis list by key `msgs`, the elements should be the following:<br/>`rpush`, `msgs`, `${payload}`."
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/bridge_redis.creation_opts_redis_single",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "server" : {
            "type" : "string",
            "summary" : "Server Host",
            "label" : "Server Host",
            "description" : "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The Redis default port 6379 is used if `[:Port]` is not specified."
          },
          "redis_type" : {
            "type" : "enum",
            "symbols" : [
              "single"
            ],
            "summary" : "Single Mode",
            "label" : "Single Mode",
            "description" : "Single mode. Must be set to 'single' when Redis server is running in single mode.",
            "default" : "single"
          },
          "pool_size" : {
            "type" : "string",
            "summary" : "Connection Pool Size",
            "label" : "Connection Pool Size",
            "description" : "Size of the connection pool towards the bridge target service.",
            "default" : 8
          },
          "password" : {
            "type" : "string",
            "summary" : "Password",
            "label" : "Password",
            "format" : "password",
            "description" : "EMQX's password in the external database."
          },
          "database" : {
            "type" : "number",
            "summary" : "Database ID",
            "label" : "Database ID",
            "description" : "Redis database ID.",
            "default" : 0
          },
          "auto_reconnect" : {
            "type" : "boolean",
            "summary" : "Deprecated. Auto Reconnect Database",
            "label" : "Deprecated. Auto Reconnect Database",
            "description" : "Deprecated. Enable automatic reconnect to the database.",
            "deprecated" : true,
            "default" : true
          },
          "ssl" : {
            "$ref" : "#/components/schemas/broker.ssl_client_opts",
            "summary" : "Enable SSL",
            "label" : "Enable SSL",
            "description" : "SSL connection settings.",
            "default" : {
              "enable" : false
            }
          }
        },
        "required" : [
          "command_template",
          "server"
        ]
      },
      "bridge_kafka.get_consumer" : {
        "type" : "object",
        "properties" : {
          "status" : {
            "type" : "enum",
            "symbols" : [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "summary" : "Bridge Status",
            "label" : "Bridge Status",
            "description" : "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason" : {
            "type" : "string",
            "summary" : "Failure reason",
            "label" : "Failure reason",
            "example" : "Connection refused",
            "description" : "This is the reason given in case a bridge is failing to connect."
          },
          "node_status" : {
            "type" : "array",
            "summary" : "Node Status",
            "label" : "Node Status",
            "items" : {
              "$ref" : "#/components/schemas/bridge.node_status"
            },
            "description" : "Node status."
          },
          "type" : {
            "type" : "enum",
            "symbols" : [
              "kafka_consumer",
              "kafka"
            ],
            "summary" : "Bridge Type",
            "label" : "Bridge Type",
            "description" : "The Bridge Type"
          },
          "name" : {
            "type" : "string",
            "summary" : "Bridge Name",
            "label" : "Bridge Name",
            "description" : "Bridge name, used as a human-readable description of the bridge."
          },
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable or Disable",
            "label" : "Enable or Disable",
            "description" : "Enable (true) or disable (false) this Kafka bridge.",
            "default" : true
          },
          "bootstrap_hosts" : {
            "type" : "string",
            "summary" : "Bootstrap Hosts",
            "label" : "Bootstrap Hosts",
            "description" : "A comma separated list of Kafka <code>host[:port]</code> endpoints to bootstrap the client. Default port number is 9092."
          },
          "connect_timeout" : {
            "type" : "duration",
            "summary" : "Connect Timeout",
            "label" : "Connect Timeout",
            "description" : "Maximum wait time for TCP connection establishment (including authentication time if enabled).",
            "default" : "5s"
          },
          "min_metadata_refresh_interval" : {
            "type" : "duration",
            "summary" : "Min Metadata Refresh Interval",
            "label" : "Min Metadata Refresh Interval",
            "description" : "Minimum time interval the client has to wait before refreshing Kafka broker and topic metadata. Setting too small value may add extra load on Kafka.",
            "default" : "3s"
          },
          "metadata_request_timeout" : {
            "type" : "duration",
            "summary" : "Metadata Request Timeout",
            "label" : "Metadata Request Timeout",
            "description" : "Maximum wait time when fetching metadata from Kafka.",
            "default" : "5s"
          },
          "authentication" : {
            "oneOf" : [
              {
                "$ref" : "#/components/schemas/bridge_kafka.auth_gssapi_kerberos"
              },
              {
                "$ref" : "#/components/schemas/bridge_kafka.auth_username_password"
              },
              {
                "type" : "enum",
                "symbols" : [
                  "none"
                ]
              }
            ],
            "summary" : "Authentication",
            "label" : "Authentication",
            "description" : "Authentication configs.",
            "default" : "none"
          },
          "socket_opts" : {
            "$ref" : "#/components/schemas/bridge_kafka.socket_opts",
            "summary" : "Socket Options",
            "label" : "Socket Options",
            "description" : "Extra socket options."
          },
          "ssl" : {
            "$ref" : "#/components/schemas/broker.ssl_client_opts",
            "summary" : "Enable SSL",
            "label" : "Enable SSL",
            "description" : "SSL connection settings.",
            "default" : {
              "enable" : false
            }
          },
          "kafka" : {
            "$ref" : "#/components/schemas/bridge_kafka.consumer_kafka_opts",
            "summary" : "Kafka Consumer",
            "label" : "Kafka Consumer",
            "description" : "Kafka consumer configs."
          },
          "topic_mapping" : {
            "type" : "array",
            "summary" : "Topic Mapping",
            "label" : "Topic Mapping",
            "items" : {
              "$ref" : "#/components/schemas/bridge_kafka.consumer_topic_mapping"
            },
            "description" : "Defines the mapping between Kafka topics and MQTT topics. Must contain at least one item."
          },
          "key_encoding_mode" : {
            "type" : "enum",
            "symbols" : [
              "none",
              "base64"
            ],
            "summary" : "Key Encoding Mode",
            "label" : "Key Encoding Mode",
            "description" : "Defines how the key from the Kafka message is encoded before being forwarded via MQTT.<br/><code>none</code> Uses the key from the Kafka message unchanged.  Note: in this case, the key must be a valid UTF-8 string.<br/><code>base64</code> Uses base-64 encoding on the received key.",
            "default" : "none"
          },
          "value_encoding_mode" : {
            "type" : "enum",
            "symbols" : [
              "none",
              "base64"
            ],
            "summary" : "Value Encoding Mode",
            "label" : "Value Encoding Mode",
            "description" : "Defines how the value from the Kafka message is encoded before being forwarded via MQTT.<br/><code>none</code> Uses the value from the Kafka message unchanged.  Note: in this case, the value must be a valid UTF-8 string.<br/><code>base64</code> Uses base-64 encoding on the received value.",
            "default" : "none"
          }
        },
        "required" : [
          "bootstrap_hosts",
          "name",
          "topic_mapping",
          "type"
        ]
      },
      "bridge_webhook.put" : {
        "type" : "object",
        "properties" : {
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/bridge_webhook.creation_opts",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "connect_timeout" : {
            "type" : "duration",
            "summary" : "Connect Timeout",
            "label" : "Connect Timeout",
            "description" : "The timeout when connecting to the HTTP server.",
            "default" : "15s"
          },
          "retry_interval" : {
            "type" : "duration",
            "label" : "retry_interval",
            "description" : "retry_interval Description",
            "deprecated" : true
          },
          "pool_type" : {
            "type" : "enum",
            "symbols" : [
              "random",
              "hash"
            ],
            "summary" : "Pool Type",
            "label" : "Pool Type",
            "description" : "The type of the pool. Can be one of `random`, `hash`.",
            "default" : "random"
          },
          "pool_size" : {
            "type" : "string",
            "summary" : "Pool Size",
            "label" : "Pool Size",
            "description" : "The pool size.",
            "default" : 8
          },
          "enable_pipelining" : {
            "type" : "string",
            "summary" : "HTTP Pipelineing",
            "label" : "HTTP Pipelineing",
            "description" : "A positive integer. Whether to send HTTP requests continuously, when set to 1, it means that after each HTTP request is sent, you need to wait for the server to return and then continue to send the next request.",
            "default" : 100
          },
          "request" : {
            "$ref" : "#/components/schemas/connector-http.request",
            "summary" : "Request",
            "label" : "Request",
            "description" : "Configure HTTP request parameters."
          },
          "ssl" : {
            "$ref" : "#/components/schemas/broker.ssl_client_opts",
            "summary" : "Enable SSL",
            "label" : "Enable SSL",
            "description" : "SSL connection settings.",
            "default" : {
              "enable" : false
            }
          },
          "url" : {
            "type" : "string",
            "summary" : "HTTP Bridge",
            "label" : "HTTP Bridge",
            "description" : "The URL of the HTTP Bridge.<br/><br/>Template with variables is allowed in the path, but variables cannot be used in the scheme, host,<br/>or port part.<br/><br/>For example, <code> http://localhost:9901/${topic} </code> is allowed, but<br/><code> http://${host}:9901/message </code> or <code> http://localhost:${port}/message </code><br/>is not allowed."
          },
          "direction" : {
            "type" : "enum",
            "symbols" : [
              "egress"
            ],
            "summary" : "Bridge Direction",
            "label" : "Bridge Direction",
            "description" : "Deprecated, The direction of this bridge, MUST be 'egress'",
            "deprecated" : true
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "The MQTT topic filter to be forwarded to the HTTP server. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.<br/><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "method" : {
            "type" : "enum",
            "symbols" : [
              "post",
              "put",
              "get",
              "delete"
            ],
            "summary" : "HTTP Method",
            "label" : "HTTP Method",
            "description" : "The method of the HTTP request. All the available methods are: post, put, get, delete.<br/><br/>Template with variables is allowed.",
            "default" : "post"
          },
          "headers" : {
            "type" : "object",
            "summary" : "HTTP Header",
            "label" : "HTTP Header",
            "description" : "The headers of the HTTP request.<br/><br/>Template with variables is allowed.",
            "default" : {
              "keep-alive" : "timeout=5",
              "content-type" : "application/json",
              "connection" : "keep-alive",
              "cache-control" : "no-cache",
              "accept" : "application/json"
            }
          },
          "body" : {
            "type" : "string",
            "summary" : "HTTP Body",
            "label" : "HTTP Body",
            "description" : "The body of the HTTP request.<br/><br/>If not provided, the body will be a JSON object of all the available fields.<br/><br/>There, 'all the available fields' means the context of a MQTT message when<br/>this webhook is triggered by receiving a MQTT message (the `local_topic` is set),<br/>or the context of the event when this webhook is triggered by a rule (i.e. this<br/>webhook is used as an action of a rule).<br/><br/>Template with variables is allowed."
          },
          "max_retries" : {
            "type" : "number",
            "summary" : "HTTP Request Max Retries",
            "minimum" : 1,
            "label" : "HTTP Request Max Retries",
            "description" : "HTTP request max retry times if failed.",
            "default" : 2
          },
          "request_timeout" : {
            "type" : "duration",
            "summary" : "HTTP Request Timeout",
            "label" : "HTTP Request Timeout",
            "description" : "HTTP request timeout.",
            "default" : "15s"
          }
        },
        "required" : [
          "url"
        ]
      },
      "bridge_kafka.consumer_kafka_opts" : {
        "type" : "object",
        "properties" : {
          "max_batch_bytes" : {
            "type" : "byteSize",
            "summary" : "Fetch Bytes",
            "label" : "Fetch Bytes",
            "description" : "Set how many bytes to pull from Kafka in each fetch request. Please note that if the configured value is smaller than the message size in Kafka, it may negatively impact the fetch performance.",
            "default" : "896KB"
          },
          "offset_reset_policy" : {
            "type" : "enum",
            "symbols" : [
              "latest",
              "earliest"
            ],
            "summary" : "Offset Reset Policy",
            "label" : "Offset Reset Policy",
            "description" : "Defines from which offset a consumer should start fetching when there is no commit history or when the commit history becomes invalid.",
            "default" : "latest"
          },
          "offset_commit_interval_seconds" : {
            "type" : "string",
            "summary" : "Offset Commit Interval",
            "label" : "Offset Commit Interval",
            "description" : "Defines the time interval between two offset commit requests sent for each consumer group.",
            "default" : 5
          }
        }
      },
      "bridge_rocketmq.put" : {
        "type" : "object",
        "properties" : {
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "template" : {
            "type" : "string",
            "summary" : "Template",
            "label" : "Template",
            "description" : "Template, the default value is empty. When this value is empty the whole message will be stored in the RocketMQ.<br><br/>            The template can be any valid string with placeholders, example:<br><br/>            - ${id}, ${username}, ${clientid}, ${timestamp}<br><br/>            - {\"id\" : ${id}, \"username\" : ${username}}",
            "default" : ""
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "The MQTT topic filter to be forwarded to RocketMQ. All MQTT `PUBLISH` messages with the topic<br/>matching the `local_topic` will be forwarded.</br><br/>NOTE: if the bridge is used as a rule action, `local_topic` should be left empty otherwise the messages will be duplicated."
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/resource_schema.creation_opts",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "servers" : {
            "type" : "string",
            "summary" : "Server Host",
            "label" : "Server Host",
            "description" : "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The RocketMQ default port 9876 is used if `[:Port]` is not specified."
          },
          "topic" : {
            "type" : "string",
            "summary" : "RocketMQ Topic",
            "label" : "RocketMQ Topic",
            "description" : "RocketMQ Topic",
            "default" : "TopicTest"
          },
          "access_key" : {
            "type" : "string",
            "summary" : "AccessKey",
            "label" : "AccessKey",
            "description" : "RocketMQ server `accessKey`.",
            "default" : ""
          },
          "secret_key" : {
            "type" : "string",
            "summary" : "SecretKey",
            "label" : "SecretKey",
            "description" : "RocketMQ server `secretKey`.",
            "default" : ""
          },
          "security_token" : {
            "type" : "string",
            "summary" : "Security Token",
            "label" : "Security Token",
            "description" : "RocketMQ Server Security Token",
            "default" : ""
          },
          "sync_timeout" : {
            "type" : "duration",
            "summary" : "Sync Timeout",
            "label" : "Sync Timeout",
            "description" : "Timeout of RocketMQ driver synchronous call.",
            "default" : "3s"
          },
          "refresh_interval" : {
            "type" : "duration",
            "summary" : "Topic Route Refresh Interval",
            "label" : "Topic Route Refresh Interval",
            "description" : "RocketMQ Topic Route Refresh Interval.",
            "default" : "3s"
          },
          "send_buffer" : {
            "type" : "byteSize",
            "summary" : "Send Buffer Size",
            "label" : "Send Buffer Size",
            "description" : "The socket send buffer size of the RocketMQ driver client.",
            "default" : "1024KB"
          },
          "pool_size" : {
            "type" : "string",
            "summary" : "Connection Pool Size",
            "label" : "Connection Pool Size",
            "description" : "Size of the connection pool towards the bridge target service.",
            "default" : 8
          },
          "auto_reconnect" : {
            "type" : "boolean",
            "summary" : "Deprecated. Auto Reconnect Database",
            "label" : "Deprecated. Auto Reconnect Database",
            "description" : "Deprecated. Enable automatic reconnect to the database.",
            "deprecated" : true,
            "default" : true
          }
        },
        "required" : [
          "servers"
        ]
      },
      "bridge_cassa.post" : {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "enum",
            "symbols" : [
              "cassandra"
            ],
            "summary" : "Bridge Type",
            "label" : "Bridge Type",
            "description" : "The Bridge Type"
          },
          "name" : {
            "type" : "string",
            "summary" : "Bridge Name",
            "label" : "Bridge Name",
            "description" : "Bridge name."
          },
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "cql" : {
            "type" : "string",
            "summary" : "CQL Template",
            "label" : "CQL Template",
            "format" : "sql",
            "description" : "CQL Template",
            "default" : "insert into mqtt_msg(topic, msgid, sender, qos, payload, arrived, retain) values (${topic}, ${id}, ${clientid}, ${qos}, ${payload}, ${timestamp}, ${flags.retain})"
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "The MQTT topic filter to be forwarded to Cassandra. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/resource_schema.creation_opts",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "servers" : {
            "type" : "string",
            "summary" : "Servers",
            "label" : "Servers",
            "description" : "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port][,Host2:Port]`.<br/><br/>The Cassandra default port 9042 is used if `[:Port]` is not specified."
          },
          "keyspace" : {
            "type" : "string",
            "summary" : "Keyspace",
            "label" : "Keyspace",
            "description" : "Keyspace name to connect to."
          },
          "pool_size" : {
            "type" : "string",
            "summary" : "Connection Pool Size",
            "label" : "Connection Pool Size",
            "description" : "Size of the connection pool towards the bridge target service.",
            "default" : 8
          },
          "username" : {
            "type" : "string",
            "summary" : "Username",
            "label" : "Username",
            "description" : "EMQX's username in the external database."
          },
          "password" : {
            "type" : "string",
            "summary" : "Password",
            "label" : "Password",
            "format" : "password",
            "description" : "EMQX's password in the external database."
          },
          "auto_reconnect" : {
            "type" : "boolean",
            "summary" : "Deprecated. Auto Reconnect Database",
            "label" : "Deprecated. Auto Reconnect Database",
            "description" : "Deprecated. Enable automatic reconnect to the database.",
            "deprecated" : true,
            "default" : true
          },
          "ssl" : {
            "$ref" : "#/components/schemas/broker.ssl_client_opts",
            "summary" : "Enable SSL",
            "label" : "Enable SSL",
            "description" : "SSL connection settings.",
            "default" : {
              "enable" : false
            }
          }
        },
        "required" : [
          "keyspace",
          "name",
          "servers",
          "type"
        ]
      },
      "bridge_tdengine.get" : {
        "type" : "object",
        "properties" : {
          "status" : {
            "type" : "enum",
            "symbols" : [
              "connected",
              "disconnected",
              "connecting",
              "inconsistent"
            ],
            "summary" : "Bridge Status",
            "label" : "Bridge Status",
            "description" : "The status of the bridge<br/><br/>- <code>connecting</code>: the initial state before any health probes were made.<br/><br/>- <code>connected</code>: when the bridge passes the health probes.<br/><br/>- <code>disconnected</code>: when the bridge can not pass health probes.<br/><br/>- <code>stopped</code>: when the bridge resource is requested to be stopped.<br/><br/>- <code>inconsistent</code>: When not all the nodes are at the same status."
          },
          "status_reason" : {
            "type" : "string",
            "summary" : "Failure reason",
            "label" : "Failure reason",
            "example" : "Connection refused",
            "description" : "This is the reason given in case a bridge is failing to connect."
          },
          "node_status" : {
            "type" : "array",
            "summary" : "Node Status",
            "label" : "Node Status",
            "items" : {
              "$ref" : "#/components/schemas/bridge.node_status"
            },
            "description" : "Node status."
          },
          "type" : {
            "type" : "enum",
            "symbols" : [
              "tdengine"
            ],
            "summary" : "Bridge Type",
            "label" : "Bridge Type",
            "description" : "The Bridge Type"
          },
          "name" : {
            "type" : "string",
            "summary" : "Bridge Name",
            "label" : "Bridge Name",
            "description" : "Bridge name."
          },
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "sql" : {
            "type" : "string",
            "summary" : "SQL Template",
            "label" : "SQL Template",
            "format" : "sql",
            "description" : "SQL Template",
            "default" : "insert into t_mqtt_msg(ts, msgid, mqtt_topic, qos, payload, arrived) values (${ts}, ${id}, ${topic}, ${qos}, ${payload}, ${timestamp})"
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "The MQTT topic filter to be forwarded to TDengine. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/resource_schema.creation_opts",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "server" : {
            "type" : "string",
            "summary" : "Server Host",
            "label" : "Server Host",
            "description" : "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The TDengine default port 6041 is used if `[:Port]` is not specified."
          },
          "database" : {
            "type" : "string",
            "summary" : "Database Name",
            "label" : "Database Name",
            "description" : "Database name."
          },
          "pool_size" : {
            "type" : "string",
            "summary" : "Connection Pool Size",
            "label" : "Connection Pool Size",
            "description" : "Size of the connection pool towards the bridge target service.",
            "default" : 8
          },
          "username" : {
            "type" : "string",
            "summary" : "Username",
            "label" : "Username",
            "description" : "EMQX's username in the external database.",
            "default" : "root"
          },
          "password" : {
            "type" : "string",
            "summary" : "Password",
            "label" : "Password",
            "format" : "password",
            "description" : "EMQX's password in the external database."
          },
          "auto_reconnect" : {
            "type" : "boolean",
            "summary" : "Deprecated. Auto Reconnect Database",
            "label" : "Deprecated. Auto Reconnect Database",
            "description" : "Deprecated. Enable automatic reconnect to the database.",
            "deprecated" : true,
            "default" : true
          }
        },
        "required" : [
          "database",
          "name",
          "password",
          "server",
          "type"
        ]
      },
      "bridge_kafka.put_producer" : {
        "type" : "object",
        "properties" : {
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable or Disable",
            "label" : "Enable or Disable",
            "description" : "Enable (true) or disable (false) this Kafka bridge.",
            "default" : true
          },
          "bootstrap_hosts" : {
            "type" : "string",
            "summary" : "Bootstrap Hosts",
            "label" : "Bootstrap Hosts",
            "description" : "A comma separated list of Kafka <code>host[:port]</code> endpoints to bootstrap the client. Default port number is 9092."
          },
          "connect_timeout" : {
            "type" : "duration",
            "summary" : "Connect Timeout",
            "label" : "Connect Timeout",
            "description" : "Maximum wait time for TCP connection establishment (including authentication time if enabled).",
            "default" : "5s"
          },
          "min_metadata_refresh_interval" : {
            "type" : "duration",
            "summary" : "Min Metadata Refresh Interval",
            "label" : "Min Metadata Refresh Interval",
            "description" : "Minimum time interval the client has to wait before refreshing Kafka broker and topic metadata. Setting too small value may add extra load on Kafka.",
            "default" : "3s"
          },
          "metadata_request_timeout" : {
            "type" : "duration",
            "summary" : "Metadata Request Timeout",
            "label" : "Metadata Request Timeout",
            "description" : "Maximum wait time when fetching metadata from Kafka.",
            "default" : "5s"
          },
          "authentication" : {
            "oneOf" : [
              {
                "$ref" : "#/components/schemas/bridge_kafka.auth_gssapi_kerberos"
              },
              {
                "$ref" : "#/components/schemas/bridge_kafka.auth_username_password"
              },
              {
                "type" : "enum",
                "symbols" : [
                  "none"
                ]
              }
            ],
            "summary" : "Authentication",
            "label" : "Authentication",
            "description" : "Authentication configs.",
            "default" : "none"
          },
          "socket_opts" : {
            "$ref" : "#/components/schemas/bridge_kafka.socket_opts",
            "summary" : "Socket Options",
            "label" : "Socket Options",
            "description" : "Extra socket options."
          },
          "ssl" : {
            "$ref" : "#/components/schemas/broker.ssl_client_opts",
            "summary" : "Enable SSL",
            "label" : "Enable SSL",
            "description" : "SSL connection settings.",
            "default" : {
              "enable" : false
            }
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Source MQTT Topic",
            "label" : "Source MQTT Topic",
            "description" : "MQTT topic or topic filter as data source (bridge input).  If rule action is used as data source, this config should be left empty, otherwise messages will be duplicated in Kafka."
          },
          "kafka" : {
            "$ref" : "#/components/schemas/bridge_kafka.producer_kafka_opts",
            "summary" : "Kafka Producer",
            "label" : "Kafka Producer",
            "description" : "Kafka producer configs."
          }
        },
        "required" : [
          "bootstrap_hosts",
          "kafka"
        ]
      },
      "connector_hstreamdb.config" : {
        "type" : "object",
        "properties" : {
          "url" : {
            "type" : "string",
            "summary" : "HStreamDB Server URL",
            "label" : "HStreamDB Server URL",
            "description" : "HStreamDB Server URL"
          },
          "stream" : {
            "type" : "string",
            "summary" : "HStreamDB Stream Name",
            "label" : "HStreamDB Stream Name",
            "description" : "HStreamDB Stream Name"
          },
          "ordering_key" : {
            "type" : "string",
            "summary" : "HStreamDB Ordering Key",
            "label" : "HStreamDB Ordering Key",
            "description" : "HStreamDB Ordering Key"
          },
          "pool_size" : {
            "type" : "string",
            "summary" : "HStreamDB Pool Size",
            "label" : "HStreamDB Pool Size",
            "description" : "HStreamDB Pool Size"
          }
        },
        "required" : [
          "pool_size",
          "stream",
          "url"
        ]
      },
      "resource_schema.creation_opts" : {
        "type" : "object",
        "properties" : {
          "worker_pool_size" : {
            "type" : "number",
            "summary" : "Buffer Pool Size",
            "minimum" : 1,
            "label" : "Buffer Pool Size",
            "description" : "The number of buffer workers. Only applicable for egress type bridges.<br/>For bridges only have ingress direction data flow, it can be set to 0 otherwise must be greater than 0.",
            "default" : 16
          },
          "health_check_interval" : {
            "type" : "duration",
            "summary" : "Health Check Interval",
            "label" : "Health Check Interval",
            "description" : "Health check interval.",
            "default" : "15s"
          },
          "start_after_created" : {
            "type" : "boolean",
            "summary" : "Start After Created",
            "label" : "Start After Created",
            "description" : "Whether start the resource right after created.",
            "default" : "true"
          },
          "start_timeout" : {
            "type" : "duration",
            "summary" : "Start Timeout",
            "label" : "Start Timeout",
            "description" : "Time interval to wait for an auto-started resource to become healthy before responding resource creation requests.",
            "default" : "5s"
          },
          "auto_restart_interval" : {
            "oneOf" : [
              {
                "type" : "duration"
              },
              {
                "type" : "enum",
                "symbols" : [
                  "infinity"
                ]
              }
            ],
            "summary" : "Auto Restart Interval",
            "label" : "Auto Restart Interval",
            "description" : "The auto restart interval after the resource is disconnected.",
            "default" : "60s"
          },
          "query_mode" : {
            "type" : "enum",
            "symbols" : [
              "sync",
              "async"
            ],
            "summary" : "Query mode",
            "label" : "Query mode",
            "description" : "Query mode. Optional 'sync/async', default 'async'.",
            "default" : "async"
          },
          "request_timeout" : {
            "oneOf" : [
              {
                "type" : "duration"
              },
              {
                "type" : "enum",
                "symbols" : [
                  "infinity"
                ]
              }
            ],
            "summary" : "Request Expiry",
            "label" : "Request Expiry",
            "description" : "Starting from the moment when the request enters the buffer, if the request remains in the buffer for the specified time or is sent but does not receive a response or acknowledgement in time, the request is considered expired.",
            "default" : "15s"
          },
          "inflight_window" : {
            "type" : "string",
            "summary" : "Inflight window",
            "label" : "Inflight window",
            "description" : "Query inflight window. When query_mode is set to async, this config has to be set to 1 if messages from the same MQTT client have to be strictly ordered.",
            "default" : 100
          },
          "enable_batch" : {
            "type" : "boolean",
            "summary" : "Enable batch",
            "label" : "Enable batch",
            "description" : "Batch mode enabled.",
            "deprecated" : true,
            "default" : true
          },
          "batch_size" : {
            "type" : "string",
            "summary" : "Max batch size",
            "label" : "Max batch size",
            "description" : "Maximum batch count. If equal to 1, there's effectively no batching.",
            "default" : 1
          },
          "batch_time" : {
            "type" : "duration",
            "summary" : "Max batch wait time",
            "label" : "Max batch wait time",
            "description" : "Maximum waiting interval when accumulating a batch at a low message rates for more efficient resource usage.",
            "default" : "0ms"
          },
          "enable_queue" : {
            "type" : "boolean",
            "summary" : "Enable disk buffer queue",
            "label" : "Enable disk buffer queue",
            "description" : "Enable disk buffer queue (only applicable for egress bridges).<br/>When Enabled, messages will be buffered on disk when the bridge connection is down.<br/>When disabled the messages are buffered in RAM only.",
            "deprecated" : true,
            "default" : false
          },
          "max_buffer_bytes" : {
            "type" : "byteSize",
            "summary" : "Max buffer queue size",
            "label" : "Max buffer queue size",
            "description" : "Maximum number of bytes to buffer for each buffer worker.",
            "default" : "256MB"
          }
        }
      },
      "bridge_timescale.post" : {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "enum",
            "symbols" : [
              "timescale"
            ],
            "summary" : "Bridge Type",
            "label" : "Bridge Type",
            "description" : "The Bridge Type"
          },
          "name" : {
            "type" : "string",
            "summary" : "Bridge Name",
            "label" : "Bridge Name",
            "description" : "Bridge name."
          },
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "sql" : {
            "type" : "string",
            "summary" : "SQL Template",
            "label" : "SQL Template",
            "format" : "sql",
            "description" : "SQL Template",
            "default" : "insert into t_mqtt_msg(msgid, topic, qos, payload, arrived) values (${id}, ${topic}, ${qos}, ${payload}, TO_TIMESTAMP((${timestamp} :: bigint)/1000))"
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "The MQTT topic filter to be forwarded to PostgreSQL. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/resource_schema.creation_opts",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "server" : {
            "type" : "string",
            "summary" : "Server Host",
            "label" : "Server Host",
            "description" : "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The PostgreSQL default port 5432 is used if `[:Port]` is not specified."
          },
          "database" : {
            "type" : "string",
            "summary" : "Database Name",
            "label" : "Database Name",
            "description" : "Database name."
          },
          "pool_size" : {
            "type" : "string",
            "summary" : "Connection Pool Size",
            "label" : "Connection Pool Size",
            "description" : "Size of the connection pool towards the bridge target service.",
            "default" : 8
          },
          "username" : {
            "type" : "string",
            "summary" : "Username",
            "label" : "Username",
            "description" : "EMQX's username in the external database."
          },
          "password" : {
            "type" : "string",
            "summary" : "Password",
            "label" : "Password",
            "format" : "password",
            "description" : "EMQX's password in the external database."
          },
          "auto_reconnect" : {
            "type" : "boolean",
            "summary" : "Deprecated. Auto Reconnect Database",
            "label" : "Deprecated. Auto Reconnect Database",
            "description" : "Deprecated. Enable automatic reconnect to the database.",
            "deprecated" : true,
            "default" : true
          },
          "ssl" : {
            "$ref" : "#/components/schemas/broker.ssl_client_opts",
            "summary" : "Enable SSL",
            "label" : "Enable SSL",
            "description" : "SSL connection settings.",
            "default" : {
              "enable" : false
            }
          }
        },
        "required" : [
          "database",
          "name",
          "server",
          "type"
        ]
      },
      "bridge_sqlserver.put" : {
        "type" : "object",
        "properties" : {
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "sql" : {
            "type" : "string",
            "summary" : "SQL Template",
            "label" : "SQL Template",
            "format" : "sql",
            "description" : "SQL Template",
            "default" : "insert into t_mqtt_msg(msgid, topic, qos, payload) values ( ${id}, ${topic}, ${qos}, ${payload} )"
          },
          "driver" : {
            "type" : "string",
            "summary" : "SQL Server Driver Name",
            "label" : "SQL Server Driver Name",
            "description" : "SQL Server Driver Name",
            "default" : "ms-sql"
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "The MQTT topic filter to be forwarded to Microsoft SQL Server. All MQTT 'PUBLISH' messages with the topic<br/>matching the local_topic will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/bridge_sqlserver.creation_opts",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "server" : {
            "type" : "string",
            "summary" : "Server Host",
            "label" : "Server Host",
            "description" : "The IPv4 or IPv6 address or the hostname to connect to.<br/><br/>A host entry has the following form: `Host[:Port]`.<br/><br/>The SQL Server default port 1433 is used if `[:Port]` is not specified."
          },
          "database" : {
            "type" : "string",
            "summary" : "Database Name",
            "label" : "Database Name",
            "description" : "Database name."
          },
          "pool_size" : {
            "type" : "string",
            "summary" : "Connection Pool Size",
            "label" : "Connection Pool Size",
            "description" : "Size of the connection pool towards the bridge target service.",
            "default" : 8
          },
          "username" : {
            "type" : "string",
            "summary" : "Username",
            "label" : "Username",
            "description" : "EMQX's username in the external database.",
            "default" : "sa"
          },
          "password" : {
            "type" : "string",
            "summary" : "Password",
            "label" : "Password",
            "format" : "password",
            "description" : "EMQX's password in the external database."
          },
          "auto_reconnect" : {
            "type" : "boolean",
            "summary" : "Deprecated. Auto Reconnect Database",
            "label" : "Deprecated. Auto Reconnect Database",
            "description" : "Deprecated. Enable automatic reconnect to the database.",
            "deprecated" : true,
            "default" : true
          }
        },
        "required" : [
          "database",
          "server"
        ]
      },
      "bridge_gcp_pubsub.post" : {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "enum",
            "symbols" : [
              "gcp_pubsub"
            ],
            "summary" : "Bridge Type",
            "label" : "Bridge Type",
            "description" : "The Bridge Type"
          },
          "name" : {
            "type" : "string",
            "summary" : "Bridge Name",
            "label" : "Bridge Name",
            "description" : "Bridge name, used as a human-readable description of the bridge."
          },
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable Or Disable Bridge",
            "label" : "Enable Or Disable Bridge",
            "description" : "Enable or disable this bridge",
            "default" : true
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/resource_schema.creation_opts",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          },
          "connect_timeout" : {
            "type" : "duration",
            "summary" : "Connect Timeout",
            "label" : "Connect Timeout",
            "description" : "The timeout when connecting to the HTTP server.",
            "default" : "15s"
          },
          "pool_size" : {
            "type" : "string",
            "summary" : "Pool Size",
            "label" : "Pool Size",
            "description" : "The pool size.",
            "default" : 8
          },
          "pipelining" : {
            "type" : "string",
            "summary" : "HTTP Pipelineing",
            "label" : "HTTP Pipelineing",
            "description" : "A positive integer. Whether to send HTTP requests continuously, when set to 1, it means that after each HTTP request is sent, you need to wait for the server to return and then continue to send the next request.",
            "default" : 100
          },
          "max_retries" : {
            "type" : "number",
            "summary" : "Max Retries",
            "minimum" : 1,
            "label" : "Max Retries",
            "description" : "Max retry times if an error occurs when sending a request.",
            "default" : 2
          },
          "request_timeout" : {
            "type" : "duration",
            "summary" : "Request Timeout",
            "label" : "Request Timeout",
            "description" : "Deprecated: Configure the request timeout in the buffer settings.",
            "deprecated" : true,
            "default" : "15s"
          },
          "payload_template" : {
            "type" : "string",
            "summary" : "Payload template",
            "label" : "Payload template",
            "description" : "The template for formatting the outgoing messages.  If undefined, will send all the available context in JSON format.",
            "default" : ""
          },
          "local_topic" : {
            "type" : "string",
            "summary" : "Local Topic",
            "label" : "Local Topic",
            "description" : "The MQTT topic filter to be forwarded to GCP PubSub. All MQTT 'PUBLISH' messages with the topic<br/>matching `local_topic` will be forwarded.</br><br/>NOTE: if this bridge is used as the action of a rule (EMQX rule engine), and also local_topic is<br/>configured, then both the data got from the rule and the MQTT messages that match local_topic<br/>will be forwarded."
          },
          "pubsub_topic" : {
            "type" : "string",
            "summary" : "GCP PubSub Topic",
            "label" : "GCP PubSub Topic",
            "description" : "The GCP PubSub topic to publish messages to."
          },
          "service_account_json" : {
            "type" : "string",
            "summary" : "GCP Service Account Credentials",
            "label" : "GCP Service Account Credentials",
            "description" : "JSON containing the GCP Service Account credentials to be used with PubSub.<br/>When a GCP Service Account is created (as described in https://developers.google.com/identity/protocols/oauth2/service-account#creatinganaccount), you have the option of downloading the credentials in JSON form.  That's the file needed."
          }
        },
        "required" : [
          "name",
          "pubsub_topic",
          "service_account_json",
          "type"
        ]
      },
      "bridge_mongodb.put_sharded" : {
        "type" : "object",
        "properties" : {
          "mongo_type" : {
            "type" : "enum",
            "symbols" : [
              "sharded"
            ],
            "summary" : "Sharded cluster",
            "label" : "Sharded cluster",
            "description" : "Sharded cluster. Must be set to 'sharded' when MongoDB server is running in 'sharded' mode.",
            "default" : "sharded"
          },
          "servers" : {
            "type" : "string",
            "summary" : "Servers",
            "label" : "Servers",
            "description" : "A Node list for Cluster to connect to. The nodes should be separated with commas, such as: `Node[,Node].`<br/>For each Node should be: The IPv4 or IPv6 address or the hostname to connect to.<br/>A host entry has the following form: `Host[:Port]`.<br/>The MongoDB default port 27017 is used if `[:Port]` is not specified."
          },
          "w_mode" : {
            "type" : "enum",
            "symbols" : [
              "unsafe",
              "safe"
            ],
            "summary" : "Write Mode",
            "label" : "Write Mode",
            "description" : "Write mode.",
            "default" : "unsafe"
          },
          "srv_record" : {
            "type" : "boolean",
            "summary" : "Srv Record",
            "label" : "Srv Record",
            "description" : "Use DNS SRV record.",
            "default" : false
          },
          "pool_size" : {
            "type" : "string",
            "summary" : "Connection Pool Size",
            "label" : "Connection Pool Size",
            "description" : "Size of the connection pool towards the bridge target service.",
            "default" : 8
          },
          "username" : {
            "type" : "string",
            "summary" : "Username",
            "label" : "Username",
            "description" : "EMQX's username in the external database."
          },
          "password" : {
            "type" : "string",
            "summary" : "Password",
            "label" : "Password",
            "format" : "password",
            "description" : "EMQX's password in the external database."
          },
          "auth_source" : {
            "type" : "string",
            "summary" : "Auth Source",
            "label" : "Auth Source",
            "description" : "Database name associated with the user's credentials."
          },
          "database" : {
            "type" : "string",
            "summary" : "Database Name",
            "label" : "Database Name",
            "description" : "Database name."
          },
          "topology" : {
            "$ref" : "#/components/schemas/emqx_connector_mongo.topology",
            "label" : "topology",
            "description" : "topology Description"
          },
          "ssl" : {
            "$ref" : "#/components/schemas/broker.ssl_client_opts",
            "summary" : "Enable SSL",
            "label" : "Enable SSL",
            "description" : "SSL connection settings.",
            "default" : {
              "enable" : false
            }
          },
          "enable" : {
            "type" : "boolean",
            "summary" : "Enable or disable",
            "label" : "Enable or disable",
            "description" : "Enable or disable this MongoDB Bridge",
            "default" : true
          },
          "collection" : {
            "type" : "string",
            "summary" : "Collection to be used",
            "label" : "Collection to be used",
            "description" : "The collection where data will be stored into",
            "default" : "mqtt"
          },
          "payload_template" : {
            "type" : "string",
            "summary" : "Payload template",
            "label" : "Payload template",
            "description" : "The template for formatting the outgoing messages.  If undefined, rule engine will use JSON format to serialize all visible inputs, such as clientid, topic, payload etc."
          },
          "resource_opts" : {
            "$ref" : "#/components/schemas/resource_schema.creation_opts",
            "summary" : "Resource Options",
            "label" : "Resource Options",
            "description" : "Resource options.",
            "default" : {
              
            }
          }
        },
        "required" : [
          "database",
          "servers"
        ]
      }
    }
  }
}