{
  "emqx_authn_api": {
    "authentication_get": {
      "desc": "列出全局认证链上的认证器。"
    },
    "authentication_id_delete": {
      "desc": "删除全局认证链上的指定认证器。"
    },
    "authentication_id_get": {
      "desc": "获取全局认证链上的指定认证器。"
    },
    "authentication_id_position_put": {
      "desc": "更改全局认证链上指定认证器的顺序。"
    },
    "authentication_id_put": {
      "desc": "更新全局认证链上的指定认证器。"
    },
    "authentication_id_status_get": {
      "desc": "获取全局认证链上指定认证器的状态。"
    },
    "authentication_id_users_get": {
      "desc": "获取全局认证链上指定认证器中的用户数据。"
    },
    "authentication_id_users_post": {
      "desc": "为全局认证链上的指定认证器创建用户数据。"
    },
    "authentication_id_users_user_id_delete": {
      "desc": "删除全局认证链上指定认证器中的指定用户数据。"
    },
    "authentication_id_users_user_id_get": {
      "desc": "获取全局认证链上指定认证器中的指定用户数据。"
    },
    "authentication_id_users_user_id_put": {
      "desc": "更新全局认证链上指定认证器中的指定用户数据。"
    },
    "authentication_post": {
      "desc": "为全局认证链创建认证器。"
    },
    "is_superuser": {
      "desc": "是否是超级用户"
    },
    "like_user_id": {
      "desc": "使用用户 ID （username 或 clientid）模糊查询。",
      "label": "like_user_id"
    },
    "listeners_listener_id_authentication_get": {
      "desc": "列出监听器认证链上的认证器。"
    },
    "listeners_listener_id_authentication_id_delete": {
      "desc": "删除监听器认证链上的指定认证器。"
    },
    "listeners_listener_id_authentication_id_get": {
      "desc": "获取监听器认证链上的指定认证器。"
    },
    "listeners_listener_id_authentication_id_position_put": {
      "desc": "更改监听器认证链上指定认证器的顺序。"
    },
    "listeners_listener_id_authentication_id_put": {
      "desc": "更新监听器认证链上的指定认证器。"
    },
    "listeners_listener_id_authentication_id_status_get": {
      "desc": "获取监听器认证链上指定认证器的状态。"
    },
    "listeners_listener_id_authentication_id_users_get": {
      "desc": "列出监听器认证链上指定认证器中的用户数据。"
    },
    "listeners_listener_id_authentication_id_users_post": {
      "desc": "为监听器认证链上的指定认证器创建用户数据。"
    },
    "listeners_listener_id_authentication_id_users_user_id_delete": {
      "desc": "删除监听器认证链上指定认证器中的指定用户数据。"
    },
    "listeners_listener_id_authentication_id_users_user_id_get": {
      "desc": "获取监听器认证链上指定认证器中的指定用户数据。"
    },
    "listeners_listener_id_authentication_id_users_user_id_put": {
      "desc": "更新监听器认证链上指定认证器中的指定用户数据。"
    },
    "listeners_listener_id_authentication_post": {
      "desc": "在监听器认证链上创建认证器。"
    },
    "param_auth_id": {
      "desc": "认证器 ID。"
    },
    "param_listener_id": {
      "desc": "监听器 ID。"
    },
    "param_position": {
      "desc": "认证者在链中的位置。可能的值是 'front', 'rear', 'before:{other_authenticator}', 'after:{other_authenticator}'"
    },
    "param_user_id": {
      "desc": "用户 ID。"
    }
  },
  "emqx_authn_http": {
    "body": {
      "desc": "HTTP request body。",
      "label": "Request Body"
    },
    "get": {
      "desc": "使用 HTTP Server 作为认证服务的认证器的配置项 (使用 GET 请求)。"
    },
    "headers": {
      "desc": "HTTP Headers 列表",
      "label": "请求头"
    },
    "headers_no_content_type": {
      "desc": "HTTP Headers 列表 (无 <code>content-type</code>) 。",
      "label": "请求头(无 content-type)"
    },
    "method": {
      "desc": "HTTP 请求方法。",
      "label": "请求方法"
    },
    "post": {
      "desc": "使用 HTTP Server 作为认证服务的认证器的配置项 (使用 POST 请求)。"
    },
    "request_timeout": {
      "desc": "HTTP 请求超时时长。",
      "label": "请求超时时间"
    },
    "url": {
      "desc": "认证 HTTP 服务器地址。",
      "label": "URL"
    }
  },
  "emqx_authn_jwt": {
    "acl_claim_name": {
      "desc": "JWT claim name to use for getting ACL rules.",
      "label": "ACL claim name"
    },
    "algorithm": {
      "desc": "JWT 签名算法，支持 HMAC (配置为 <code>hmac-based</code>）和 RSA、ECDSA (配置为 <code>public-key</code>)。",
      "label": "JWT 签名算法"
    },
    "cacertfile": {
      "desc": "包含 PEM 编码的 CA 证书的文件的路径。",
      "label": "CA 证书文件"
    },
    "certfile": {
      "desc": "包含用户证书的文件的路径。",
      "label": "证书文件"
    },
    "enable": {
      "desc": "启用/禁用 SSL。",
      "label": "启用/禁用 SSL"
    },
    "endpoint": {
      "desc": "JWKS 端点， 它是一个以 JWKS 格式返回服务端的公钥集的只读端点。",
      "label": "JWKS Endpoint"
    },
    "from": {
      "desc": "要从中获取 JWT 的字段。",
      "label": "源字段"
    },
    "hmac-based": {
      "desc": "用于认证的 JWT 使用 HMAC 算法签发时的配置。"
    },
    "jwks": {
      "desc": "用于认证的 JWTs 需要从 JWKS 端点获取时的配置。"
    },
    "keyfile": {
      "desc": "包含 PEM 编码的用户私钥的文件的路径。",
      "label": "私钥文件"
    },
    "public-key": {
      "desc": "用于认证的 JWT 使用 RSA 或 ECDSA 算法签发时的配置。"
    },
    "public_key": {
      "desc": "用于验证 JWT 的公钥。",
      "label": "公钥"
    },
    "refresh_interval": {
      "desc": "JWKS 刷新间隔。",
      "label": "JWKS 刷新间隔"
    },
    "secret": {
      "desc": "使用 HMAC 算法时用于验证 JWT 的密钥",
      "label": "Secret"
    },
    "secret_base64_encoded": {
      "desc": "密钥是否为 Base64 编码。",
      "label": "密钥是否为 Base64 编码"
    },
    "server_name_indication": {
      "desc": "服务器名称指示（SNI）。",
      "label": "服务器名称指示"
    },
    "ssl": {
      "desc": "SSL 选项。",
      "label": "SSL 选项"
    },
    "use_jwks": {
      "desc": "是否使用 JWKS。",
      "label": "是否使用 JWKS"
    },
    "verify": {
      "desc": "指定握手过程中是否校验对端证书。",
      "label": "Verify"
    },
    "verify_claims": {
      "desc": "需要验证的自定义声明列表，它是一个名称/值对列表。\n值可以使用以下占位符：\n- <code>${username}</code>: 将在运行时被替换为客户端连接时使用的用户名\n- <code>${clientid}</code>: 将在运行时被替换为客户端连接时使用的客户端标识符\n认证时将验证 JWT（取自 Password 字段）中 claims 的值是否与 <code>verify_claims</code> 中要求的相匹配。",
      "label": "Verify Claims"
    }
  },
  "emqx_authn_mnesia": {
    "authentication": {
      "desc": "使用内置数据库作为认证数据源的认证器的配置项。"
    },
    "user_id_type": {
      "desc": "指定使用客户端ID `clientid` 还是用户名 `username` 进行认证。",
      "label": "认证 ID 类型"
    }
  },
  "emqx_authn_mongodb": {
    "collection": {
      "desc": "存储认证数据的集合。",
      "label": "集合"
    },
    "filter": {
      "desc": "在查询中定义过滤条件的条件表达式。\n过滤器支持如下占位符：\n- <code>${username}</code>: 将在运行时被替换为客户端连接时使用的用户名\n- <code>${clientid}</code>: 将在运行时被替换为客户端连接时使用的客户端标识符",
      "label": "过滤器"
    },
    "is_superuser_field": {
      "desc": "文档中用于定义用户是否具有超级用户权限的字段。",
      "label": "超级用户字段"
    },
    "password_hash_field": {
      "desc": "文档中用于存放密码散列的字段。",
      "label": "密码散列字段"
    },
    "replica-set": {
      "desc": "使用 MongoDB (Replica Set) 作为认证数据源的认证器的配置项。"
    },
    "salt_field": {
      "desc": "文档中用于存放盐值的字段。",
      "label": "盐值字段"
    },
    "sharded-cluster": {
      "desc": "使用 MongoDB (Sharded Cluster) 作为认证数据源的认证器的配置项。"
    },
    "standalone": {
      "desc": "使用 MongoDB (Standalone) 作为认证数据源的认证器的配置项。"
    }
  },
  "emqx_authn_mysql": {
    "authentication": {
      "desc": "使用 MySQL 作为认证数据源的认证器的配置项。"
    },
    "query": {
      "desc": "用于查询密码散列等用于认证的数据的 SQL 语句。",
      "label": "查询语句"
    },
    "query_timeout": {
      "desc": "SQL 查询的超时时间。",
      "label": "查询超时"
    }
  },
  "emqx_authn_pgsql": {
    "authentication": {
      "desc": "使用 PostgreSQL 作为认证数据源的认证器的配置项。"
    },
    "query": {
      "desc": "用于查询密码散列等用于认证的数据的 SQL 语句。",
      "label": "查询语句"
    }
  },
  "emqx_authn_redis": {
    "cluster": {
      "desc": "使用 Redis (Cluster) 作为认证数据源的认证器的配置项。"
    },
    "cmd": {
      "desc": "用于查询密码散列等用于认证的数据的 Redis Command，目前仅支持 <code>HGET</code> 与 <code>HMGET</code>。",
      "label": "Command"
    },
    "sentinel": {
      "desc": "使用 Redis (Sentinel) 作为认证数据源的认证器的配置项。"
    },
    "standalone": {
      "desc": "使用 Redis (Standalone) 作为认证数据源的认证器的配置项。"
    }
  },
  "emqx_authn_schema": {
    "backend": {
      "desc": "后端类型。",
      "label": "后端类型"
    },
    "enable": {
      "desc": "设为 <code>true</code> 或 <code>false</code> 以启用或禁用此认证数据源。",
      "label": "启用"
    },
    "failed": {
      "desc": "请求失败次数。",
      "label": "失败"
    },
    "matched": {
      "desc": "请求命中次数。",
      "label": "已命中"
    },
    "mechanism": {
      "desc": "认证机制。",
      "label": "认证机制"
    },
    "metrics": {
      "desc": "资源统计指标。",
      "label": "指标"
    },
    "metrics_failed": {
      "desc": "在当前实例中找到需要的认证信息，并且实例返回认证失败的次数。",
      "label": "实例认证失败的次数"
    },
    "metrics_nomatch": {
      "desc": "在当前实例中没有找到需要的认证信息，实例被忽略的次数。",
      "label": "实例被忽略的次数"
    },
    "metrics_rate": {
      "desc": "实例被触发的速率。触发速率等于匹配速率 + 忽略速率，单位：次/秒。",
      "label": "实例被触发的速率"
    },
    "metrics_rate_last5m": {
      "desc": "实例5分钟内平均触发速率，单位：次/秒。",
      "label": "实例5分钟内平均触发速率"
    },
    "metrics_rate_max": {
      "desc": "实例曾经达到的最高触发速率，单位：次/秒。",
      "label": "实例曾经达到的最高触发速率"
    },
    "metrics_success": {
      "desc": "在当前实例中找到需要的认证信息，并且实例返回认证成功的次数。",
      "label": "实例认证成功的次数"
    },
    "metrics_total": {
      "desc": "当前实例被触发的总次数。",
      "label": "当前实例被触发的总次数"
    },
    "node": {
      "desc": "节点名称。",
      "label": "节点名称。"
    },
    "node_error": {
      "desc": "节点上产生的错误。",
      "label": "节点产生的错误"
    },
    "node_metrics": {
      "desc": "每个节点上资源的统计指标。",
      "label": "节点资源指标"
    },
    "node_status": {
      "desc": "每个节点上资源的状态。",
      "label": "节点资源状态"
    },
    "rate": {
      "desc": "命中速率，单位：次/秒。",
      "label": "速率"
    },
    "rate_last5m": {
      "desc": "5分钟内平均命中速率，单位：次/秒。",
      "label": "5分钟内速率"
    },
    "rate_max": {
      "desc": "最大命中速率，单位：次/秒。",
      "label": "最大速率"
    },
    "status": {
      "desc": "资源状态。",
      "label": "状态"
    },
    "success": {
      "desc": "请求成功次数。",
      "label": "成功"
    }
  },
  "emqx_authn_user_import_api": {
    "authentication_id_import_users_post": {
      "desc": "为全局认证链上的指定认证器导入用户数据。"
    },
    "listeners_listener_id_authentication_id_import_users_post": {
      "desc": "为监听器认证链上的指定认证器导入用户数据。"
    }
  },
  "emqx_authz_api_cache": {
    "authorization_cache_delete": {
      "desc": "清除集群中所有授权数据缓存。"
    }
  },
  "emqx_authz_api_mnesia": {
    "action": {
      "desc": "被授权的行为 (发布/订阅/所有)",
      "label": "行为"
    },
    "clientid": {
      "desc": "客户端标识符",
      "label": "客户端标识符"
    },
    "fuzzy_clientid": {
      "desc": "使用字串匹配模糊搜索客户端标识符",
      "label": "客户端标识符子串"
    },
    "fuzzy_username": {
      "desc": "使用字串匹配模糊搜索用户名",
      "label": "用户名子串"
    },
    "permission": {
      "desc": "权限",
      "label": "权限"
    },
    "rules_all_delete": {
      "desc": "删除 `all` 规则"
    },
    "rules_all_get": {
      "desc": "列出为所有客户端启用的规则列表"
    },
    "rules_all_post": {
      "desc": "创建/更新 为所有客户端启用的规则列表。"
    },
    "rules_delete": {
      "desc": "清除内置数据库中的所有类型（'users' 、'clients' 、'all'）的所有规则"
    },
    "topic": {
      "desc": "在指定主题上的规则",
      "label": "主题"
    },
    "user_clientid_delete": {
      "desc": "删除内置数据库中指定客户端标识符类型的规则记录"
    },
    "user_clientid_get": {
      "desc": "获取内置数据库中指定客户端标识符类型的规则记录"
    },
    "user_clientid_put": {
      "desc": "更新内置数据库中指定客户端标识符类型的规则记录"
    },
    "user_username_delete": {
      "desc": "删除内置数据库中指定用户名类型的规则记录"
    },
    "user_username_get": {
      "desc": "获取内置数据库中指定用户名类型的规则记录"
    },
    "user_username_put": {
      "desc": "更新内置数据库中指定用户名类型的规则记录"
    },
    "username": {
      "desc": "用户名",
      "label": "用户名"
    },
    "users_clientid_get": {
      "desc": "获取内置数据库中所有客户端标识符类型的规则记录"
    },
    "users_clientid_post": {
      "desc": "添加内置数据库中客户端标识符类型的规则记录"
    },
    "users_username_get": {
      "desc": "获取内置数据库中所有用户名类型的规则记录"
    },
    "users_username_post": {
      "desc": "添加内置数据库中用户名类型的规则记录"
    }
  },
  "emqx_authz_api_schema": {
    "body": {
      "desc": "HTTP 请求体。",
      "label": "请求体"
    },
    "cmd": {
      "desc": "访问控制数据查询命令。",
      "label": "查询命令"
    },
    "collection": {
      "desc": "`MongoDB` 授权数据集。",
      "label": "数据集"
    },
    "enable": {
      "desc": "设为 <code>true</code> 或 <code>false</code> 以启用或禁用此访问控制数据源。",
      "label": "enable"
    },
    "filter": {
      "desc": "在查询中定义过滤条件的条件表达式。\n过滤器支持如下占位符：\n- <code>${username}</code>: 将在运行时被替换为客户端连接时使用的用户名\n- <code>${clientid}</code>: 将在运行时被替换为客户端连接时使用的客户端标识符",
      "label": "过滤器"
    },
    "headers": {
      "desc": "HTTP Headers 列表",
      "label": "请求头"
    },
    "headers_no_content_type": {
      "desc": "HTTP Headers 列表（无 <code>content-type</code>）。",
      "label": "请求头(无 content-type)"
    },
    "method": {
      "desc": "HTTP 请求方法。",
      "label": "method"
    },
    "position": {
      "desc": "认证数据源位置。",
      "label": "位置"
    },
    "query": {
      "desc": "访问控制数据查询语句。",
      "label": "查询语句"
    },
    "request_timeout": {
      "desc": "请求超时时间。",
      "label": "请求超时"
    },
    "rules": {
      "desc": "静态授权文件规则。",
      "label": "规则"
    },
    "type": {
      "desc": "数据后端类型。",
      "label": "type"
    },
    "url": {
      "desc": "认证服务器 URL。",
      "label": "url"
    }
  },
  "emqx_authz_api_settings": {
    "authorization_settings_get": {
      "desc": "获取授权配置"
    },
    "authorization_settings_put": {
      "desc": "更新授权配置"
    }
  },
  "emqx_authz_api_sources": {
    "authorization_sources_get": {
      "desc": "列出所有授权数据源"
    },
    "authorization_sources_post": {
      "desc": "添加授权数据源"
    },
    "authorization_sources_type_delete": {
      "desc": "删除指定类型的授权数据源"
    },
    "authorization_sources_type_get": {
      "desc": "获取指定类型的授权数据源"
    },
    "authorization_sources_type_move_post": {
      "desc": "更新授权数据源的优先执行顺序"
    },
    "authorization_sources_type_put": {
      "desc": "更新指定类型的授权数据源"
    },
    "authorization_sources_type_status_get": {
      "desc": "获取指定授权数据源的状态"
    },
    "source": {
      "desc": "授权数据源",
      "label": "数据源"
    },
    "source_config": {
      "desc": "数据源配置",
      "label": "数据源配置"
    },
    "source_type": {
      "desc": "数据源类型",
      "label": "数据源类型"
    },
    "sources": {
      "desc": "授权数据源列表",
      "label": "数据源列表"
    }
  },
  "emqx_authz_schema": {
    "deny": {
      "desc": "授权失败的次数。",
      "label": "授权失败次数"
    },
    "redis_sentinel": {
      "desc": "使用 Redis 授权（哨兵模式）。",
      "label": "redis_sentinel"
    },
    "rate": {
      "desc": "命中速率，单位：次/秒。",
      "label": "速率"
    },
    "status": {
      "desc": "资源状态。",
      "label": "状态"
    },
    "method": {
      "desc": "HTTP 请求方法",
      "label": "method"
    },
    "query": {
      "desc": "访问控制数据查询语句/查询命令。",
      "label": "查询语句"
    },
    "metrics_total": {
      "desc": "授权实例被触发的总次数。",
      "label": "授权实例被触发的总次数"
    },
    "redis_cluster": {
      "desc": "使用 Redis 授权（集群模式）。",
      "label": "redis_cluster"
    },
    "mysql": {
      "desc": "使用 MySOL 数据库授权",
      "label": "mysql"
    },
    "postgresql": {
      "desc": "使用 PostgreSQL 数据库授权",
      "label": "postgresql"
    },
    "mongo_rs": {
      "desc": "使用 MongoDB 授权（副本集模式）",
      "label": "mongo_rs"
    },
    "type": {
      "desc": "数据后端类型",
      "label": "type"
    },
    "mongo_sharded": {
      "desc": "使用 MongoDB 授权（分片集群模式）。",
      "label": "mongo_sharded"
    },
    "body": {
      "desc": "HTTP request body。",
      "label": "Request Body"
    },
    "url": {
      "desc": "授权 HTTP 服务器地址。",
      "label": "URL"
    },
    "node": {
      "desc": "节点名称。",
      "label": "节点名称。"
    },
    "headers": {
      "desc": "HTTP Headers 列表",
      "label": "请求头"
    },
    "rate_last5m": {
      "desc": "5分钟内平均命中速率，单位：次/秒。",
      "label": "5分钟内速率"
    },
    "headers_no_content_type": {
      "desc": "HTTP Headers 列表 (无 <code>content-type</code>) 。",
      "label": "请求头(无 content-type)"
    },
    "node_error": {
      "desc": "节点上产生的错误。",
      "label": "节点产生的错误"
    },
    "mnesia": {
      "desc": "使用内部数据库授权（mnesia）。",
      "label": "mnesia"
    },
    "enable": {
      "desc": "设为 <code>true</code> 或 <code>false</code> 以启用或禁用此访问控制数据源",
      "label": "enable"
    },
    "matched": {
      "desc": "请求命中次数。",
      "label": "已命中"
    },
    "node_status": {
      "desc": "每个节点上资源的状态。",
      "label": "节点资源状态"
    },
    "rate_max": {
      "desc": "最大命中速率，单位：次/秒。",
      "label": "最大速率"
    },
    "filter": {
      "desc": "在查询中定义过滤条件的条件表达式。\n过滤器支持如下占位符：<br/>\n- <code>${username}</code>：将在运行时被替换为客户端连接时使用的用户名<br/>\n- <code>${clientid}</code>：将在运行时被替换为客户端连接时使用的客户端标识符",
      "label": "过滤器"
    },
    "path": {
      "desc": "包含 ACL 规则的文件路径。\n如果在启动 EMQX 节点前预先配置该路径，\n那么可以将该文件置于任何 EMQX 可以访问到的位置。\n\n如果从 EMQX Dashboard 或 HTTP API 创建或修改了规则集，\n那么EMQX将会生成一个新的文件并将它存放在 `data_dir` 下的 `authz` 子目录中，\n并从此弃用旧的文件。",
      "label": "path"
    },
    "redis_single": {
      "desc": "使用 Redis 授权（单实例）。",
      "label": "redis_single"
    },
    "failed": {
      "desc": "请求失败次数。",
      "label": "失败"
    },
    "metrics": {
      "desc": "资源统计指标。",
      "label": "指标"
    },
    "authorization": {
      "desc": "客户端授权相关配置",
      "label": "授权"
    },
    "collection": {
      "desc": "`MongoDB` 授权数据集。",
      "label": "数据集"
    },
    "mongo_single": {
      "desc": "使用 MongoDB 授权（单实例）。",
      "label": "mongo_single"
    },
    "file": {
      "desc": "使用静态文件授权",
      "label": "文件"
    },
    "http_post": {
      "desc": "使用外部 HTTP 服务器授权(POST 请求)。",
      "label": "http_post"
    },
    "request_timeout": {
      "desc": "HTTP 请求超时时长。",
      "label": "请求超时时间"
    },
    "allow": {
      "desc": "授权成功的次数。",
      "label": "授权成功次数"
    },
    "cmd": {
      "desc": "访问控制数据查查询命令",
      "label": "查询命令"
    },
    "nomatch": {
      "desc": "没有匹配到任何授权规则的次数。",
      "label": "没有匹配到任何授权规则的次数"
    },
    "sources": {
      "desc": "授权数据源。<br/>\n授权（ACL）数据源的列表。\n它被设计为一个数组，而不是一个散列映射，\n所以可以作为链式访问控制。<br/>\n\n当授权一个 'publish' 或 'subscribe' 行为时，\n该配置列表中的所有数据源将按顺序进行检查。\n如果在某个客户端未找到时(使用 ClientID 或 Username)。\n将会移动到下一个数据源。直至得到 'allow' 或 'deny' 的结果。<br/>\n\n如果在任何数据源中都未找到对应的客户端信息。\n配置的默认行为 ('authorization.no_match') 将生效。<br/>\n\n注意：\n数据源使用 'type' 进行标识。\n使用同一类型的数据源多于一次不被允许。",
      "label": "数据源"
    },
    "node_metrics": {
      "desc": "每个节点上资源的统计指标。",
      "label": "节点资源指标"
    },
    "success": {
      "desc": "请求成功次数。",
      "label": "成功"
    },
    "http_get": {
      "desc": "使用外部 HTTP 服务器授权(GET 请求)。",
      "label": "http_get"
    }
  },
  "emqx_auto_subscribe_api": {
    "list_auto_subscribe_api": {
      "desc": "获取自动订阅主题列表"
    },
    "update_auto_subscribe_api": {
      "desc": "更新自动订阅主题列表"
    },
    "update_auto_subscribe_api_response409": {
      "desc": "超出自定订阅主题列表长度限制"
    }
  },
  "emqx_auto_subscribe_schema": {
    "auto_subscribe": {
      "desc": "设备登录成功之后，通过预设的订阅表示符，为设备自动完成订阅。支持使用占位符。",
      "label": "自动订阅"
    },
    "nl": {
      "desc": "缺省值为0，\nMQTT v3.1.1：如果设备订阅了自己发布消息的主题，那么将收到自己发布的所有消息。\nMQTT v5：如果设备在订阅时将此选项设置为 1，那么服务端将不会向设备转发自己发布的消息",
      "label": "No Local"
    },
    "qos": {
      "desc": "缺省值为 0，服务质量，\nQoS 0：消息最多传递一次，如果当时客户端不可用，则会丢失该消息。\nQoS 1：消息传递至少 1 次。\nQoS 2：消息仅传送一次。",
      "label": "服务质量"
    },
    "rap": {
      "desc": "缺省值为 0，这一选项用来指定服务端向客户端转发消息时是否要保留其中的 RETAIN 标识，注意这一选项不会影响保留消息中的 RETAIN 标识。因此当 Retain As Publish 选项被设置为 0 时，客户端直接依靠消息中的 RETAIN 标识来区分这是一个正常的转发消息还是一个保留消息，而不是去判断消息是否是自己订阅后收到的第一个消息（转发消息甚至可能会先于保留消息被发送，视不同 Broker 的具体实现而定）。",
      "label": "Retain As Publish"
    },
    "rh": {
      "desc": "指定订阅建立时服务端是否向客户端发送保留消息，\n可选值 0：只要客户端订阅成功，服务端就发送保留消息。\n可选值 1：客户端订阅成功且该订阅此前不存在，服务端才发送保留消息。毕竟有些时候客户端重新发起订阅可能只是为了改变一下 QoS，并不意味着它想再次接收保留消息。\n可选值 2：即便客户订阅成功，服务端也不会发送保留消息。",
      "label": "Retain Handling"
    },
    "topic": {
      "desc": "订阅标识符，支持使用占位符，例如 client/${clientid}/username/${username}/host/${host}/port/${port}\n必填，且不可为空字符串",
      "label": "订阅标识符"
    }
  },
  "emqx_bridge_api": {
    "desc_api1": {
      "desc": "列出所有 Birdge",
      "label": "列出所有 Bridge"
    },
    "desc_api2": {
      "desc": "通过类型和名字创建 Bridge",
      "label": "创建 Bridge"
    },
    "desc_api3": {
      "desc": "通过 ID 获取 Bridge",
      "label": "获取 Bridge"
    },
    "desc_api4": {
      "desc": "通过 ID 更新 Bridge",
      "label": "更新 Bridge"
    },
    "desc_api5": {
      "desc": "通过 ID 删除 Bridge",
      "label": "删除 Bridge"
    },
    "desc_api6": {
      "desc": "通过 ID 重置 Bridge 的计数",
      "label": "重置 Bridge 计数"
    },
    "desc_api7": {
      "desc": "停止或启用所有节点上的桥接",
      "label": "集群 Bridge 操作"
    },
    "desc_api8": {
      "desc": "在某个节点上停止/重新启动 Bridge。",
      "label": "单节点 Bridge 操作"
    },
    "desc_api9": {
      "desc": "通过给定的 ID 测试创建一个新的桥接。 </br>\nID 的格式必须为 ’{type}:{name}”",
      "label": "测试桥接创建"
    },
    "desc_bridge_metrics": {
      "desc": "通过 Id 来获取桥接的指标信息",
      "label": "获取桥接的指标"
    },
    "desc_enable_bridge": {
      "desc": "启用或禁用所有节点上的桥接",
      "label": "是否启用集群内的桥接"
    },
    "desc_param_path_enable": {
      "desc": "是否启用桥接",
      "label": "启用桥接"
    },
    "desc_param_path_id": {
      "desc": "Bridge ID ， 格式为 {type}:{name}",
      "label": "Bridge ID"
    },
    "desc_param_path_node": {
      "desc": "节点名，比如 emqx@127.0.0.1",
      "label": "节点名"
    },
    "desc_param_path_operation_cluster": {
      "desc": "集群可用操作：停止、重新启动",
      "label": "集群可用操作"
    },
    "desc_param_path_operation_on_node": {
      "desc": "节点可用操作：停止、重新启动",
      "label": "节点可用操作"
    }
  },
  "emqx_bridge_mqtt_schema": {
    "config": {
      "desc": "MQTT Bridge 的配置。",
      "label": "配置"
    },
    "desc_name": {
      "desc": "Bridge 名字，Bridge 的可读描述",
      "label": "Bridge 名字"
    },
    "desc_type": {
      "desc": "Bridge 的类型",
      "label": "Bridge 类型"
    }
  },
  "emqx_bridge_schema": {
    "bridges_mqtt": {
      "desc": "桥接到另一个 MQTT Broker 的 MQTT Bridge",
      "label": "MQTT Bridge"
    },
    "bridges_webhook": {
      "desc": "转发消息到 HTTP 服务器的 WebHook",
      "label": "WebHook"
    },
    "desc_bridges": {
      "desc": "MQTT Bridge 配置",
      "label": "MQTT Bridge 配置"
    },
    "desc_enable": {
      "desc": "启用/禁用 Bridge",
      "label": "启用/禁用 Bridge"
    },
    "desc_metrics": {
      "desc": "Bridge 计数",
      "label": "Bridge 计数"
    },
    "desc_node_metrics": {
      "desc": "节点的计数器",
      "label": "节点的计数器"
    },
    "desc_node_name": {
      "desc": "节点的名字",
      "label": "节点名字"
    },
    "desc_node_status": {
      "desc": "节点的状态",
      "label": "节点的状态"
    },
    "desc_status": {
      "desc": "Bridge 的连接状态<br/>\n- <code>connecting</code>: 启动时的初始状态。<br/>\n- <code>connected</code>: 桥接驱动健康检查正常。<br/>\n- <code>disconnected</code>: 当桥接无法通过健康检查。<br/>\n- <code>stopped</code>: 桥接处于停用状态。<br/>\n- <code>inconsistent</code>: 集群中有各节点汇报的状态不一致。",
      "label": "Bridge 状态"
    },
    "desc_status_reason": {
      "desc": "桥接连接失败的原因。",
      "label": "失败原因"
    },
    "metric_dropped": {
      "desc": "被丢弃的消息个数。",
      "label": "丢弃"
    },
    "metric_dropped_other": {
      "desc": "因为其他原因被丢弃的消息个数。",
      "label": "其他丢弃"
    },
    "metric_dropped_queue_full": {
      "desc": "因为队列已满被丢弃的消息个数。",
      "label": "队列已满被丢弃"
    },
    "metric_dropped_resource_not_found": {
      "desc": "因为资源不存在被丢弃的消息个数。",
      "label": "资源不存在被丢弃"
    },
    "metric_dropped_resource_stopped": {
      "desc": "因为资源已停用被丢弃的消息个数。",
      "label": "资源停用被丢弃"
    },
    "metric_inflight": {
      "desc": "已异步地发送但没有收到 ACK 的消息个数。",
      "label": "已发送未确认"
    },
    "metric_matched": {
      "desc": "Bridge 被匹配到（被请求）的次数。",
      "label": "匹配次数"
    },
    "metric_queuing": {
      "desc": "当前被缓存到磁盘队列的消息个数。",
      "label": "被缓存"
    },
    "metric_rate": {
      "desc": "执行操作的速率，次/秒",
      "label": "速率"
    },
    "metric_rate_last5m": {
      "desc": "5 分钟平均速率，次/秒",
      "label": "5 分钟平均速率"
    },
    "metric_rate_max": {
      "desc": "执行操作的最大速率，次/秒",
      "label": "执行操作的最大速率"
    },
    "metric_received": {
      "desc": "从远程系统收到的消息个数。",
      "label": "已接收"
    },
    "metric_retried": {
      "desc": "重试的次数。",
      "label": "已重试"
    },
    "metric_sent_failed": {
      "desc": "发送失败的消息个数。",
      "label": "发送失败"
    },
    "metric_sent_success": {
      "desc": "已经发送成功的消息个数。",
      "label": "发送成功"
    }
  },
  "emqx_bridge_webhook_schema": {
    "config_body": {
      "desc": "HTTP 请求的正文。<br/>\n如果没有设置该字段，请求正文将是包含所有可用字段的 JSON object。<br/>\n如果该 webhook 是由于收到 MQTT 消息触发的，'所有可用字段' 将是 MQTT 消息的\n上下文信息；如果该 webhook 是由于规则触发的，'所有可用字段' 则为触发事件的上下文信息。<br/>\n允许使用带有变量的模板。",
      "label": "HTTP 请求正文"
    },
    "config_direction": {
      "desc": "已废弃，Bridge 的方向，必须是 egress",
      "label": "Bridge 方向"
    },
    "config_enable": {
      "desc": "启用/禁用 Bridge",
      "label": "启用/禁用 Bridge"
    },
    "config_headers": {
      "desc": "HTTP 请求的标头。<br/>\n允许使用带有变量的模板。",
      "label": "HTTP 请求标头"
    },
    "config_local_topic": {
      "desc": "发送到 'local_topic' 的消息都会转发到 HTTP 服务器。 <br/>\n注意：如果这个 Bridge 被用作规则（EMQX 规则引擎）的输出，同时也配置了 'local_topic' ，那么这两部分的消息都会被转发到 HTTP 服务器。",
      "label": "本地 Topic"
    },
    "config_max_retries": {
      "desc": "HTTP 请求失败最大重试次数",
      "label": "HTTP 请求重试次数"
    },
    "config_method": {
      "desc": "HTTP 请求的方法。 所有可用的方法包括：post、put、get、delete。<br/>\n允许使用带有变量的模板。",
      "label": "HTTP 请求方法"
    },
    "config_request_timeout": {
      "desc": "HTTP 请求超时",
      "label": "HTTP 请求超时"
    },
    "config_url": {
      "desc": "HTTP Bridge 的 URL。<br/>\n路径中允许使用带变量的模板，但是 host， port 不允许使用变量模板。<br/>\n例如，<code> http://localhost:9901/${topic} </code> 是允许的，\n但是<code> http://${host}:9901/message </code>\n或 <code> http://localhost:${port}/message </code>\n不允许。",
      "label": "HTTP Bridge"
    },
    "desc_config": {
      "desc": "HTTP Bridge 配置",
      "label": "HTTP Bridge 配置"
    },
    "desc_name": {
      "desc": "Bridge 名字，Bridge 的可读描述",
      "label": "Bridge 名字"
    },
    "desc_type": {
      "desc": "Bridge 类型",
      "label": "Bridge 类型"
    }
  },
  "emqx_coap_api": {
    "content_type": {
      "desc": "Payload 类型"
    },
    "message_id": {
      "desc": "消息 ID"
    },
    "method": {
      "desc": "请求 Method 类型"
    },
    "payload": {
      "desc": "Payload 内容"
    },
    "response_code": {
      "desc": "应答码"
    },
    "send_coap_request": {
      "desc": "发送 CoAP 消息到指定客户端"
    },
    "timeout": {
      "desc": "请求超时时间"
    },
    "token": {
      "desc": "消息 Token, 可以为空"
    }
  },
  "emqx_coap_schema": {
    "coap": {
      "desc": "CoAP 网关配置。\n该网关的实现基于 RFC-7252 和 https://core-wg.github.io/coap-pubsub/draft-ietf-core-pubsub.html"
    },
    "coap_connection_required": {
      "desc": "是否开启连接模式。\n连接模式是非标准协议的功能。它维护 CoAP 客户端上线、认证、和连接状态的保持"
    },
    "coap_heartbeat": {
      "desc": "CoAP 网关要求客户端的最小心跳间隔时间。\n当 <code>connection_required</code> 开启后，该参数用于检查客户端连接是否存活"
    },
    "coap_notify_type": {
      "desc": "投递给 CoAP 客户端的通知消息类型。当客户端 Observe 一个资源（或订阅某个主题）时，网关会向客户端推送新产生的消息。其消息类型可设置为：<br/>\n  - non: 不需要客户端返回确认消息;<br/>\n  - con: 需要客户端返回一个确认消息;<br/>\n  - qos: 取决于消息的 QoS 等级; QoS 0 会以 `non` 类型下发，QoS 1/2 会以 `con` 类型下发"
    },
    "coap_publish_qos": {
      "desc": "客户端发布请求的默认 QoS 等级。\n当 CoAP 客户端发起发布请求时，如果未携带 `qos` 参数则会使用该默认值。默认值可设置为：<br>\n  - qos0、qos1、qos2: 设置为固定的 QoS 等级<br/>\n  - coap: 依据发布操作的 CoAP 报文类型来动态决定<br/>\n    * 当发布请求为 `non-confirmable` 类型时，取值为 qos0<br/>\n    * 当发布请求为 `confirmable` 类型时，取值为 qos1"
    },
    "coap_subscribe_qos": {
      "desc": "客户端订阅请求的默认 QoS 等级。\n当 CoAP 客户端发起订阅请求时，如果未携带 `qos` 参数则会使用该默认值。默认值可设置为：<br/>\n  - qos0、 qos1、qos2: 设置为固定的 QoS 等级<br/>\n  - coap: 依据订阅操作的 CoAP 报文类型来动态决定<br/>\n    * 当订阅请求为 `non-confirmable` 类型时，取值为 qos0<br/>\n    * 当订阅请求为 `confirmable` 类型时，取值为 qos1"
    }
  },
  "emqx_conf_schema": {
    "common_handler_drop_mode_qlen": {
      "desc": "当缓冲的日志事件数大于此值时，新的日志事件将被丢弃。起到过载保护的功能。\n为了使过载保护算法正常工作必须要：<code> sync_mode_qlen =< drop_mode_qlen =< flush_qlen </code> 且 drop_mode_qlen > 1\n要禁用某些模式，请执行以下操作。\n- 如果sync_mode_qlen被设置为0，所有的日志事件都被同步处理。也就是说，异步日志被禁用。\n- 如果sync_mode_qlen被设置为与drop_mode_qlen相同的值，同步模式被禁用。也就是说，处理程序总是以异步模式运行，除非调用drop或flushing。\n- 如果drop_mode_qlen被设置为与flush_qlen相同的值，则drop模式被禁用，永远不会发生。",
      "label": "进入丢弃模式的队列长度"
    },
    "cluster_mcast_addr": {
      "desc": "指定多播 IPv4 地址。\n当 cluster.discovery_strategy 为 mcast 时，此配置项才有效。",
      "label": "多播地址"
    },
    "desc_cluster_dns": {
      "desc": "DNS SRV 记录服务发现。",
      "label": "DNS SRV 记录服务发现"
    },
    "cluster_dns_name": {
      "desc": "指定 DNS A 记录的名字。emqx 会通过访问这个 DNS A 记录来获取 IP 地址列表。\n当<code>cluster.discovery_strategy</code> 为 <code>dns</code> 时有效。",
      "label": "DNS名称"
    },
    "rpc_keyfile": {
      "desc": "<code>rpc.certfile</code> 的私钥文件的路径。<br/>\n注意：此文件内容是私钥，所以需要设置权限为 600。",
      "label": "RPC 私钥文件"
    },
    "cluster_mcast_recbuf": {
      "desc": "接收数据报的内核级缓冲区的大小。\n当 cluster.discovery_strategy 为 mcast 时，此配置项才有效。",
      "label": "多播接收数据缓冲区"
    },
    "cluster_autoheal": {
      "desc": "集群脑裂自动恢复机制开关。",
      "label": "节点脑裂自动修复机制"
    },
    "log_overload_kill_enable": {
      "desc": "日志处理进程过载时为保护自己节点其它的业务能正常，强制杀死日志处理进程。",
      "label": "日志处理进程过载保护"
    },
    "node_etc_dir": {
      "desc": "<code>etc</code> 存放目录",
      "label": "Etc 目录"
    },
    "cluster_proto_dist": {
      "desc": "分布式 Erlang 集群协议类型。可选值为:<br/>\n- inet_tcp: 使用 IPv4 <br/>\n- inet_tls: 使用 TLS，需要配合 <code>etc/ssl_dist.conf</code> 一起使用。",
      "label": "集群内部通信协议"
    },
    "log_burst_limit_enable": {
      "desc": "启用日志限流保护机制。",
      "label": "日志限流保护"
    },
    "dist_buffer_size": {
      "desc": "Erlang分布式缓冲区的繁忙阈值，单位是KB。",
      "label": "Erlang分布式缓冲区的繁忙阈值(KB)"
    },
    "common_handler_max_depth": {
      "desc": "Erlang 内部格式日志格式化和 Erlang 进程消息队列检查的最大深度。",
      "label": "最大深度"
    },
    "desc_log": {
      "desc": "EMQX 日志记录支持日志事件的多个接收器。 每个接收器由一个_log handler_表示，可以独立配置。",
      "label": "日志"
    },
    "common_handler_flush_qlen": {
      "desc": "如果缓冲日志事件的数量增长大于此阈值，则会发生冲刷（删除）操作。 日志处理进程会丢弃缓冲的日志消息。\n来缓解自身不会由于内存瀑涨而影响其它业务进程。日志内容会提醒有多少事件被删除。",
      "label": "冲刷阈值"
    },
    "common_handler_chars_limit": {
      "desc": "设置单个日志消息的最大长度。 如果超过此长度，则日志消息将被截断。最小可设置的长度为100。\n注意：如果日志格式为 JSON，限制字符长度可能会导致截断不完整的 JSON 数据。",
      "label": "单条日志长度限制"
    },
    "cluster_k8s_namespace": {
      "desc": "当使用 k8s 方式并且 cluster.k8s.address_type 指定为 dns 类型时，\n可设置 emqx 节点名的命名空间。与 cluster.k8s.suffix 一起使用用以拼接得到节点名列表。",
      "label": "K8s 命名空间"
    },
    "node_name": {
      "desc": "节点名。格式为 \\<name>@\\<host>。其中 <host> 可以是 IP 地址，也可以是 FQDN。\n详见 http://erlang.org/doc/reference_manual/distributed.html。",
      "label": "节点名"
    },
    "rpc_port_discovery": {
      "desc": "<code>manual</code>: 通过 <code>tcp_server_port</code> 来发现端口。\n<br/><code>stateless</code>: 使用无状态的方式来发现端口，使用如下算法。如果节点名称是 <code>\nemqxN@127.0.0.1</code>, N 是一个数字，那么监听端口就是 5370 + N。",
      "label": "RPC 端口发现策略"
    },
    "log_overload_kill_restart_after": {
      "desc": "如果处理进程终止，它会在以指定的时间后后自动重新启动。 `infinity` 不自动重启。",
      "label": "处理进程重启机制"
    },
    "log_file_handler_max_size": {
      "desc": "此参数控制日志文件轮换。 `infinity` 意味着日志文件将无限增长，否则日志文件将在达到 `max_size`（以字节为单位）时进行轮换。\n与 rotation count配合使用。如果 counter 为 10，则是10个文件轮换。",
      "label": "日志文件轮换大小"
    },
    "desc_log_file_handler": {
      "desc": "日志处理进程将日志事件打印到文件。",
      "label": "文件日志处理进程"
    },
    "rpc_socket_keepalive_count": {
      "desc": "keepalive 探测消息发送失败的次数，直到 RPC 连接被认为已经断开。",
      "label": "RPC Socket Keepalive 次数"
    },
    "cluster_etcd_server": {
      "desc": "指定 etcd 服务的地址。如有多个服务使用逗号 , 分隔。\n当 cluster.discovery_strategy 为 etcd 时，此配置项才有效。",
      "label": "Etcd 服务器地址"
    },
    "db_backend": {
      "desc": "配置后端数据库驱动，默认值为 <code>rlog</code> 它适用于大规模的集群。\n<code>mnesia</code> 是备选数据库，适合中小集群。",
      "label": "内置数据库"
    },
    "desc_authorization": {
      "desc": "授权相关",
      "label": "授权"
    },
    "cluster_etcd_ssl": {
      "desc": "当使用 TLS 连接 etcd 时的配置选项。\n当 cluster.discovery_strategy 为 etcd 时，此配置项才有效。",
      "label": "Etcd SSL 选项"
    },
    "rpc_insecure_fallback": {
      "desc": "兼容旧的无鉴权模式",
      "label": "向后兼容旧的无鉴权模式"
    },
    "cluster_mcast_buffer": {
      "desc": "用户级缓冲区的大小。\n当 cluster.discovery_strategy 为 mcast 时，此配置项才有效。",
      "label": "多播用户级缓冲区"
    },
    "rpc_authentication_timeout": {
      "desc": "远程节点认证的超时时间。",
      "label": "RPC 认证超时时间"
    },
    "cluster_call_retry_interval": {
      "desc": "当集群间调用出错时，多长时间重试一次。",
      "label": "重试时间间隔"
    },
    "cluster_mcast_sndbuf": {
      "desc": "外发数据报的内核级缓冲区的大小。\n当 cluster.discovery_strategy 为 mcast 时，此配置项才有效。",
      "label": "多播发送缓存区"
    },
    "rpc_driver": {
      "desc": "集群间通信使用的传输协议。",
      "label": "RPC 驱动"
    },
    "max_ets_tables": {
      "desc": "Erlang ETS 表的最大数量",
      "label": "Erlang 表的最大数量"
    },
    "desc_db": {
      "desc": "内置数据库的配置。",
      "label": "数据库"
    },
    "desc_cluster_etcd": {
      "desc": "使用 'etcd' 服务的服务发现。",
      "label": "'etcd' 服务的服务发现"
    },
    "cluster_name": {
      "desc": "EMQX集群名称。每个集群都有一个唯一的名称。服务发现时会用于做路径的一部分。",
      "label": "集群名称"
    },
    "log_rotation_enable": {
      "desc": "启用日志轮换功能。启动后生成日志文件后缀会加上对应的索引数字，比如：log/emqx.log.1。\n系统会默认生成<code>*.siz/*.idx</code>用于记录日志位置，请不要手动修改这两个文件。",
      "label": "日志轮换"
    },
    "cluster_call_cleanup_interval": {
      "desc": "清理过期事务的时间间隔",
      "label": "清理间隔"
    },
    "desc_cluster_static": {
      "desc": "静态节点服务发现。新节点通过连接一个节点来加入集群。",
      "label": "静态节点服务发现"
    },
    "db_default_shard_transport": {
      "desc": "定义用于推送事务日志的默认传输。<br/>\n这可以在 <code>db.shard_transports</code> 中基于每个分片被覆盖。\n<code>gen_rpc</code> 使用 <code>gen_rpc</code> 库，\n<code>distr</code> 使用 Erlang 发行版。",
      "label": "事务日志传输默认协议"
    },
    "cluster_static_seeds": {
      "desc": "集群中的EMQX节点名称列表，\n指定固定的节点列表，多个节点间使用逗号 , 分隔。\n当 cluster.discovery_strategy 为 static 时，此配置项才有效。\n适合于节点数量较少且固定的集群。",
      "label": "集群静态节点"
    },
    "log_overload_kill_qlen": {
      "desc": "允许的最大队列长度。",
      "label": "最大队列长度"
    },
    "node_backtrace_depth": {
      "desc": "错误信息中打印的最大堆栈层数",
      "label": "最大堆栈导数"
    },
    "desc_log_burst_limit": {
      "desc": "短时间内产生的大量日志事件可能会导致问题，例如：\n  - 日志文件变得非常大\n  - 日志文件轮换过快，有用信息被覆盖\n  - 对系统的整体性能影响\n\n日志突发限制功能可以暂时禁用日志记录以避免这些问题。",
      "label": "日志突发限制"
    },
    "common_handler_enable": {
      "desc": "启用此日志处理进程。",
      "label": "启用日志处理进程"
    },
    "cluster_k8s_service_name": {
      "desc": "指定 Kubernetes 中 EMQX 的服务名。\n当 cluster.discovery_strategy 为 k8s 时，此配置项才有效。",
      "label": "K8s 服务别名"
    },
    "log_rotation_count": {
      "desc": "轮换的最大日志文件数。",
      "label": "最大日志文件数"
    },
    "node_cookie": {
      "desc": "分布式 Erlang 集群使用的 cookie 值。集群间保持一致",
      "label": "节点 Cookie"
    },
    "db_role": {
      "desc": "选择节点的角色。<br/>\n<code>core</code> 节点提供数据的持久性，并负责写入。建议将核心节点放置在不同的机架或不同的可用区。<br/>\n<code>repliant</code> 节点是临时工作节点。 从集群中删除它们，不影响数据库冗余<br/>\n建议复制节点多于核心节点。<br/>\n注意：该参数仅在设置<code>backend</code>时生效到 <code>rlog</code>。",
      "label": "数据库角色"
    },
    "rpc_tcp_server_port": {
      "desc": "RPC 本地服务使用的 TCP 端口。<br/>\n只有当 rpc.port_discovery 设置为 manual 时，此配置才会生效。",
      "label": "RPC TCP 服务监听端口"
    },
    "desc_console_handler": {
      "desc": "日志处理进程将日志事件打印到 EMQX 控制台。",
      "label": "Console Handler"
    },
    "node_applications": {
      "desc": "当新EMQX 加入集群时，应重启的Erlang应用程序的列表。",
      "label": "应用"
    },
    "log_burst_limit_max_count": {
      "desc": "在 `window_time` 间隔内处理的最大日志事件数。 达到限制后，将丢弃连续事件，直到 `window_time` 结束。",
      "label": "日志事件数"
    },
    "rpc_tcp_client_num": {
      "desc": "设置本节点与远程节点之间的 RPC 通信通道的最大数量。",
      "label": "RPC TCP 客户端数量"
    },
    "cluster_k8s_address_type": {
      "desc": "当使用 k8s 方式集群时，address_type 用来从 Kubernetes 接口的应答里获取什么形式的 Host 列表。\n指定 <code>cluster.k8s.address_type</code> 为 <code>ip</code>，则将从 Kubernetes 接口中获取集群中其他节点\n的IP地址。",
      "label": "K8s 地址类型"
    },
    "rpc_socket_sndbuf": {
      "desc": "TCP 调节参数。TCP 发送缓冲区大小。",
      "label": "RPC 套接字发送缓冲区大小"
    },
    "cluster_mcast_ttl": {
      "desc": "指定多播的 Time-To-Live 值。\n当 cluster.discovery_strategy 为 mcast 时，此配置项才有效。",
      "label": "多播TTL"
    },
    "db_core_nodes": {
      "desc": "当前节点连接的核心节点列表。<br/>\n注意：该参数仅在设置<code>backend</code>时生效到 <code>rlog</code>\n并且设置<code>role</code>为<code>replicant</code>时生效。<br/>\n该值需要在手动或静态集群发现机制下设置。<br/>\n如果使用了自动集群发现机制（如<code>etcd</code>），则不需要设置该值。",
      "label": "数据库核心节点"
    },
    "log_file_handler_file": {
      "desc": "日志文件路径及名字。",
      "label": "日志文件名字"
    },
    "node_dist_net_ticktime": {
      "desc": "系统调优参数，此配置将覆盖 vm.args 文件里的 -kernel net_ticktime 参数。当一个节点持续无响应多久之后，认为其已经宕机并断开连接。",
      "label": "节点间心跳间隔"
    },
    "desc_cluster_k8s": {
      "desc": "Kubernetes 服务发现。",
      "label": "Kubernetes 服务发现"
    },
    "desc_cluster_mcast": {
      "desc": "UDP 组播服务发现。",
      "label": "UDP 组播服务发现"
    },
    "rpc_cacertfile": {
      "desc": "验证 <code>rpc.certfile</code> 的 CA 证书文件的路径。<br/>\n注意：集群中所有节点的证书必须使用同一个 CA 签发。",
      "label": "RPC CA 证书文件"
    },
    "desc_node": {
      "desc": "节点名称、Cookie、配置文件、数据目录和 Erlang 虚拟机（BEAM）启动参数。",
      "label": "节点"
    },
    "cluster_k8s_apiserver": {
      "desc": "指定 Kubernetes API Server。如有多个 Server 使用逗号 , 分隔。\n当 cluster.discovery_strategy 为 k8s 时，此配置项才有效。",
      "label": "K8s 服务地址"
    },
    "common_handler_supervisor_reports": {
      "desc": "Supervisor 报告的类型。默认为 error 类型。<br/>\n  - <code>error</code>：仅记录 Erlang 进程中的错误。\n  - <code>progress</code>：除了 error 信息外，还需要记录进程启动的详细信息。",
      "label": "报告类型"
    },
    "node_data_dir": {
      "desc": "节点数据存放目录，可能会自动创建的子目录如下：<br/>\n- `mnesia/<node_name>`。EMQX的内置数据库目录。例如，`mnesia/emqx@127.0.0.1`。<br/>\n如果节点要被重新命名（例如，`emqx@10.0.1.1`）。旧目录应该首先被删除。<br/>\n- `configs`。在启动时生成的配置，以及集群/本地覆盖的配置。<br/>\n- `patches`: 热补丁文件将被放在这里。<br/>\n- `trace`: 日志跟踪文件。<br/>\n\n**注意**: 一个数据dir不能被两个或更多的EMQX节点同时使用。",
      "label": "节点数据目录"
    },
    "cluster_k8s_suffix": {
      "desc": "当使用 k8s 方式并且 cluster.k8s.address_type 指定为 dns 类型时，可设置 emqx 节点名的后缀。\n与 cluster.k8s.namespace 一起使用用以拼接得到节点名列表。",
      "label": "K8s 前缀"
    },
    "db_rpc_module": {
      "desc": "集群间推送事务日志到复制节点使用的协议。",
      "label": "RPC协议"
    },
    "cluster_etcd_prefix": {
      "desc": "指定 etcd 路径的前缀。每个节点在 etcd 中都会创建一个路径:\nv2/keys/<prefix>/<cluster.name>/<node.name> <br/>\n当 cluster.discovery_strategy 为 etcd 时，此配置项才有效。",
      "label": "Etcd 路径前缀"
    },
    "cluster_mcast_iface": {
      "desc": "指定节点发现服务需要绑定到本地 IP 地址。\n当 cluster.discovery_strategy 为 mcast 时，此配置项才有效。",
      "label": "多播绑定地址"
    },
    "log_burst_limit_window_time": {
      "desc": "参考 <code>max_count</code>。",
      "label": "Window Time"
    },
    "cluster_dns_record_type": {
      "desc": "DNS 记录类型。",
      "label": "DNS记录类型"
    },
    "cluster_autoclean": {
      "desc": "指定多久之后从集群中删除离线节点。",
      "label": "自动删除离线节点时间"
    },
    "process_limit": {
      "desc": "Erlang系统同时存在的最大进程数。\n实际选择的最大值可能比设置的数字大得多。\n参考: https://www.erlang.org/doc/man/erl.html",
      "label": "Erlang 最大进程数"
    },
    "max_ports": {
      "desc": "Erlang系统同时存在的最大端口数。\n实际选择的最大值可能比设置的数字大得多。\n参考: https://www.erlang.org/doc/man/erl.html",
      "label": "Erlang 最大端口数"
    },
    "desc_log_rotation": {
      "desc": "默认情况下，日志存储在 `./log` 目录（用于从 zip 文件安装）或 `/var/log/emqx`（用于二进制安装）。<br/>\n这部分配置，控制每个日志处理进程保留的文件数量。",
      "label": "日志轮换"
    },
    "desc_log_overload_kill": {
      "desc": "日志过载终止，具有过载保护功能。当日志处理进程使用过多内存，或者缓存的日志消息过多时该功能被激活。<br/>\n检测到过载时，日志处理进程将终止，并在冷却期后重新启动。",
      "label": "日志过载保护"
    },
    "authorization": {
      "desc": "授权（ACL）。EMQX 支持完整的客户端访问控制（ACL）。",
      "label": "授权"
    },
    "rpc_socket_keepalive_idle": {
      "desc": "broker 之间的连接在最后一条消息发送后保持打开的时间。",
      "label": "RPC Socket Keepalive Idle"
    },
    "desc_cluster_call": {
      "desc": "集群调用功能的选项。",
      "label": "集群调用"
    },
    "cluster_mcast_ports": {
      "desc": "指定多播端口。如有多个端口使用逗号 , 分隔。\n当 cluster.discovery_strategy 为 mcast 时，此配置项才有效。",
      "label": "多播端口"
    },
    "log_overload_kill_mem_size": {
      "desc": "日志处理进程允许使用的最大内存。",
      "label": "日志处理进程允许使用的最大内存"
    },
    "rpc_connect_timeout": {
      "desc": "建立 RPC 连接的超时时间。",
      "label": "RPC 连接超时时间"
    },
    "cluster_etcd_node_ttl": {
      "desc": "指定 etcd 中节点信息的过期时间。\n当 cluster.discovery_strategy 为 etcd 时，此配置项才有效。",
      "label": "Etcd 节点过期时间"
    },
    "rpc_call_receive_timeout": {
      "desc": "同步 RPC 的回复超时时间。",
      "label": "RPC 调用接收超时时间"
    },
    "rpc_socket_recbuf": {
      "desc": "TCP 调节参数。TCP 接收缓冲区大小。",
      "label": "RPC 套接字接收缓冲区大小"
    },
    "db_tlog_push_mode": {
      "desc": "同步模式下，核心节点等待复制节点的确认信息，然后再发送下一条事务日志。",
      "label": "Tlog推送模式"
    },
    "node_crash_dump_bytes": {
      "desc": "限制崩溃文件的大小，当崩溃时节点内存太大，\n如果为了保存现场，需要全部存到崩溃文件中，此处限制最多能保存多大的文件。\n如果超过此限制，崩溃转储将被截断。如果设置为0，系统不会尝试写入崩溃转储文件。",
      "label": "崩溃文件最大容量"
    },
    "rpc_certfile": {
      "desc": "TLS 证书文件的路径，用于验证集群节点的身份。\n只有当 <code>rpc.driver</code> 设置为 <code>ssl</code> 时，此配置才会生效。",
      "label": "RPC 证书文件"
    },
    "node_crash_dump_seconds": {
      "desc": "该配置给出了运行时系统允许花费的写入崩溃转储的秒数。当给定的秒数已经过去，运行时系统将被终止。<br/>\n- 如果设置为0秒，运行时会立即终止，不会尝试写入崩溃转储文件。<br/>\n- 如果设置为一个正数 S，节点会等待 S 秒来完成崩溃转储文件，然后用SIGALRM信号终止运行时系统。<br/>\n- 如果设置为一个负值导致运行时系统的终止等待无限期地直到崩溃转储文件已经完全写入。",
      "label": "保存崩溃文件最长时间"
    },
    "log_file_handlers": {
      "desc": "输出到文件的日志处理进程列表",
      "label": "File Handler"
    },
    "node_global_gc_interval": {
      "desc": "系统调优参数，设置节点运行多久强制进行一次全局垃圾回收。禁用设置为 <code>disabled</code>。",
      "label": "全局垃圾回收"
    },
    "common_handler_time_offset": {
      "desc": "日志中的时间戳使用的时间偏移量。\n可选值为：\n  - <code>system</code>: 本地系统使用的时区偏移量\n  - <code>utc</code>: 0 时区的偏移量\n  - <code>+-[hh]:[mm]</code>: 自定义偏移量，比如 \"-02:00\" 或者 \"+00:00\"\n默认值为本地系统的时区偏移量：<code>system</code>。",
      "label": "时间偏移量"
    },
    "rpc_mode": {
      "desc": "在 <code>sync</code> 模式下，发送端等待接收端的 ack信号。",
      "label": "RPC 模式"
    },
    "node_crash_dump_file": {
      "desc": "设置 Erlang crash_dump 文件的存储路径和文件名。",
      "label": "节点崩溃时的Dump文件"
    },
    "cluster_mcast_loop": {
      "desc": "设置多播的报文是否投递到本地回环地址。\n当 cluster.discovery_strategy 为 mcast 时，此配置项才有效。",
      "label": "多播回环开关"
    },
    "rpc_socket_keepalive_interval": {
      "desc": "keepalive 消息的间隔。",
      "label": "RPC Socket Keepalive 间隔"
    },
    "common_handler_level": {
      "desc": "当前日志处理进程的日志级别。\n默认为 warning 级别。",
      "label": "日志级别"
    },
    "desc_rpc": {
      "desc": "EMQX 使用 <code>gen_rpc</code> 库来实现跨节点通信。<br/>\n大多数情况下，默认的配置应该可以工作，但如果你需要做一些性能优化或者实验，可以尝试调整这些参数。",
      "label": "RPC"
    },
    "rpc_ssl_server_port": {
      "desc": "RPC 本地服务使用的监听SSL端口。<br/>\n只有当 rpc.port_discovery 设置为 manual 且 <code> dirver </code> 设置为 <code>ssl</code>，\n此配置才会生效。",
      "label": "RPC SSL 服务监听端口"
    },
    "desc_cluster": {
      "desc": "EMQX 节点可以组成一个集群，以提高总容量。<br/> 这里指定了节点之间如何连接。",
      "label": "集群"
    },
    "common_handler_sync_mode_qlen": {
      "desc": "只要缓冲的日志事件的数量低于这个值，所有的日志事件都会被异步处理。\n这意味着，日志落地速度不会影响正常的业务进程，因为它们不需要等待日志处理进程的响应。\n如果消息队列的增长超过了这个值，处理程序开始同步处理日志事件。也就是说，发送事件的客户进程必须等待响应。\n当处理程序将消息队列减少到低于sync_mode_qlen阈值的水平时，异步操作就会恢复。\n默认为100条信息，当等待的日志事件大于100条时，就开始同步处理日志。",
      "label": "进入异步模式的队列长度"
    },
    "common_handler_formatter": {
      "desc": "选择日志格式类型。 <code>text</code> 用于纯文本，<code>json</code> 用于结构化日志记录。",
      "label": "日志格式类型"
    },
    "rpc_async_batch_size": {
      "desc": "异步模式下，发送的批量消息的最大数量。",
      "label": "异步模式下的批量消息数量"
    },
    "cluster_call_max_history": {
      "desc": "集群间调用最多保留的历史记录数。只用于排错时查看。",
      "label": "最大历史记录"
    },
    "cluster_discovery_strategy": {
      "desc": "集群节点发现方式。可选值为:\n- manual: 使用 <code>emqx ctl cluster</code> 命令管理集群。<br/>\n- static: 配置静态节点。配置几个固定的节点，新节点通过连接固定节点中的某一个来加入集群。<br/>\n- dns: 使用 DNS A 记录的方式发现节点。<br/>\n- etcd: 使用 etcd 发现节点。<br/>\n- k8s: 使用 Kubernetes API 发现节点。",
      "label": "集群服务发现策略"
    },
    "rpc_send_timeout": {
      "desc": "发送 RPC 请求的超时时间。",
      "label": "RPC 发送超时时间"
    },
    "common_handler_single_line": {
      "desc": "如果设置为 true，则单行打印日志。 否则，日志消息可能跨越多行。",
      "label": "单行模式"
    },
    "rpc_socket_buffer": {
      "desc": "TCP 调节参数。用户模式套接字缓冲区大小。",
      "label": "RPC 套接字缓冲区大小"
    },
    "db_shard_transports": {
      "desc": "允许为每个 shard 下的事务日志复制操作的传输方法进行调优。<br/>\n<code>gen_rpc</code> 使用 <code>gen_rpc</code> 库，\n<code>distr</code> 使用 Erlang 自带的 rpc 库。<br/>如果未指定，\n默认是使用 <code>db.default_shard_transport</code> 中设置的值。",
      "label": "事务日志传输协议"
    }
  },
  "emqx_connector_api": {
    "conn_get": {
      "desc": "列出所有连接器",
      "label": "列出所有连接器"
    },
    "conn_id_delete": {
      "desc": "通过 ID 删除一个连接器",
      "label": "删除连接器"
    },
    "conn_id_get": {
      "desc": "通过 ID 获取连接器",
      "label": "获取连接器"
    },
    "conn_id_put": {
      "desc": "通过 ID 更新一个连接器",
      "label": "更新连接器"
    },
    "conn_post": {
      "desc": "创建一个新的连接器",
      "label": "创建连接器"
    },
    "conn_test_post": {
      "desc": "通过给定的 ID 测试创建一个新的连接器 <br/>\nID 的格式必须为“{type}:{name}”",
      "label": "创建测试连接器"
    },
    "id": {
      "desc": "连接器 ID， 格式必须为 {type}:{name}",
      "label": "连接器 ID"
    }
  },
  "emqx_connector_http": {
    "base_url": {
      "desc": "base URL 只包含host和port。<br/>\n发送HTTP请求时，真实的URL是由base URL 和 path parameter连接而成。<br/>\n示例：`http://localhost:9901/`",
      "label": "Base Url"
    },
    "body": {
      "desc": "HTTP请求报文主体。",
      "label": "HTTP请求报文主体"
    },
    "connect_timeout": {
      "desc": "连接HTTP服务器的超时时间。",
      "label": "连接超时"
    },
    "enable_pipelining": {
      "desc": "正整数，设置最大可发送的异步 HTTP 请求数量。当设置为 1 时，表示每次发送完成 HTTP 请求后都需要等待服务器返回，再继续发送下一个请求。",
      "label": "HTTP 管道"
    },
    "headers": {
      "desc": "HTTP 头字段列表。",
      "label": "HTTP 头字段列表"
    },
    "max_retries": {
      "desc": "请求出错时的最大重试次数。",
      "label": "最大重试次数"
    },
    "method": {
      "desc": "HTTP 请求方法。",
      "label": "HTTP 请求方法"
    },
    "path": {
      "desc": "HTTP请求路径。",
      "label": "HTTP请求路径"
    },
    "pool_size": {
      "desc": "连接池大小。",
      "label": "连接池大小"
    },
    "pool_type": {
      "desc": "连接池的类型，可用类型有`random`, `hash`。",
      "label": "连接池类型"
    },
    "request": {
      "desc": "设置 HTTP 请求的参数。",
      "label": "HTTP 请求"
    },
    "request_timeout": {
      "desc": "HTTP 请求超时。",
      "label": "HTTP 请求超时"
    }
  },
  "emqx_connector_ldap": {
    "bind_dn": {
      "desc": "LDAP 绑定的 DN 的值",
      "label": "Bind DN"
    },
    "port": {
      "desc": "LDAP 端口",
      "label": "端口"
    },
    "timeout": {
      "desc": "LDAP 查询超时时间",
      "label": "超时时间"
    }
  },
  "emqx_connector_mongo": {
    "auth_source": {
      "desc": "与用户证书关联的数据库名称。",
      "label": "认证源"
    },
    "connect_timeout": {
      "desc": "超时重连的等待时间。",
      "label": "连接超时"
    },
    "desc_rs": {
      "desc": "配置 Replica Set",
      "label": "配置 Replica Set"
    },
    "desc_sharded": {
      "desc": "配置 Sharded Cluster",
      "label": "配置 Sharded Cluster"
    },
    "desc_single": {
      "desc": "配置 Single 模式",
      "label": "配置 Single 模式"
    },
    "desc_topology": {
      "desc": "配置 Topology",
      "label": "配置 Topology"
    },
    "heartbeat_period": {
      "desc": "控制驱动程序何时检查MongoDB部署的状态。指定检查的间隔时间，从上一次检查结束到下一次检查开始计算。如果连接数增加（例如，如果你增加池子的大小，就会发生这种情况），你可能也需要增加这个周期，以避免在MongoDB日志文件中创建太多的日志条目。",
      "label": "心跳期"
    },
    "local_threshold": {
      "desc": "在多个合适的MongoDB实例中进行选择的延迟窗口的大小。",
      "label": "本地阈值"
    },
    "max_overflow": {
      "desc": "最大溢出。",
      "label": "最大溢出"
    },
    "min_heartbeat_period": {
      "desc": "心跳间的最小间隙",
      "label": "最小心跳周期"
    },
    "overflow_check_period": {
      "desc": "检查是否有超过配置的工人的周期（\"溢出\"）。",
      "label": "溢出检查周期"
    },
    "overflow_ttl": {
      "desc": "当池内工人太多时，等待多久清除多余工人。",
      "label": "溢出TTL"
    },
    "r_mode": {
      "desc": "读模式。",
      "label": "读模式"
    },
    "replica_set_name": {
      "desc": "副本集的名称。",
      "label": "副本集名称"
    },
    "rs_mongo_type": {
      "desc": "Replica set模式。当 MongoDB 服务运行在 replica-set 模式下，该配置必须设置为 'rs'。",
      "label": "Replica set 模式"
    },
    "server": {
      "desc": "将要连接的 IPv4 或 IPv6 地址，或者主机名。<br/>\n主机名具有以下形式：`Host[:Port]`。<br/>\n如果未指定 `[:Port]`，则使用 MongoDB 默认端口 27017。",
      "label": "服务器地址"
    },
    "server_selection_timeout": {
      "desc": "指定在抛出异常之前为服务器选择阻断多长时间。",
      "label": "服务器选择超时"
    },
    "servers": {
      "desc": "集群将要连接的节点列表。 节点之间用逗号分隔，如：`Node[,Node].`\n每个节点的配置为：将要连接的 IPv4 或 IPv6 地址或主机名。\n主机名具有以下形式：`Host[:Port]`。\n如果未指定 `[:Port]`，则使用 MongoDB 默认端口 27017。",
      "label": "服务器列表"
    },
    "sharded_mongo_type": {
      "desc": "Sharded cluster模式。当 MongoDB 服务运行在 sharded 模式下，该配置必须设置为 'sharded'。",
      "label": "Sharded cluster 模式"
    },
    "single_mongo_type": {
      "desc": "Standalone 模式。当 MongoDB 服务运行在 standalone 模式下，该配置必须设置为 'single'。",
      "label": "Standalone 模式"
    },
    "socket_timeout": {
      "desc": "在尝试超时之前，在套接字上尝试发送或接收的持续时间。",
      "label": "套接字操作超时"
    },
    "srv_record": {
      "desc": "使用 DNS SRV 记录。",
      "label": "SRV 记录"
    },
    "w_mode": {
      "desc": "写模式。",
      "label": "写模式"
    },
    "wait_queue_timeout": {
      "desc": "工作者等待连接可用的最长时间。",
      "label": "等待队列超时"
    }
  },
  "emqx_connector_mqtt": {
    "name": {
      "desc": "连接器名称，人类可读的连接器描述。",
      "label": "连接器名称"
    },
    "num_of_bridges": {
      "desc": "当前使用此连接器的网桥数量。",
      "label": "网桥数量"
    },
    "type": {
      "desc": "连接器类型。",
      "label": "连接器类型"
    }
  },
  "emqx_connector_mqtt_schema": {
    "bridge_mode": {
      "desc": "是否启用 Bridge Mode。\n注意：此设置只针对 MQTT 协议版本 < 5.0 有效，并且需要远程 MQTT Broker 支持 Bridge Mode。\n如果设置为 true ，桥接会告诉远端服务器当前连接是一个桥接而不是一个普通的客户端。\n这意味着消息回环检测会更加高效，并且远端服务器收到的保留消息的标志位会透传给本地。",
      "label": "Bridge 模式"
    },
    "clean_start": {
      "desc": "与 ingress MQTT 桥的远程服务器重连时是否清除老的 MQTT 会话。",
      "label": "清除会话"
    },
    "clientid_prefix": {
      "desc": "可选的前缀，用于在出口网桥使用的clientid前加上前缀。",
      "label": "客户ID前缀"
    },
    "egress_desc": {
      "desc": "出口配置定义了该桥接如何将消息从本地 Broker 转发到远程 Broker。\n以下字段中允许使用带有变量的模板：'remote.topic', 'local.qos', 'local.retain', 'local.payload'。<br/>\n注意：如果此桥接被用作规则的动作，并且配置了 'local.topic'，则从规则输出的数据以及匹配到 'local.topic' 的 MQTT 消息都会被转发。",
      "label": "出方向配置"
    },
    "egress_local": {
      "desc": "如何从本地 Broker 接收消息相关的配置。",
      "label": "本地配置"
    },
    "egress_local_topic": {
      "desc": "要转发到远程broker的本地主题",
      "label": "本地主题"
    },
    "egress_remote": {
      "desc": "发送消息到远程 Broker 相关的配置。",
      "label": "远程配置"
    },
    "egress_remote_qos": {
      "desc": "待发送 MQTT 消息的 QoS。<br/>\n允许使用带有变量的模板。",
      "label": "远程 QoS"
    },
    "egress_remote_topic": {
      "desc": "转发到远程broker的哪个topic。<br/>\n允许使用带有变量的模板。",
      "label": "远程主题"
    },
    "ingress_desc": {
      "desc": "入口配置定义了该桥接如何从远程 MQTT Broker 接收消息，然后将消息发送到本地 Broker。<br/>\n        以下字段中允许使用带有变量的模板：'remote.qos', 'local.topic', 'local.qos', 'local.retain', 'local.payload'。<br/>\n        注意：如果此桥接被用作规则的输入，并且配置了 'local.topic'，则从远程代理获取的消息将同时被发送到 'local.topic' 和规则。",
      "label": "入方向配置"
    },
    "ingress_local": {
      "desc": "发送消息到本地 Broker 相关的配置。",
      "label": "本地配置"
    },
    "ingress_local_qos": {
      "desc": "待发送 MQTT 消息的 QoS。<br/>\n允许使用带有变量的模板。",
      "label": "本地 QoS"
    },
    "ingress_local_topic": {
      "desc": "向本地broker的哪个topic发送消息。<br/>\n允许使用带有变量的模板。",
      "label": "本地主题"
    },
    "ingress_remote": {
      "desc": "订阅远程 Broker 相关的配置。",
      "label": "远程配置"
    },
    "ingress_remote_qos": {
      "desc": "订阅远程borker时要使用的 QoS 级别",
      "label": "远程 QoS"
    },
    "ingress_remote_topic": {
      "desc": "从远程broker的哪个topic接收消息",
      "label": "远程主题"
    },
    "max_inflight": {
      "desc": "MQTT 协议的最大飞行（已发送但未确认）消息",
      "label": "最大飞行消息"
    },
    "mode": {
      "desc": "MQTT 桥的模式。 <br/>\n- cluster_shareload：在 emqx 集群的每个节点上创建一个 MQTT 连接。<br/>\n在“cluster_shareload”模式下，来自远程代理的传入负载通过共享订阅的方式接收。<br/>\n请注意，<code>clientid</code> 以节点名称为后缀，这是为了避免不同节点之间的 <code> clientid</code> 冲突。\n而且对于入口连接的 <code>remote.topic</code>，我们只能使用共享订阅主题过滤器。",
      "label": "MQTT 桥接模式"
    },
    "password": {
      "desc": "MQTT 协议的密码",
      "label": "密码"
    },
    "payload": {
      "desc": "要发送的 MQTT 消息的负载。<br/>\n允许使用带有变量的模板。",
      "label": "消息负载"
    },
    "proto_ver": {
      "desc": "MQTT 协议版本",
      "label": "协议版本"
    },
    "retain": {
      "desc": "要发送的 MQTT 消息的“保留”标志。<br/>\n允许使用带有变量的模板。",
      "label": "保留消息标志"
    },
    "server": {
      "desc": "远程 MQTT Broker的主机和端口。",
      "label": "Broker主机和端口"
    },
    "server_configs": {
      "desc": "服务器相关的配置。",
      "label": "服务配置。"
    },
    "username": {
      "desc": "MQTT 协议的用户名",
      "label": "用户名"
    }
  },
  "emqx_connector_mysql": {
    "server": {
      "desc": "将要连接的 IPv4 或 IPv6 地址，或者主机名。<br/>\n主机名具有以下形式：`Host[:Port]`。<br/>\n如果未指定 `[:Port]`，则使用 MySQL 默认端口 3306。",
      "label": "服务器地址"
    }
  },
  "emqx_connector_pgsql": {
    "server": {
      "desc": "将要连接的 IPv4 或 IPv6 地址，或者主机名。<br/>\n主机名具有以下形式：`Host[:Port]`。<br/>\n如果未指定 `[:Port]`，则使用 PostgreSQL 默认端口 5432。",
      "label": "服务器地址"
    }
  },
  "emqx_connector_redis": {
    "cluster": {
      "desc": "集群模式。当 Redis 服务运行在集群模式下，该配置必须设置为 'cluster'。",
      "label": "集群模式"
    },
    "database": {
      "desc": "Redis 数据库 ID。",
      "label": "数据库 ID"
    },
    "sentinel": {
      "desc": "哨兵模式。当 Redis 服务运行在哨兵模式下，该配置必须设置为 'sentinel'。",
      "label": "哨兵模式"
    },
    "sentinel_desc": {
      "desc": "Redis 哨兵模式下的集群名称。",
      "label": "集群名称"
    },
    "server": {
      "desc": "将要连接的 IPv4 或 IPv6 地址，或者主机名。<br/>\n主机名具有以下形式：`Host[:Port]`。<br/>\n如果未指定 `[:Port]`，则使用 Redis 默认端口 6379。",
      "label": "服务器地址"
    },
    "servers": {
      "desc": "集群将要连接的节点列表。 节点之间用逗号分隔，如：`Node[,Node].`\n每个节点的配置为：将要连接的 IPv4 或 IPv6 地址或主机名。\n主机名具有以下形式：`Host[:Port]`。\n如果未指定 `[:Port]`，则使用 Redis 默认端口 6379。",
      "label": "服务器列表"
    },
    "single": {
      "desc": "单机模式。当 Redis 服务运行在单机模式下，该配置必须设置为 'single'。",
      "label": "单机模式"
    }
  },
  "emqx_connector_schema_lib": {
    "auto_reconnect": {
      "desc": "已弃用。自动重连数据库。",
      "label": "已弃用。自动重连数据库"
    },
    "database_desc": {
      "desc": "数据库名字。",
      "label": "数据库名字"
    },
    "password": {
      "desc": "内部数据库密码。",
      "label": "密码"
    },
    "pool_size": {
      "desc": "桥接远端服务时使用的连接池大小。",
      "label": "连接池大小"
    },
    "prepare_statement": {
      "desc": "SQL 预处理语句列表。",
      "label": "SQL 预处理语句列表"
    },
    "ssl": {
      "desc": "启用 SSL 连接。",
      "label": "启用SSL"
    },
    "username": {
      "desc": "内部数据库的用户名。",
      "label": "用户名"
    }
  },
  "emqx_dashboard_api": {
    "change_pwd_api": {
      "desc": "更改 Dashboard 用户密码"
    },
    "create_user_api": {
      "desc": "创建 Dashboard 用户"
    },
    "create_user_api_success": {
      "desc": "创建 Dashboard 用户成功"
    },
    "delete_user_api": {
      "desc": "删除 Dashboard 用户"
    },
    "license": {
      "desc": "EMQX 许可类型。可为 opensource 或 enterprise"
    },
    "list_users_api": {
      "desc": "Dashboard 用户列表"
    },
    "login_api": {
      "desc": "获取 Dashboard 认证 Token。"
    },
    "login_failed401": {
      "desc": "登录失败。用户名或密码错误"
    },
    "login_failed_response400": {
      "desc": "登录失败。用户名或密码错误"
    },
    "login_success": {
      "desc": "Dashboard 认证成功"
    },
    "logout_api": {
      "desc": "Dashboard 用户登出"
    },
    "new_pwd": {
      "desc": "新密码"
    },
    "old_pwd": {
      "desc": "旧密码"
    },
    "password": {
      "desc": "Dashboard 密码"
    },
    "token": {
      "desc": "Dashboard 认证 Token"
    },
    "update_user_api": {
      "desc": "更新 Dashboard 用户描述"
    },
    "update_user_api200": {
      "desc": "更新 Dashboard 用户成功"
    },
    "user_description": {
      "desc": "Dashboard 用户描述"
    },
    "username": {
      "desc": "Dashboard 用户名"
    },
    "users_api404": {
      "desc": "Dashboard 用户不存在"
    },
    "version": {
      "desc": "EMQX 版本"
    }
  },
  "emqx_dashboard_schema": {
    "backlog": {
      "desc": "排队等待连接的队列的最大长度。",
      "label": "排队长度"
    },
    "bind": {
      "desc": "监听地址和端口，热更新此配置时，会重启 Dashboard 服务。",
      "label": "绑定端口"
    },
    "bootstrap_users_file": {
      "desc": "已废弃，请使用 api_key.bootstrap_file。",
      "label": "已废弃"
    },
    "cors": {
      "desc": "支持跨域资源共享(CORS)，\n允许服务器指示任何来源(域名、协议或端口)，除了本服务器之外的任何浏览器应允许加载资源。",
      "label": "跨域资源共享"
    },
    "default_password": {
      "desc": "Dashboard 的默认密码，为了安全，应该尽快修改密码。\n当通过网页首次登录 Dashboard 并按提示修改成复杂密码后，此值就会失效。",
      "label": "默认密码"
    },
    "default_username": {
      "desc": "Dashboard 的默认用户名。",
      "label": "默认用户名"
    },
    "desc_dashboard": {
      "desc": "EMQX Dashboard 配置。",
      "label": "Dashboard"
    },
    "desc_http": {
      "desc": "Dashboard 监听器(HTTP)配置。",
      "label": "HTTP"
    },
    "desc_https": {
      "desc": "Dashboard 监听器(HTTPS)配置。",
      "label": "HTTPS"
    },
    "desc_listeners": {
      "desc": "Dashboard 监听器配置。",
      "label": "监听器"
    },
    "i18n_lang": {
      "desc": "设置 Swagger 多语言的版本，可为 en 或 zh。",
      "label": "多语言支持"
    },
    "inet6": {
      "desc": "启用IPv6， 如果机器不支持IPv6，请关闭此选项，否则会导致 Dashboard 无法使用。",
      "label": "IPv6"
    },
    "ipv6_v6only": {
      "desc": "当开启 inet6 功能的同时禁用 IPv4-to-IPv6 映射。该配置仅在 inet6 功能开启时有效。",
      "label": "IPv6 only"
    },
    "listener_enable": {
      "desc": "忽略或启用该监听器。",
      "label": "启用"
    },
    "listeners": {
      "desc": "Dashboard 监听器设置。监听器必须有唯一的端口号和IP地址的组合。\n例如，可以通过指定IP地址 0.0.0.0 来监听机器上给定端口上的所有配置的IP地址。\n或者，可以为每个监听器指定唯一的IP地址，但使用相同的端口。",
      "label": "监听器"
    },
    "max_connections": {
      "desc": "同时处理的最大连接数。",
      "label": "最大连接数"
    },
    "num_acceptors": {
      "desc": "TCP协议的Socket acceptor池大小, 默认设置在线的调度器数量（通常为 CPU 核数）",
      "label": "Acceptor 数量"
    },
    "proxy_header": {
      "desc": "开启对  `HAProxy` 的支持，注意：一旦开启了这个功能，就无法再处理普通的 HTTP 请求了。",
      "label": "开启对 `HAProxy` 的支持"
    },
    "sample_interval": {
      "desc": "Dashboard 中图表指标的时间间隔。必须小于60，且被60的整除，默认设置 10s。"
    },
    "send_timeout": {
      "desc": "Socket发送超时时间。",
      "label": "发送超时时间"
    },
    "token_expired_time": {
      "desc": "JWT token 过期时间。默认设置为 60 分钟。",
      "label": "JWT 过期时间"
    }
  },
  "emqx_delayed_api": {
    "bad_msgid_format": {
      "desc": "消息 ID 格式错误"
    },
    "count": {
      "desc": "延迟消息总数"
    },
    "delayed_interval": {
      "desc": "延迟时间(秒)"
    },
    "delayed_remaining": {
      "desc": "剩余时间(秒)"
    },
    "delete_api": {
      "desc": "删除延迟消息"
    },
    "expected_at": {
      "desc": "期望的发送时间, RFC 3339 格式"
    },
    "from_clientid": {
      "desc": "消息的 ClientID"
    },
    "from_username": {
      "desc": "消息的 Username"
    },
    "get_message_api": {
      "desc": "查看延迟消息"
    },
    "illegality_limit": {
      "desc": "数量上限不合法"
    },
    "list_api": {
      "desc": "查看延迟消息列表"
    },
    "msgid": {
      "desc": "延迟消息 ID"
    },
    "msgid_not_found": {
      "desc": "未找到对应消息"
    },
    "node": {
      "desc": "消息的来源节点"
    },
    "payload": {
      "desc": "消息内容, base64 格式。如果消息的大小超过 2048 字节，则消息内容会被设置为 'PAYLOAD_TO_LARGE'"
    },
    "publish_at": {
      "desc": "客户端发送时间, RFC 3339 格式"
    },
    "qos": {
      "desc": "QoS"
    },
    "topic": {
      "desc": "主题"
    },
    "update_api": {
      "desc": "开启或者关闭功能，或者设置延迟消息数量上限"
    },
    "update_success": {
      "desc": "开启或者关闭功能操作成功"
    },
    "view_limit": {
      "desc": "每页数量"
    },
    "view_page": {
      "desc": "查看的页数"
    },
    "view_status_api": {
      "desc": "查看慢订阅状态"
    }
  },
  "emqx_ee_bridge_cassa": {
    "config_enable": {
      "desc": "启用/禁用桥接",
      "label": "启用/禁用桥接"
    },
    "cql_template": {
      "desc": "CQL 模板",
      "label": "CQL 模板"
    },
    "desc_config": {
      "desc": "Cassandra 桥接配置",
      "label": "Cassandra 桥接配置"
    },
    "desc_name": {
      "desc": "桥接名字",
      "label": "桥接名字"
    },
    "desc_type": {
      "desc": "Bridge 类型",
      "label": "桥接类型"
    },
    "local_topic": {
      "desc": "发送到 'local_topic' 的消息都会转发到 Cassandra。 </br>\n注意：如果这个 Bridge 被用作规则（EMQX 规则引擎）的输出，同时也配置了 'local_topic' ，那么这两部分的消息都会被转发。",
      "label": "本地 Topic"
    }
  },
  "emqx_ee_bridge_clickhouse": {
    "batch_value_separator": {
      "desc": "默认为逗号 ','，适用于 VALUE 格式。您也可以使用其他分隔符， 请参考 [INSERT INTO 语句](https://clickhouse.com/docs/en/sql-reference/statements/insert-into)。",
      "label": "分隔符"
    },
    "config_enable": {
      "desc": "启用/禁用桥接",
      "label": "启用/禁用桥接"
    },
    "desc_config": {
      "desc": "Clickhouse 桥接配置",
      "label": "Clickhouse 桥接配置"
    },
    "desc_name": {
      "desc": "桥接名字",
      "label": "桥接名字"
    },
    "desc_type": {
      "desc": "Bridge 类型",
      "label": "桥接类型"
    },
    "local_topic": {
      "desc": "发送到 'local_topic' 的消息都会转发到 Clickhouse。 </br>\n注意：如果这个 Bridge 被用作规则（EMQX 规则引擎）的输出，同时也配置了 'local_topic' ，那么这两部分的消息都会被转发。",
      "label": "本地 Topic"
    },
    "sql_template": {
      "desc": "可以使用 ${field} 占位符来引用消息与客户端上下文中的变量，请确保对应字段存在且数据格式符合预期。此处不支持 [SQL 预处理](https://docs.emqx.com/zh/enterprise/v5.0/data-integration/data-bridges.html#sql-预处理)。",
      "label": "SQL 模板"
    }
  },
  "emqx_ee_bridge_dynamo": {
    "config_enable": {
      "desc": "启用/禁用桥接",
      "label": "启用/禁用桥接"
    },
    "desc_config": {
      "desc": "DynamoDB 桥接配置",
      "label": "DynamoDB 桥接配置"
    },
    "desc_name": {
      "desc": "桥接名字",
      "label": "桥接名字"
    },
    "desc_type": {
      "desc": "Bridge 类型",
      "label": "桥接类型"
    },
    "local_topic": {
      "desc": "发送到 'local_topic' 的消息都会转发到 DynamoDB。 </br>\n注意：如果这个 Bridge 被用作规则（EMQX 规则引擎）的输出，同时也配置了 'local_topic' ，那么这两部分的消息都会被转发。",
      "label": "本地 Topic"
    },
    "template": {
      "desc": "模板, 默认为空，为空时将会将整个消息存入数据库",
      "label": "模板"
    }
  },
  "emqx_ee_bridge_gcp_pubsub": {
    "connect_timeout": {
      "desc": "连接 HTTP 服务器的超时时间。",
      "label": "连接超时"
    },
    "desc_config": {
      "desc": "GCP PubSub 桥接配置",
      "label": "GCP PubSub 桥接配置"
    },
    "desc_name": {
      "desc": "桥接名字，可读描述",
      "label": "桥接名字"
    },
    "desc_type": {
      "desc": "桥接类型",
      "label": "桥接类型"
    },
    "local_topic": {
      "desc": "发送到 'local_topic' 的消息都会转发到 GCP PubSub。 </br>\n注意：如果这个 Bridge 被用作规则（EMQX 规则引擎）的输出，同时也配置了 'local_topic' ，那么这两部分的消息都会被转发到 GCP PubSub。",
      "label": "本地 Topic"
    },
    "max_retries": {
      "desc": "请求出错时的最大重试次数。",
      "label": "最大重试次数"
    },
    "payload_template": {
      "desc": "用于格式化外发信息的模板。 如果未定义，将以JSON格式发送所有可用的上下文。",
      "label": "HTTP 请求消息体模板"
    },
    "pipelining": {
      "desc": "正整数，设置最大可发送的异步 HTTP 请求数量。当设置为 1 时，表示每次发送完成 HTTP 请求后都需要等待服务器返回，再继续发送下一个请求。",
      "label": "HTTP 流水线"
    },
    "pool_size": {
      "desc": "连接池大小。",
      "label": "连接池大小"
    },
    "pubsub_topic": {
      "desc": "要发布消息的GCP PubSub主题。",
      "label": "GCP PubSub 主题"
    },
    "request_timeout": {
      "desc": "废弃的。在缓冲区设置中配置请求超时。",
      "label": "HTTP 请求超时"
    },
    "service_account_json": {
      "desc": "包含将与 PubSub 一起使用的 GCP 服务账户凭证的 JSON。\n当创建GCP服务账户时（如https://developers.google.com/identity/protocols/oauth2/service-account#creatinganaccount），可以选择下载 JSON 形式的凭证，然后在该配置项中使用。",
      "label": "GCP 服务账户凭证"
    }
  },
  "emqx_ee_bridge_hstreamdb": {
    "config_direction": {
      "desc": "桥接的方向， 必须是 egress",
      "label": "桥接方向"
    },
    "config_enable": {
      "desc": "启用/禁用桥接",
      "label": "启用/禁用桥接"
    },
    "desc_config": {
      "desc": "HStreamDB 桥接配置",
      "label": "HStreamDB 桥接配置"
    },
    "desc_connector": {
      "desc": "连接器的通用配置。",
      "label": "连接器通用配置。"
    },
    "desc_name": {
      "desc": "桥接名字，可读描述",
      "label": "桥接名字"
    },
    "desc_type": {
      "desc": "Bridge 类型",
      "label": "桥接类型"
    },
    "local_topic": {
      "desc": "发送到 'local_topic' 的消息都会转发到 HStreamDB。 </br>\n注意：如果这个 Bridge 被用作规则（EMQX 规则引擎）的输出，同时也配置了 'local_topic' ，那么这两部分的消息都会被转发到 HStreamDB。",
      "label": "本地 Topic"
    },
    "payload": {
      "desc": "要转发到 HStreamDB 的数据内容，支持占位符",
      "label": "消息内容"
    }
  },
  "emqx_ee_bridge_influxdb": {
    "config_enable": {
      "desc": "启用/禁用桥接。",
      "label": "启用/禁用桥接"
    },
    "desc_config": {
      "desc": "InfluxDB 桥接配置。",
      "label": "InfluxDB 桥接配置"
    },
    "desc_name": {
      "desc": "桥接名称。",
      "label": "桥接名称"
    },
    "desc_type": {
      "desc": "桥接类型。",
      "label": "桥接类型"
    },
    "local_topic": {
      "desc": "发送到 'local_topic' 的消息都会转发到 InfluxDB。 </br>\n注意：如果这个 Bridge 被用作规则（EMQX 规则引擎）的输出，同时也配置了 'local_topic' ，那么这两部分的消息都会被转发到 InfluxDB。",
      "label": "本地 Topic"
    },
    "write_syntax": {
      "desc": "使用 InfluxDB API Line Protocol 写入 InfluxDB 的数据，支持占位符</br>\n参考 [InfluxDB 2.3 Line Protocol](https://docs.influxdata.com/influxdb/v2.3/reference/syntax/line-protocol/) 及\n[InfluxDB 1.8 Line Protocol](https://docs.influxdata.com/influxdb/v1.8/write_protocols/line_protocol_tutorial/) </br>\nTLDR: </br>\n```\n<measurement>[,<tag_key>=<tag_value>[,<tag_key>=<tag_value>]] <field_key>=<field_value>[,<field_key>=<field_value>] [<timestamp>]\n```\n注意，整形数值占位符后需要添加一个字符 `i` 类型标识。例如 `${payload.int_value}i`",
      "label": "写语句"
    }
  },
  "emqx_ee_bridge_kafka": {
    "connect_timeout": {
      "desc": "建立 TCP 连接时的最大等待时长（若启用认证，这个等待时长也包含完成认证所需时间）。",
      "label": "连接超时"
    },
    "producer_opts": {
      "desc": "本地 MQTT 数据源和 Kafka 桥接的配置。",
      "label": "MQTT 到 Kafka"
    },
    "min_metadata_refresh_interval": {
      "desc": "刷新 Kafka broker 和 Kafka 主题元数据段最短时间间隔。设置太小可能会增加 Kafka 压力。",
      "label": "元数据刷新最小间隔"
    },
    "kafka_producer": {
      "desc": "Kafka Producer 配置。",
      "label": "Kafka Producer"
    },
    "producer_buffer": {
      "desc": "配置消息缓存的相关参数。\n\n当 EMQX 需要发送的消息超过 Kafka 处理能力，或者当 Kafka 临时下线时，EMQX 内部会将消息缓存起来。",
      "label": "消息缓存"
    },
    "socket_send_buffer": {
      "desc": "TCP socket 的发送缓存调优。默认值是针对高吞吐量的一个推荐值。",
      "label": "Socket 发送缓存大小"
    },
    "desc_name": {
      "desc": "桥接名字，可读描述",
      "label": "桥接名字"
    },
    "consumer_offset_commit_interval_seconds": {
      "desc": "指定 Kafka 消费组偏移量提交的时间间隔。",
      "label": "偏移提交间隔"
    },
    "consumer_max_batch_bytes": {
      "desc": "设置每次从 Kafka 拉取数据的字节数。如该配置小于 Kafka 消息的大小，可能会影响消费性能。",
      "label": "拉取字节数"
    },
    "socket_receive_buffer": {
      "desc": "TCP socket 的收包缓存调优。默认值是针对高吞吐量的一个推荐值。",
      "label": "Socket 收包缓存大小"
    },
    "consumer_topic_mapping": {
      "desc": "指定 Kafka 主题和 MQTT 主题之间的映射关系。 应至少包含一项。",
      "label": "主题映射关系"
    },
    "producer_kafka_opts": {
      "desc": "Kafka 生产者参数。",
      "label": "生产者参数"
    },
    "kafka_topic": {
      "desc": "Kafka 主题名称",
      "label": "Kafka 主题名称"
    },
    "consumer_kafka_topic": {
      "desc": "指定从哪个 Kafka 主题消费消息。",
      "label": "Kafka 主题"
    },
    "auth_username_password": {
      "desc": "基于用户名密码的认证。",
      "label": "用户名密码认证"
    },
    "auth_sasl_password": {
      "desc": "SASL 认证的密码。",
      "label": "密码"
    },
    "kafka_message_timestamp": {
      "desc": "生成 Kafka 消息时间戳的模版。该时间必需是一个整型数值（可以是字符串格式）例如 <code>1661326462115</code> 或 <code>'1661326462115'</code>。当所需的输入字段不存在，或不是一个整型时，则会使用当前系统时间。",
      "label": "消息的时间戳"
    },
    "buffer_mode": {
      "desc": "消息缓存模式。\n<code>memory</code>: 所有的消息都缓存在内存里。如果 EMQX 服务重启，缓存的消息会丢失。\n<code>disk</code>: 缓存到磁盘上。EMQX 重启后会继续发送重启前未发送完成的消息。\n<code>hybrid</code>: 先将消息缓存在内存中，当内存中的消息堆积超过一定限制（配置项 <code>segment_bytes</code> 描述了该限制）后，后续的消息会缓存到磁盘上。与 <code>memory</code> 模式一样，如果 EMQX 服务重启，缓存的消息会丢失。",
      "label": "缓存模式"
    },
    "consumer_mqtt_qos": {
      "desc": "转发 MQTT 消息时使用的 QoS。",
      "label": "QoS"
    },
    "consumer_key_encoding_mode": {
      "desc": "通过 MQTT 转发之前，如何处理 Kafka 消息的 Key。<code>none</code> 使用 Kafka 消息中的 Key 原始值，不进行编码。  注意：在这种情况下，Key 必须是一个有效的 UTF-8 字符串。\n<code>base64</code> 对收到的密钥或值使用 base-64 编码。",
      "label": "Key 编码模式"
    },
    "auth_gssapi_kerberos": {
      "desc": "使用 GSSAPI/Kerberos 认证。",
      "label": "GSSAPI/Kerberos"
    },
    "consumer_mqtt_opts": {
      "desc": "本地 MQTT 消息转发。",
      "label": "MQTT 转发"
    },
    "auth_kerberos_principal": {
      "desc": "SASL GSSAPI 认证方法的 Kerberos principal，例如 <code>client_name@MY.KERBEROS.REALM.MYDOMAIN.COM</code>注意：这里使用的 realm 需要配置在 EMQX 服务器的 /etc/krb5.conf 中",
      "label": "Kerberos Principal"
    },
    "socket_opts": {
      "desc": "更多 Socket 参数设置。",
      "label": "Socket 参数"
    },
    "consumer_mqtt_topic": {
      "desc": "设置 Kafka 消息向哪个本地 MQTT 主题转发消息。",
      "label": "MQTT主题"
    },
    "consumer_offset_reset_policy": {
      "desc": "如不存在偏移量历史记录或历史记录失效，消费者应使用哪个偏移量开始消费。",
      "label": "偏移重置策略"
    },
    "partition_count_refresh_interval": {
      "desc": "配置 Kafka 刷新分区数量的时间间隔。\nEMQX 发现 Kafka 分区数量增加后，会开始按 <code>partition_strategy<code> 配置，把消息发送到新的分区中。",
      "label": "分区数量刷新间隔"
    },
    "max_batch_bytes": {
      "desc": "最大消息批量字节数。大多数 Kafka 环境的默认最低值是 1 MB，EMQX 的默认值比 1 MB 更小是因为需要补偿 Kafka 消息编码所需要的额外字节（尤其是当每条消息都很小的情况下）。当单个消息的大小超过该限制时，它仍然会被发送，（相当于该批量中只有单个消息）。",
      "label": "最大批量字节数"
    },
    "required_acks": {
      "desc": "设置 Kafka leader 在返回给 EMQX 确认之前需要等待多少个 follower 的确认。\n\n<code>all_isr</code>: 需要所有的在线复制者都确认。\n<code>leader_only</code>: 仅需要分区 leader 确认。\n<code>none</code>: 无需 Kafka 回复任何确认。",
      "label": "Kafka 确认数量"
    },
    "metadata_request_timeout": {
      "desc": "刷新元数据时最大等待时长。",
      "label": "元数据请求超时"
    },
    "desc_type": {
      "desc": "桥接类型",
      "label": "桥接类型"
    },
    "socket_nodelay": {
      "desc": "设置‘true’让系统内核立即发送。否则当需要发送的内容很少时，可能会有一定延迟（默认 40 毫秒）。",
      "label": "是否关闭延迟发送"
    },
    "authentication": {
      "desc": "认证参数。",
      "label": "认证"
    },
    "buffer_memory_overload_protection": {
      "desc": "缓存模式是 <code>memory</code> 或 <code>hybrid</code> 时适用。当系统处于高内存压力时，从队列中丢弃旧的消息以减缓内存增长。内存压力值由配置项 <code>sysmon.os.sysmem_high_watermark</code> 决定。注意，该配置仅在 Linux 系统中有效。",
      "label": "内存过载保护"
    },
    "auth_sasl_mechanism": {
      "desc": "SASL 认证方法名称。",
      "label": "认证方法"
    },
    "config_enable": {
      "desc": "启用（true）或停用该（false）Kafka 数据桥接。",
      "label": "启用或停用"
    },
    "consumer_mqtt_payload": {
      "desc": "用于转换收到的 Kafka 消息的模板。 默认情况下，它将使用 JSON 格式来序列化来自 Kafka 的所有字段。 这些字段包括：<code>headers</code>：一个包含字符串键值对的 JSON 对象。\n<code>key</code>：Kafka 消息的键（使用选择的编码方式编码）。\n<code>offset</code>：消息的偏移量。\n<code>topic</code>：Kafka 主题。\n<code>ts</code>: 消息的时间戳。\n<code>ts_type</code>：消息的时间戳类型，值可能是： <code>create</code>， <code>append</code> 或 <code>undefined</code>。\n<code>value</code>: Kafka 消息值（使用选择的编码方式编码）。",
      "label": "MQTT Payload Template"
    },
    "consumer_opts": {
      "desc": "本地 MQTT 转发 和 Kafka 消费者配置。",
      "label": "MQTT 到 Kafka"
    },
    "kafka_consumer": {
      "desc": "Kafka 消费者配置。",
      "label": "Kafka 消费者"
    },
    "desc_config": {
      "desc": "Kafka 桥接配置",
      "label": "Kafka 桥接配置"
    },
    "consumer_value_encoding_mode": {
      "desc": "通过 MQTT 转发之前，如何处理 Kafka 消息的 Value。<code>none</code> 使用 Kafka 消息中的 Value 原始值，不进行编码。  注意：在这种情况下，Value 必须是一个有效的 UTF-8 字符串。\n<code>base64</code> 对收到的 Value 使用 base-64 编码。",
      "label": "Value 编码模式"
    },
    "buffer_per_partition_limit": {
      "desc": "为每个 Kafka 分区设置的最大缓存字节数。当超过这个上限之后，老的消息会被丢弃，为新的消息腾出空间。",
      "label": "Kafka 分区缓存上限"
    },
    "bootstrap_hosts": {
      "desc": "用逗号分隔的 <code>host[:port]</code> 主机列表。默认端口号为 9092。",
      "label": "主机列表"
    },
    "consumer_max_rejoin_attempts": {
      "desc": "消费组成员允许重新加入小组的最大次数。如超过该配置次数后仍未能成功加入消费组，则会在等待一段时间后重试。",
      "label": "最大的重新加入尝试"
    },
    "kafka_message_key": {
      "desc": "生成 Kafka 消息 Key 的模版。如果模版生成后为空值，则会使用 Kafka 的 <code>NULL</code> ，而非空字符串。",
      "label": "消息的 Key"
    },
    "kafka_message": {
      "desc": "用于生成 Kafka 消息的模版。",
      "label": "Kafka 消息模版"
    },
    "mqtt_topic": {
      "desc": "指定 MQTT 主题作为桥接的数据源。 若该桥接用于规则的动作，则必须将该配置项删除。",
      "label": "源 MQTT 主题"
    },
    "kafka_message_value": {
      "desc": "生成 Kafka 消息 Value 的模版。如果模版生成后为空值，则会使用 Kafka 的 <code>NULL</code>，而非空字符串。",
      "label": "消息的 Value"
    },
    "partition_strategy": {
      "desc": "设置消息发布时应该如何选择 Kafka 分区。\n\n<code>random</code>: 为每个消息随机选择一个分区。\n<code>key_dispatch</code>: Hash Kafka message key to a partition number",
      "label": "分区选择策略"
    },
    "buffer_segment_bytes": {
      "desc": "当缓存模式是 <code>disk</code> 或 <code>hybrid</code> 时适用。该配置用于指定缓存到磁盘上的文件的大小。",
      "label": "缓存文件大小"
    },
    "consumer_kafka_opts": {
      "desc": "Kafka消费者配置。",
      "label": "Kafka 消费者"
    },
    "max_inflight": {
      "desc": "设置 Kafka 生产者（每个分区一个）在收到 Kafka 的确认前最多发送多少个请求（批量）。调大这个值通常可以增加吞吐量，但是，当该值设置大于 1 时存在消息乱序的风险。",
      "label": "飞行窗口"
    },
    "auth_sasl_username": {
      "desc": "SASL 认证的用户名。",
      "label": "用户名"
    },
    "auth_kerberos_keytab_file": {
      "desc": "SASL GSSAPI 认证方法的 Kerberos keytab 文件。注意：该文件需要上传到 EMQX 服务器中，且运行 EMQX 服务的系统账户需要有读取权限。",
      "label": "Kerberos keytab 文件"
    },
    "compression": {
      "desc": "压缩方法。",
      "label": "压缩"
    }
  },
  "emqx_ee_bridge_mongodb": {
    "collection": {
      "desc": "数据将被存储到的集合",
      "label": "将要使用的集合（Collection）"
    },
    "desc_config": {
      "desc": "为MongoDB桥配置",
      "label": "MongoDB桥配置"
    },
    "desc_name": {
      "desc": "桥接名称。",
      "label": "桥接名称"
    },
    "desc_type": {
      "desc": "桥接类型。",
      "label": "桥接类型"
    },
    "enable": {
      "desc": "启用或停用该MongoDB桥",
      "label": "启用或禁用"
    },
    "mongodb_rs_conf": {
      "desc": "MongoDB（Replica Set）配置",
      "label": "MongoDB（Replica Set）配置"
    },
    "mongodb_sharded_conf": {
      "desc": "MongoDB (Sharded)配置",
      "label": "MongoDB (Sharded)配置"
    },
    "mongodb_single_conf": {
      "desc": "MongoDB（独立）配置",
      "label": "MongoDB（独立）配置"
    },
    "payload_template": {
      "desc": "用于格式化写入 MongoDB 的消息模板。 如果未定义，规则引擎会使用 JSON 格式序列化所有的可见输入，例如 clientid, topic, payload 等。",
      "label": "有效载荷模板"
    }
  },
  "emqx_ee_bridge_mysql": {
    "config_enable": {
      "desc": "启用/禁用桥接",
      "label": "启用/禁用桥接"
    },
    "desc_config": {
      "desc": "HStreamDB 桥接配置",
      "label": "HStreamDB 桥接配置"
    },
    "desc_name": {
      "desc": "桥接名字，可读描述",
      "label": "桥接名字"
    },
    "desc_type": {
      "desc": "Bridge 类型",
      "label": "桥接类型"
    },
    "local_topic": {
      "desc": "发送到 'local_topic' 的消息都会转发到 MySQL。 </br>\n注意：如果这个 Bridge 被用作规则（EMQX 规则引擎）的输出，同时也配置了 'local_topic' ，那么这两部分的消息都会被转发。",
      "label": "本地 Topic"
    },
    "sql_template": {
      "desc": "SQL 模板",
      "label": "SQL 模板"
    }
  },
  "emqx_ee_bridge_pgsql": {
    "config_enable": {
      "desc": "启用/禁用桥接",
      "label": "启用/禁用桥接"
    },
    "desc_config": {
      "desc": "PostgreSQL 桥接配置",
      "label": "PostgreSQL 桥接配置"
    },
    "desc_name": {
      "desc": "桥接名字",
      "label": "桥接名字"
    },
    "desc_type": {
      "desc": "Bridge 类型",
      "label": "桥接类型"
    },
    "local_topic": {
      "desc": "发送到 'local_topic' 的消息都会转发到 PostgreSQL。 </br>\n注意：如果这个 Bridge 被用作规则（EMQX 规则引擎）的输出，同时也配置了 'local_topic' ，那么这两部分的消息都会被转发。",
      "label": "本地 Topic"
    },
    "sql_template": {
      "desc": "SQL 模板",
      "label": "SQL 模板"
    }
  },
  "emqx_ee_bridge_redis": {
    "command_template": {
      "desc": "用于推送数据的 Redis 命令模板。 每个列表元素代表一个命令名称或其参数。\n例如，要通过键值 `msgs` 将消息体推送到 Redis 列表中，数组元素应该是： `rpush`, `msgs`, `${payload}`。",
      "label": "Redis Command  模板"
    },
    "config_enable": {
      "desc": "启用/禁用桥接",
      "label": "启用/禁用桥接"
    },
    "desc_config": {
      "desc": "Resis 桥接配置",
      "label": "Redis 桥接配置"
    },
    "desc_name": {
      "desc": "桥接名字，可读描述",
      "label": "桥接名字"
    },
    "desc_type": {
      "desc": "Bridge 类型",
      "label": "桥接类型"
    },
    "local_topic": {
      "desc": "发送到 'local_topic' 的消息都会转发到 Redis。 </br>\n注意：如果这个 Bridge 被用作规则（EMQX 规则引擎）的输出，同时也配置了 'local_topic' ，那么这两部分的消息都会被转发到 Redis。",
      "label": "本地 Topic"
    }
  },
  "emqx_ee_bridge_rocketmq": {
    "config_enable": {
      "desc": "启用/禁用桥接",
      "label": "启用/禁用桥接"
    },
    "desc_config": {
      "desc": "RocketMQ 桥接配置",
      "label": "RocketMQ 桥接配置"
    },
    "desc_name": {
      "desc": "桥接名字",
      "label": "桥接名字"
    },
    "desc_type": {
      "desc": "Bridge 类型",
      "label": "桥接类型"
    },
    "local_topic": {
      "desc": "发送到 'local_topic' 的消息都会转发到 RocketMQ。 </br>\n注意：如果这个 Bridge 被用作规则（EMQX 规则引擎）的输出，同时也配置了 'local_topic' ，那么这两部分的消息都会被转发。",
      "label": "本地 Topic"
    },
    "template": {
      "desc": "模板, 默认为空，为空时将会将整个消息转发给 RocketMQ",
      "label": "模板"
    }
  },
  "emqx_ee_bridge_tdengine": {
    "config_enable": {
      "desc": "启用/禁用桥接",
      "label": "启用/禁用桥接"
    },
    "desc_config": {
      "desc": "TDengine 桥接配置",
      "label": "TDengine 桥接配置"
    },
    "desc_name": {
      "desc": "桥接名字",
      "label": "桥接名字"
    },
    "desc_type": {
      "desc": "Bridge 类型",
      "label": "桥接类型"
    },
    "local_topic": {
      "desc": "发送到 'local_topic' 的消息都会转发到 TDengine。 </br>\n注意：如果这个 Bridge 被用作规则（EMQX 规则引擎）的输出，同时也配置了 'local_topic' ，那么这两部分的消息都会被转发。",
      "label": "本地 Topic"
    },
    "sql_template": {
      "desc": "SQL 模板",
      "label": "SQL 模板"
    }
  },
  "emqx_ee_connector_cassa": {
    "keyspace": {
      "desc": "要连接到的 Keyspace 名称。",
      "label": "Keyspace"
    },
    "servers": {
      "desc": "将要连接的 IPv4 或 IPv6 地址，或者主机名。<br/>\n主机名具有以下形式：`Host[:Port][,Host2:Port]`。<br/>\n如果未指定 `[:Port]`，则使用 Cassandra 默认端口 9042。",
      "label": "Servers"
    }
  },
  "emqx_ee_connector_clickhouse": {
    "base_url": {
      "desc": "你想连接到的Clickhouse服务器的HTTP URL（例如http://myhostname:8123）。",
      "label": "服务器 URL"
    },
    "connect_timeout": {
      "desc": "连接HTTP服务器的超时时间。",
      "label": "连接超时"
    }
  },
  "emqx_ee_connector_dynamo": {
    "url": {
      "desc": "DynamoDB 的地址。",
      "label": "DynamoDB 地址"
    }
  },
  "emqx_ee_connector_hstreamdb": {
    "config": {
      "desc": "HStreamDB 连接配置。",
      "label": "连接配置"
    },
    "name": {
      "desc": "连接器名称，人类可读的连接器描述。",
      "label": "连接器名称"
    },
    "ordering_key": {
      "desc": "HStreamDB 分区键",
      "label": "HStreamDB 分区键"
    },
    "pool_size": {
      "desc": "HStreamDB 连接池大小",
      "label": "HStreamDB 连接池大小"
    },
    "stream_name": {
      "desc": "HStreamDB 流名称",
      "label": "HStreamDB 流名称"
    },
    "type": {
      "desc": "连接器类型。",
      "label": "连接器类型"
    },
    "url": {
      "desc": "HStreamDB 服务器 URL",
      "label": "HStreamDB 服务器 URL"
    }
  },
  "emqx_ee_connector_influxdb": {
    "bucket": {
      "desc": "InfluxDB bucket 名称。",
      "label": "Bucket"
    },
    "database": {
      "desc": "InfluxDB 数据库。",
      "label": "数据库"
    },
    "influxdb_api_v1": {
      "desc": "InfluxDB HTTP API 协议。支持 Influxdb v1.8 以及之前的版本。",
      "label": "HTTP API 协议"
    },
    "influxdb_api_v2": {
      "desc": "InfluxDB HTTP API V2 协议。支持 Influxdb v2.0 以及之后的版本。",
      "label": "HTTP API V2 协议"
    },
    "org": {
      "desc": "InfluxDB 组织名称。",
      "label": "组织"
    },
    "password": {
      "desc": "InfluxDB 密码。",
      "label": "密码"
    },
    "precision": {
      "desc": "InfluxDB 时间精度。",
      "label": "时间精度"
    },
    "protocol": {
      "desc": "InfluxDB 协议。HTTP API 或 HTTP API V2。",
      "label": "协议"
    },
    "server": {
      "desc": "将要连接的 IPv4 或 IPv6 地址，或者主机名。</br>\n主机名具有以下形式：`Host[:Port]`。</br>\n如果未指定 `[:Port]`，则使用 InfluxDB 默认端口 8086。",
      "label": "服务器地址"
    },
    "token": {
      "desc": "InfluxDB token。",
      "label": "Token"
    },
    "username": {
      "desc": "InfluxDB 用户名。",
      "label": "用户名"
    }
  },
  "emqx_ee_connector_rocketmq": {
    "refresh_interval": {
      "desc": "RocketMQ 主题路由更新间隔。",
      "label": "主题路由更新间隔"
    },
    "security_token": {
      "desc": "RocketMQ 服务器安全令牌",
      "label": "安全令牌"
    },
    "send_buffer": {
      "desc": "RocketMQ 驱动的套字节发送消息的缓冲区大小",
      "label": "发送消息的缓冲区大小"
    },
    "server": {
      "desc": "将要连接的 IPv4 或 IPv6 地址，或者主机名。<br/>\n主机名具有以下形式：`Host[:Port]`。<br/>\n如果未指定 `[:Port]`，则使用 RocketMQ 默认端口 9876。",
      "label": "服务器地址"
    },
    "topic": {
      "desc": "RocketMQ 主题",
      "label": "RocketMQ 主题"
    }
  },
  "emqx_ee_connector_tdengine": {
    "server": {
      "desc": "将要连接的 IPv4 或 IPv6 地址，或者主机名。<br/>\n主机名具有以下形式：`Host[:Port]`。<br/>\n如果未指定 `[:Port]`，则使用 TDengine 默认端口 6041。",
      "label": "服务器地址"
    }
  },
  "emqx_exhook_api": {
    "add_server": {
      "desc": "添加 ExHook 服务器"
    },
    "delete_server": {
      "desc": "删除 Exhook 服务器"
    },
    "get_detail": {
      "desc": "查看 Exhook 服务器详细信息"
    },
    "get_hooks": {
      "desc": "获取 Exhook 服务器的钩子信息"
    },
    "hook_metrics": {
      "desc": "当前节点中该钩子的指标信息"
    },
    "hook_name": {
      "desc": "钩子的名称"
    },
    "hook_params": {
      "desc": "钩子注册时使用的参数"
    },
    "list_all_servers": {
      "desc": "查看ExHook 服务器列表"
    },
    "metric_failed": {
      "desc": "钩子执行失败的次数"
    },
    "metric_max_rate": {
      "desc": "钩子的最大调用速率"
    },
    "metric_rate": {
      "desc": "钩子的调用速率"
    },
    "metric_succeed": {
      "desc": "钩子执行成功的次数"
    },
    "metrics": {
      "desc": "指标信息"
    },
    "move_api": {
      "desc": "移动 Exhook 服务器顺序。\n注意: 移动的参数只能是：front | rear | before:{name} | after:{name}",
      "label": "改变已注册的Exhook服务器的执行顺序"
    },
    "move_position": {
      "desc": "移动的方向"
    },
    "node": {
      "desc": "节点名称"
    },
    "node_hook_metrics": {
      "desc": "所有节点中该钩子的指标信息"
    },
    "node_metrics": {
      "desc": "所有节点中该服务器的指标信息"
    },
    "node_status": {
      "desc": "所有节点中该服务器的状态信息"
    },
    "server_metrics": {
      "desc": "当前节点中该服务器的指标信息"
    },
    "server_name": {
      "desc": "Exhook 服务器的名称"
    },
    "status": {
      "desc": "Exhook 服务器的状态。<br/>\nconnected: 连接成功<br/>\nconnecting: 连接失败，重连中<br/>\ndisconnected: 连接失败，且未设置自动重连<br/>\ndisabled: 该服务器未开启<br/>\nerror: 查看该服务器状态时发生错误"
    },
    "update_server": {
      "desc": "更新 Exhook 服务器"
    }
  },
  "emqx_exhook_schema": {
    "auto_reconnect": {
      "desc": "自动重连到 gRPC 服务器的设置。\n当 gRPC 服务器不可用时，Exhook 将会按照这里设置的间隔时间进行重连，并重新初始化注册的钩子"
    },
    "enable": {
      "desc": "开启这个 Exhook 服务器"
    },
    "failed_action": {
      "desc": "当 gRPC 请求失败后的操作"
    },
    "keepalive": {
      "desc": "当没有其他数据交换时，是否向连接的对端套接字定期的发送探测包。如果另一端没有响应，则认为连接断开，并向控制进程发送错误消息"
    },
    "name": {
      "desc": "ExHook 服务器名称"
    },
    "nodelay": {
      "desc": "如果为 true，则为套接字设置 TCP_NODELAY 选项，这意味着会立即发送数据包"
    },
    "pool_size": {
      "desc": "gRPC 客户端进程池大小"
    },
    "recbuf": {
      "desc": "套接字的最小接收缓冲区大小"
    },
    "request_timeout": {
      "desc": "gRPC 服务器请求超时时间"
    },
    "servers": {
      "desc": "ExHook 服务器列表"
    },
    "sndbuf": {
      "desc": "套接字的最小发送缓冲区大小"
    },
    "socket_options": {
      "desc": "连接套接字设置"
    },
    "url": {
      "desc": "gRPC 服务器地址"
    }
  },
  "emqx_exproto_schema": {
    "exproto": {
      "desc": "ExProto 网关"
    },
    "exproto_grpc_handler_address": {
      "desc": "对端 gRPC 服务器地址。"
    },
    "exproto_grpc_handler_ssl": {
      "desc": "gRPC 客户端的 SSL 配置。"
    },
    "exproto_grpc_server_bind": {
      "desc": "服务监听地址和端口。"
    },
    "exproto_grpc_server_ssl": {
      "desc": "服务 SSL 配置。"
    },
    "exproto_handler": {
      "desc": "配置 ExProto 网关需要请求的 <code>ConnectionHandler</code> 服务地址。\n该服务用于给 ExProto 提供客户端的 Socket 事件处理、字节解码、订阅消息接收等功能。"
    },
    "exproto_server": {
      "desc": "配置 ExProto 网关需要启动的 <code>ConnectionAdapter</code> 服务。\n该服务用于提供客户端的认证、发布、订阅和数据下行等功能。"
    }
  },
  "emqx_gateway_api": {
    "delete_gateway": {
      "desc": "停用指定网关"
    },
    "enable_gateway": {
      "desc": "使用配置启动某一网关。"
    },
    "gateway_created_at": {
      "desc": "网关创建时间"
    },
    "gateway_current_connections": {
      "desc": "当前连接数"
    },
    "gateway_enable_in_path": {
      "desc": "是否开启此网关"
    },
    "gateway_listener_id": {
      "desc": "监听器 ID"
    },
    "gateway_listener_name": {
      "desc": "监听器名称"
    },
    "gateway_listener_running": {
      "desc": "监听器运行状态"
    },
    "gateway_listener_type": {
      "desc": "监听器类型"
    },
    "gateway_listeners": {
      "desc": "网关监听器列表"
    },
    "gateway_max_connections": {
      "desc": "最大连接数"
    },
    "gateway_name": {
      "desc": "网关名称"
    },
    "gateway_name_in_qs": {
      "desc": "网关名称.<br/>\n可取值为 `stomp`、`mqttsn`、`coap`、`lwm2m`、`exproto`"
    },
    "gateway_node_status": {
      "desc": "网关在集群中每个节点上的状态"
    },
    "gateway_started_at": {
      "desc": "网关启用时间"
    },
    "gateway_status": {
      "desc": "网关启用状态"
    },
    "gateway_status_in_qs": {
      "desc": "通过网关状态筛选<br/>\n可选值为 `running`、`stopped`、`unloaded`"
    },
    "gateway_stopped_at": {
      "desc": "网关停用时间"
    },
    "get_gateway": {
      "desc": "获取网关配置详情"
    },
    "list_gateway": {
      "desc": "该接口会返回指定或所有网关的概览状态，\n包括当前状态、连接数、监听器状态等。"
    },
    "node": {
      "desc": "节点名称"
    },
    "update_gateway": {
      "desc": "更新指定网关的基础配置、和启用的状态。<br/>\n注：认证、和监听器的配置更新需参考对应的 API 接口。"
    }
  },
  "emqx_gateway_api_authn": {
    "add_authn": {
      "desc": "为指定网关开启认证器实现客户端认证的功能。<br/>\n当未配置认证器或关闭认证器时，则认为允许所有客户端的连接。<br/>\n注：在网关中仅支持添加一个认证器，而不是像 MQTT 一样允许配置多个认证器构成认证链。"
    },
    "add_user": {
      "desc": "添加用户（仅支持 built_in_database 类型的认证器）"
    },
    "delete_authn": {
      "desc": "删除指定网关的认证器。"
    },
    "delete_user": {
      "desc": "删除用户（仅支持 built_in_database 类型的认证器）"
    },
    "get_authn": {
      "desc": "获取指定网关认证器的配置\n当网关或认证未启用时，返回 404。"
    },
    "get_user": {
      "desc": "获取用户信息（仅支持 built_in_database 类型的认证器）"
    },
    "import_users": {
      "desc": "导入用户（仅支持 built_in_database 类型的认证器）"
    },
    "is_superuser": {
      "desc": "是否是超级用户"
    },
    "like_user_id": {
      "desc": "使用用户 ID （username 或 clientid）模糊搜索，仅支持按子串的方式进行搜索。"
    },
    "list_users": {
      "desc": "获取用户列表（仅支持 built_in_database 类型的认证器）"
    },
    "update_authn": {
      "desc": "更新指定网关认证器的配置，或停用认证器。"
    },
    "update_user": {
      "desc": "更新用户信息（仅支持 built_in_database 类型的认证器）"
    },
    "user_id": {
      "desc": "用户 ID"
    }
  },
  "emqx_gateway_api_clients": {
    "disconnected_at": {
      "desc": "客户端连接断开时间"
    },
    "heap_size": {
      "desc": "进程堆内存大小，单位：字节"
    },
    "send_oct": {
      "desc": "已发送字节数"
    },
    "get_client": {
      "desc": "获取客户端信息"
    },
    "param_gte_created_at": {
      "desc": "匹配会话创建时间大于等于指定值的客户端"
    },
    "param_conn_state": {
      "desc": "匹配客户端连接状态"
    },
    "send_pkt": {
      "desc": "已发送应用层协议控制报文数"
    },
    "clean_start": {
      "desc": "标识客户端是否以 clean_start 的标志连接到网关"
    },
    "inflight_cnt": {
      "desc": "客户端当前飞行窗口大小"
    },
    "delete_subscription": {
      "desc": "为某客户端删除某订阅关系"
    },
    "param_lte_connected_at": {
      "desc": "匹配连接创建时间小于等于指定值的客户端"
    },
    "node": {
      "desc": "客户端连接到的节点名称"
    },
    "awaiting_rel_cnt": {
      "desc": "客户端当前等待 PUBREL 确认的 PUBREC 消息的条数"
    },
    "rap": {
      "desc": "Retain as Published 选项，枚举：0，1"
    },
    "inflight_max": {
      "desc": "客户端允许的飞行窗口最大值"
    },
    "param_username": {
      "desc": "匹配客户端 Username"
    },
    "param_like_endpoint_name": {
      "desc": "子串匹配 LwM2M 客户端 Endpoint Name"
    },
    "created_at": {
      "desc": "会话创建时间"
    },
    "sub_props": {
      "desc": "订阅属性"
    },
    "list_clients": {
      "desc": "获取指定网关的客户端列表"
    },
    "subscriptions_cnt": {
      "desc": "客户端已订阅主题数"
    },
    "mailbox_len": {
      "desc": "进程邮箱大小"
    },
    "send_cnt": {
      "desc": "已发送 Socket 报文次数"
    },
    "rh": {
      "desc": "Retain Handling 选项，枚举：0，1，2"
    },
    "connected": {
      "desc": "标识客户端是否已连接到网关"
    },
    "qos": {
      "desc": "QoS 等级，枚举：0，1，2"
    },
    "ip_address": {
      "desc": "客户端 IP 地址"
    },
    "param_gte_connected_at": {
      "desc": "匹配连接创建时间大于等于指定值的客户端"
    },
    "awaiting_rel_max": {
      "desc": "客户端允许的最大 PUBREC 等待队列长度"
    },
    "param_like_username": {
      "desc": "子串匹配 客户端 Username"
    },
    "nl": {
      "desc": "No Local 选项，枚举：0，1"
    },
    "param_like_clientid": {
      "desc": "子串匹配客户端 ID"
    },
    "param_lte_created_at": {
      "desc": "匹配会话创建时间小于等于指定值的客户端"
    },
    "topic": {
      "desc": "主题过滤器或主题名称"
    },
    "proto_ver": {
      "desc": "客户端使用的协议版本"
    },
    "mountpoint": {
      "desc": "主题固定前缀"
    },
    "proto_name": {
      "desc": "客户端使用的协议名称"
    },
    "param_lte_lifetime": {
      "desc": "匹配心跳时间小于等于指定值的 LwM2M 客户端"
    },
    "port": {
      "desc": "客户端端口"
    },
    "connected_at": {
      "desc": "客户端连接时间"
    },
    "expiry_interval": {
      "desc": "会话超期时间，单位：秒"
    },
    "username": {
      "desc": "客户端连接的用户名"
    },
    "param_clean_start": {
      "desc": "匹配客户端 `clean_start` 标记"
    },
    "recv_msg": {
      "desc": "已接收上行的消息条数"
    },
    "list_subscriptions": {
      "desc": "获取某客户端的主题订阅列表"
    },
    "recv_oct": {
      "desc": "已接收的字节数"
    },
    "keepalive": {
      "desc": "Keepalive 时间，单位：秒"
    },
    "param_clientid": {
      "desc": "匹配客户端 ID"
    },
    "subscriptions_max": {
      "desc": "客户端允许订阅的最大主题数"
    },
    "param_ip_address": {
      "desc": "匹配客户端 IP 地址"
    },
    "mqueue_max": {
      "desc": "客户端允许的最大消息队列长度"
    },
    "mqueue_dropped": {
      "desc": "由于消息队列过程，客户端消息队列丢弃消息条数"
    },
    "subid": {
      "desc": "订阅ID，仅用于 Stomp 网关。用于创建订阅关系时指定订阅 ID。取值范围 1-65535。"
    },
    "clientid": {
      "desc": "客户端 ID"
    },
    "kick_client": {
      "desc": "踢出指定客户端"
    },
    "is_bridge": {
      "desc": "标识客户端是否通过 is_bridge 标志连接"
    },
    "lifetime": {
      "desc": "LwM2M 客户端心跳周期"
    },
    "send_msg": {
      "desc": "已发送下行消息数条数"
    },
    "add_subscription": {
      "desc": "为某客户端新增订阅关系"
    },
    "param_endpoint_name": {
      "desc": "匹配 LwM2M 客户端 Endpoint Name"
    },
    "param_node": {
      "desc": "匹配客户端的节点名称"
    },
    "recv_cnt": {
      "desc": "已接收 Socket 报文次数"
    },
    "recv_pkt": {
      "desc": "已接收应用层协议控制报文数"
    },
    "endpoint_name": {
      "desc": "LwM2M 客户端 Endpoint Name"
    },
    "param_proto_ver": {
      "desc": "匹配客户端协议版本"
    },
    "reductions": {
      "desc": "进程已消耗 Reduction 数"
    },
    "param_gte_lifetime": {
      "desc": "匹配心跳时间大于等于指定值的 LwM2M 客户端"
    },
    "mqueue_len": {
      "desc": "客户端当前消息队列长度"
    }
  },
  "emqx_gateway_api_listeners": {
    "add_listener": {
      "desc": "为指定网关添加监听器。<br/>\n注：对于某网关不支持的监听器类型，该接口会返回 `400: BAD_REQUEST`。"
    },
    "add_listener_authn": {
      "desc": "为指定监听器开启认证器以实现客户端认证的能力。<br/>\n当某一监听器开启认证后，所有连接到该监听器的客户端会使用该认证器进行认证。"
    },
    "add_user": {
      "desc": "添加用户（仅支持 built_in_database 类型的认证器）"
    },
    "current_connections": {
      "desc": "当前连接数"
    },
    "delete_listener": {
      "desc": "删除指定监听器。被删除的监听器下所有已连接的客户端都会离线。"
    },
    "delete_listener_authn": {
      "desc": "移除指定监听器的认证器。"
    },
    "delete_user": {
      "desc": "删除用户（仅支持 built_in_database 类型的认证器）"
    },
    "get_listener": {
      "desc": "获取指定网关监听器的配置。"
    },
    "get_listener_authn": {
      "desc": "获取监听器的认证器配置。"
    },
    "get_user": {
      "desc": "获取用户信息（仅支持 built_in_database 类型的认证器）"
    },
    "import_users": {
      "desc": "导入用户（仅支持 built_in_database 类型的认证器）"
    },
    "list_listeners": {
      "desc": "获取网关监听器列表。该接口会返回监听器所有的配置（包括该监听器上的认证器），同时也会返回该监听器在集群中运行的状态。"
    },
    "list_users": {
      "desc": "获取用户列表（仅支持 built_in_database 类型的认证器）"
    },
    "listener_id": {
      "desc": "监听器 ID"
    },
    "listener_node_status": {
      "desc": "监听器在集群中每个节点上的状态"
    },
    "listener_status": {
      "desc": "监听器状态"
    },
    "node": {
      "desc": "节点名称"
    },
    "update_listener": {
      "desc": "更新某网关监听器的配置。被更新的监听器会执行重启，所有已连接到该监听器上的客户端都会被断开。"
    },
    "update_listener_authn": {
      "desc": "更新指定监听器的认证器配置，或停用/启用该认证器。"
    },
    "update_user": {
      "desc": "更新用户信息（仅支持 built_in_database 类型的认证器）"
    }
  },
  "emqx_gateway_schema": {
    "dtls_listener_acceptors": {
      "desc": "Acceptor 进程池大小。"
    },
    "dtls_listener_dtls_opts": {
      "desc": "DTLS Socket 配置"
    },
    "gateway_common_authentication": {
      "desc": "网关的认证器配置，对该网关下所以的监听器生效。如果每个监听器需要配置不同的认证器，需要配置监听器下的 <code>authentication</code> 字段。"
    },
    "gateway_common_clientinfo_override": {
      "desc": "ClientInfo 重写。"
    },
    "gateway_common_clientinfo_override_clientid": {
      "desc": "clientid 重写模板"
    },
    "gateway_common_clientinfo_override_password": {
      "desc": "password 重写模板"
    },
    "gateway_common_clientinfo_override_username": {
      "desc": "username 重写模板"
    },
    "gateway_common_enable": {
      "desc": "是否启用该网关"
    },
    "gateway_common_enable_stats": {
      "desc": "是否开启客户端统计"
    },
    "gateway_common_idle_timeout": {
      "desc": "客户端连接过程的空闲时间。该配置用于：\n  1. 一个新创建的客户端进程如果在该时间间隔内没有收到任何客户端请求，将被直接关闭。\n  2. 一个正在运行的客户进程如果在这段时间后没有收到任何客户请求，将进入休眠状态以节省资源。"
    },
    "gateway_common_listener_access_rules": {
      "desc": "配置监听器的访问控制规则。\n见：https://github.com/emqtt/esockd#allowdeny"
    },
    "gateway_common_listener_bind": {
      "desc": "监听器绑定的 IP 地址或端口。"
    },
    "gateway_common_listener_enable": {
      "desc": "是否启用该监听器。"
    },
    "gateway_common_listener_enable_authn": {
      "desc": "配置 <code>true</code> （默认值）启用客户端进行身份认证。\n配置 <code>false</code> 时，将不对客户端做任何认证。"
    },
    "gateway_common_listener_max_conn_rate": {
      "desc": "监听器支持的最大连接速率。"
    },
    "gateway_common_listener_max_connections": {
      "desc": "监听器支持的最大连接数。"
    },
    "gateway_mountpoint": {
      "desc": "发布或订阅时，在所有主题前增加前缀字符串。\n当消息投递给订阅者时，前缀字符串将从主题名称中删除。挂载点是用户可以用来实现不同监听器之间的消息路由隔离的一种方式。\n例如，如果客户端 A 在 `listeners.tcp.\\<name>.mountpoint` 设置为 `some_tenant` 的情况下订阅 `t`，\n则客户端实际上订阅了 `some_tenant/t` 主题。\n类似地，如果另一个客户端 B（连接到与客户端 A 相同的侦听器）向主题 `t` 发送消息，\n则该消息被路由到所有订阅了 `some_tenant/t` 的客户端，因此客户端 A 将收到该消息，带有 主题名称`t`。 设置为 `\"\"` 以禁用该功能。\n挂载点字符串中可用的变量：<br/>\n   - <code>${clientid}</code>：clientid<br/>\n   - <code>${username}</code>：用户名"
    },
    "listener_name_to_settings_map": {
      "desc": "从监听器名称到配置参数的映射。"
    },
    "ssl_listener_options": {
      "desc": "SSL Socket 配置。"
    },
    "tcp_listener_acceptors": {
      "desc": "Acceptor 进程池大小。"
    },
    "tcp_listener_proxy_protocol": {
      "desc": "是否开启 Proxy Protocol V1/2。当 EMQX 集群部署在 HAProxy 或 Nginx 后需要获取客户端真实 IP 时常用到该选项。参考：https://www.haproxy.com/blog/haproxy/proxy-protocol/"
    },
    "tcp_listener_proxy_protocol_timeout": {
      "desc": "接收 Proxy Protocol 报文头的超时时间。如果在超时内没有收到 Proxy Protocol 包，EMQX 将关闭 TCP 连接。"
    },
    "tcp_listener_tcp_opts": {
      "desc": "TCP Socket 配置。"
    },
    "tcp_listeners": {
      "desc": "配置 TCP 类型的监听器。"
    },
    "tcp_udp_listeners": {
      "desc": "监听器配置。"
    },
    "udp_listener_active_n": {
      "desc": "为 Socket 指定 {active, N} 选项。\n参见：https://erlang.org/doc/man/inet.html#setopts-2"
    },
    "udp_listener_buffer": {
      "desc": "Socket 在用户空间的缓冲区大小。"
    },
    "udp_listener_recbuf": {
      "desc": "Socket 在内核空间接收缓冲区的大小。"
    },
    "udp_listener_reuseaddr": {
      "desc": "允许重用本地处于 TIME_WAIT 的端口号。"
    },
    "udp_listener_sndbuf": {
      "desc": "Socket 在内核空间发送缓冲区的大小。"
    },
    "udp_listener_udp_opts": {
      "desc": "UDP Socket 配置。"
    },
    "udp_listeners": {
      "desc": "配置 UDP 类型的监听器。"
    }
  },
  "emqx_license_http_api": {
    "desc_license_info_api": {
      "desc": "获取许可证信息",
      "label": "许可证信息"
    },
    "desc_license_key_api": {
      "desc": "更新一个许可证密钥",
      "label": "更新许可证"
    }
  },
  "emqx_license_schema": {
    "connection_high_watermark_field": {
      "desc": "高水位线，连接数超过这个水位线时，系统会触发许可证连接配额使用告警",
      "label": "连接高水位"
    },
    "connection_low_watermark_field": {
      "desc": "低水位限制，低于此水位线时系统会清除连接配额使用告警",
      "label": "连接低水位线"
    },
    "key_field": {
      "desc": "许可证字符串",
      "label": "许可证字符串"
    },
    "license_root": {
      "desc": "EMQX企业许可证。\nEMQX 自带一个默认的试用许可证，默认试用许可允许最多接入 100 个连接，签发时间是 2023年1月9日，有效期是 5 年（1825 天）。若需要在生产环境部署，\n请访问 https://www.emqx.com/apply-licenses/emqx 来申请。",
      "label": "许可证"
    }
  },
  "emqx_limiter_schema": {
    "bucket_cfg": {
      "desc": "桶的配置",
      "label": "桶的配置"
    },
    "burst": {
      "desc": "突发速率。\n突发速率允许短时间内速率超过设置的速率值，突发速率 + 速率 = 当前桶能达到的最大速率值",
      "label": "突发速率"
    },
    "bytes_in": {
      "desc": "流入字节率控制器。\n这个是用来控制当前节点上的数据流入的字节率，每条消息将会消耗和其二进制大小等量的令牌，当达到最大速率后，会话将会被限速甚至被强制挂起一小段时间",
      "label": "流入字节率"
    },
    "capacity": {
      "desc": "该令牌桶的容量",
      "label": "容量"
    },
    "client": {
      "desc": "对桶的每个使用者的速率控制设置",
      "label": "每个使用者的限制"
    },
    "client_bucket_capacity": {
      "desc": "每个使用者的令牌容量上限",
      "label": "容量"
    },
    "connection": {
      "desc": "连接速率控制器。\n这个用来控制当前节点上的连接速率，当达到最大速率后，新的连接将会被拒绝",
      "label": "连接速率"
    },
    "divisible": {
      "desc": "申请的令牌数是否可以被分割",
      "label": "是否可分割"
    },
    "failure_strategy": {
      "desc": "当所有的重试都失败后的处理策略",
      "label": "失败策略"
    },
    "initial": {
      "desc": "桶中的初始令牌数",
      "label": "初始令牌数"
    },
    "internal": {
      "desc": "EMQX 内部功能所用限制器。"
    },
    "low_watermark": {
      "desc": "当桶中剩余的令牌数低于这个值，即使令牌申请成功了，也会被强制暂停一会儿",
      "label": "低水位线"
    },
    "max_retry_time": {
      "desc": "申请失败后，尝试重新申请的时长最大值",
      "label": "最大重试时间"
    },
    "message_in": {
      "desc": "流入速率控制器。\n这个用来控制当前节点上的消息流入速率，当达到最大速率后，会话将会被限速甚至被强制挂起一小段时间",
      "label": "消息流入速率"
    },
    "message_routing": {
      "desc": "消息派发速率控制器。\n这个用来控制当前节点内的消息派发速率，当达到最大速率后，新的推送将会被拒绝",
      "label": "消息派发"
    },
    "rate": {
      "desc": "桶的令牌生成速率",
      "label": "速率"
    }
  },
  "emqx_lwm2m_api": {
    "dataType": {
      "desc": "数据类型"
    },
    "lookup_resource": {
      "desc": "查看指定资源状态"
    },
    "name": {
      "desc": "资源名称"
    },
    "observe_resource": {
      "desc": "Observe/Un-Observe 指定资源"
    },
    "operations": {
      "desc": "资源可用操作列表"
    },
    "path": {
      "desc": "资源路径"
    },
    "read_resource": {
      "desc": "发送读指令到某资源"
    },
    "write_resource": {
      "desc": "发送写指令到某资源"
    }
  },
  "emqx_lwm2m_schema": {
    "lwm2m": {
      "desc": "LwM2M 网关配置。仅支持 v1.0.1 协议。"
    },
    "lwm2m_auto_observe": {
      "desc": "自动 Observe REGISTER 数据包的 Object 列表。"
    },
    "lwm2m_lifetime_max": {
      "desc": "允许 LwM2M 客户端允许设置的心跳最大值。"
    },
    "lwm2m_lifetime_min": {
      "desc": "允许 LwM2M 客户端允许设置的心跳最小值。"
    },
    "lwm2m_qmode_time_window": {
      "desc": "在QMode模式下，LwM2M网关认为网络链接有效的时间窗口的值。\n例如，在收到客户端的更新信息后，在这个时间窗口内的任何信息都会直接发送到LwM2M客户端，而超过这个时间窗口的所有信息都会暂时储存在内存中。"
    },
    "lwm2m_translators": {
      "desc": "LwM2M 网关订阅/发布消息的主题映射配置。"
    },
    "lwm2m_translators_command": {
      "desc": "下行命令主题。\n对于每个成功上线的新 LwM2M 客户端，网关会创建一个订阅关系来接收下行消息并将其发送给客户端。"
    },
    "lwm2m_translators_notify": {
      "desc": "用于发布来自 LwM2M 客户端的通知事件的主题。\n在成功 Observe 到 LwM2M 客户端的资源后，如果客户端报告任何资源状态的变化，网关将通过该主题发送通知事件。"
    },
    "lwm2m_translators_register": {
      "desc": "用于发布来自 LwM2M 客户端的注册事件的主题。"
    },
    "lwm2m_translators_response": {
      "desc": "用于网关发布来自 LwM2M 客户端的确认事件的主题。"
    },
    "lwm2m_translators_update": {
      "desc": "用于发布来自LwM2M客户端的更新事件的主题。"
    },
    "lwm2m_update_msg_publish_condition": {
      "desc": "发布UPDATE事件消息的策略。<br/>\n  - always: 只要收到 UPDATE 请求，就发送更新事件。<br/>\n  - contains_object_list: 仅当 UPDATE 请求携带 Object 列表时才发送更新事件。"
    },
    "lwm2m_xml_dir": {
      "desc": "LwM2M Resource 定义的 XML 文件目录路径。"
    },
    "translator": {
      "desc": "配置某网关客户端对于发布消息或订阅的主题和 QoS 等级。"
    },
    "translator_qos": {
      "desc": "QoS 等级"
    },
    "translator_topic": {
      "desc": "主题名称"
    }
  },
  "emqx_mgmt_api_alarms": {
    "activate_at": {
      "desc": "告警开始时间，使用 rfc3339 标准时间格式。"
    },
    "deactivate_at": {
      "desc": "告警结束时间，使用 rfc3339 标准时间格式。"
    },
    "delete_alarms_api": {
      "desc": "删除所有历史告警。"
    },
    "delete_alarms_api_response204": {
      "desc": "历史告警已成功清除。"
    },
    "details": {
      "desc": "告警详情，提供了更多的告警信息，主要提供给程序处理。"
    },
    "duration": {
      "desc": "表明告警已经持续了多久，单位：毫秒。"
    },
    "get_alarms_qs_activated": {
      "desc": "用于指定查询的告警类型，\n为 true 时返回当前激活的告警，为 false 时返回历史告警，默认为 false。"
    },
    "list_alarms_api": {
      "desc": "列出当前激活的告警或历史告警，由查询参数决定。"
    },
    "message": {
      "desc": "告警消息，以人类可读的方式描述告警内容。"
    },
    "name": {
      "desc": "告警名称，用于区分不同的告警。"
    },
    "node": {
      "desc": "触发此告警的节点名称。"
    }
  },
  "emqx_mgmt_api_banned": {
    "as": {
      "desc": "封禁方式，可以通过客户端 ID、用户名或者 IP 地址等方式进行封禁。",
      "label": "封禁方式"
    },
    "at": {
      "desc": "封禁的起始时间，格式为 rfc3339，默认为发起操作的时间。",
      "label": "封禁时间"
    },
    "by": {
      "desc": "封禁的发起者。",
      "label": "封禁发起者"
    },
    "create_banned_api": {
      "desc": "添加一个客户端 ID、用户名或者 IP 地址到黑名单。"
    },
    "create_banned_api_response400": {
      "desc": "错误的请求，可能是参数错误或封禁对象已存在等原因。"
    },
    "delete_banned_api": {
      "desc": "将一个客户端 ID、用户名或者 IP 地址从黑名单中删除。"
    },
    "delete_banned_api_response404": {
      "desc": "未在黑名单中找到该封禁对象。"
    },
    "list_banned_api": {
      "desc": "列出目前所有被封禁的客户端 ID、用户名和 IP 地址。"
    },
    "reason": {
      "desc": "封禁原因，记录当前对象被封禁的原因。",
      "label": "封禁原因"
    },
    "until": {
      "desc": "封禁的结束时间，格式为 rfc3339，默认值为发起操作的时间 + 1 年。",
      "label": "封禁结束时间"
    },
    "who": {
      "desc": "封禁对象，具体的客户端 ID、用户名或者 IP 地址。",
      "label": "封禁对象"
    }
  },
  "emqx_mgmt_api_key_schema": {
    "api_key": {
      "desc": "API 密钥， 可用于请求除管理 API 密钥及 Dashboard 用户管理 API 的其它接口",
      "label": "API 密钥"
    },
    "bootstrap_file": {
      "desc": "用于在启动 emqx 时，添加 API 密钥，其格式为：\n      ```\n      7e729ae70d23144b:2QILI9AcQ9BYlVqLDHQNWN2saIjBV4egr1CZneTNKr9CpK\n      ec3907f865805db0:Ee3taYltUKtoBVD9C3XjQl9C6NXheip8Z9B69BpUv5JxVHL\n      ```",
      "label": "API 密钥初始化文件"
    }
  },
  "emqx_mgmt_api_publish": {
    "error_message": {
      "desc": "失败的详细原因。"
    },
    "message_id": {
      "desc": "全局唯一的一个消息 ID，方便用于关联和追踪。"
    },
    "message_properties": {
      "desc": "PUBLISH 消息里的 Property 字段。"
    },
    "msg_content_type": {
      "desc": "内容类型标识符，以 UTF-8 格式编码的字符串，用来描述应用消息的内容，服务端必须把收到的应用消息中的内容类型原封不动的发送给所有的订阅者。"
    },
    "msg_correlation_data": {
      "desc": "对比数据标识符，服务端在收到应用消息时必须原封不动的把对比数据发送给所有的订阅者。对比数据只对请求消息(Request Message)的发送端和响应消息(Response Message)的接收端有意义。"
    },
    "msg_message_expiry_interval": {
      "desc": "消息过期间隔标识符，以秒为单位。当消失已经过期时，如果服务端还没有开始向匹配的订阅者投递该消息，则服务端会删除该订阅者的消息副本。如果不设置，则消息永远不会过期"
    },
    "msg_payload_format_indicator": {
      "desc": "载荷格式指示标识符，0 表示载荷是未指定格式的数据，相当于没有发送载荷格式指示；1 表示载荷是 UTF-8 编码的字符数据，载荷中的 UTF-8 数据必须是按照 Unicode 的规范和 RFC 3629 的标准要求进行编码的。"
    },
    "msg_response_topic": {
      "desc": "响应主题标识符， UTF-8 编码的字符串，用作响应消息的主题名。响应主题不能包含通配符，也不能包含多个主题，否则将造成协议错误。当存在响应主题时，消息将被视作请求报文。服务端在收到应用消息时必须将响应主题原封不动的发送给所有的订阅者。"
    },
    "msg_user_properties": {
      "desc": "指定 MQTT 消息的 User Property 键值对。注意，如果出现重复的键，只有最后一个会保留。"
    },
    "payload": {
      "desc": "MQTT 消息体。"
    },
    "payload_encoding": {
      "desc": "MQTT 消息体的编码方式，可以是 <code>base64</code> 或 <code>plain</code>。当设置为 <code>base64</code> 时，消息在发布前会先被解码。"
    },
    "publish_api": {
      "desc": "发布一个消息。<br/>\n可能的 HTTP 状态码如下：<br/>\n200: 消息被成功发送到至少一个订阅。<br/>\n202: 没有匹配到任何订阅。<br/>\n400: 消息编码错误，如非法主题，或 QoS 超出范围等。<br/>\n503: 服务重启等过程中导致转发失败。",
      "label": "发布一条信息"
    },
    "publish_bulk_api": {
      "desc": "批量发布一组消息。<br/>\n可能的 HTTP 状态码如下：<br/>\n200: 所有的消息都被成功发送到至少一个订阅。<br/>\n202: 至少有一个消息没有匹配到任何订阅。<br/>\n400: 至少有一个消息编码错误，如非法主题，或 QoS 超出范围等。<br/>\n503: 至少有一个小因为服务重启的原因导致转发失败。<br/>\n\n请求的 Body 或者 Body 中包含的某个消息无法通过 API 规范的类型检查时，HTTP 响应的消息与发布单个消息的 API\n <code>/publish</code> 是一样的。\n如果所有的消息都是合法的，那么 HTTP 返回的内容是一个 JSON 数组，每个元素代表了该消息转发的状态。",
      "label": "发布一批信息"
    },
    "qos": {
      "desc": "MQTT 消息的 QoS"
    },
    "reason_code": {
      "desc": "MQTT 消息发布的错误码，这些错误码也是 MQTT 规范中 PUBACK 消息可能携带的错误码。<br/>\n当前支持如下错误码：<br/>\n\n16(0x10)：没能匹配到任何订阅；<br/>\n131(0x81)：消息转发时发生错误，例如 EMQX 服务重启；<br/>\n144(0x90)：主题名称非法；<br/>\n151(0x97)：受到了速率限制，或者消息尺寸过大。全局消息大小限制可以通过配置项 <code>mqtt.max_packet_size</code> 来进行修改。<br/>\n注意：消息尺寸的是通过主题和消息体的字节数进行估算的。具体发布时所占用的字节数可能会稍大于这个估算的值。"
    },
    "retain": {
      "desc": "布尔型字段，用于表示该消息是否保留消息。"
    },
    "topic_name": {
      "desc": "主题名称"
    }
  },
  "emqx_mgmt_api_status": {
    "get_status_api": {
      "desc": "作为节点的健康检查。 返回一个纯文本的响应，描述节点的状态。\n\n如果 EMQX 应用程序已经启动并运行，返回状态代码 200，否则返回 503。\n\n这个API是在v5.0.10中引入的。\nGET `/status`端点（没有`/api/...`前缀）也是这个端点的一个别名，工作方式相同。 这个别名从v5.0.0开始就有了。",
      "label": "服务健康检查"
    },
    "get_status_response200": {
      "desc": "Node emqx@127.0.0.1 is started\nemqx is running"
    },
    "get_status_response503": {
      "desc": "Node emqx@127.0.0.1 is stopped\nemqx is not_running"
    }
  },
  "emqx_modules_schema": {
    "enable": {
      "desc": "是否开启该功能"
    },
    "max_delayed_messages": {
      "desc": "延迟消息的数量上限(0 代表无限)"
    },
    "rewrite": {
      "desc": "EMQX 的主题重写功能支持根据用户配置的规则在客户端订阅主题、发布消息、取消订阅的时候将 A 主题重写为 B 主题。\n重写规则分为 Pub 规则和 Sub 规则，Pub 规则匹配 PUSHLISH 报文携带的主题，Sub 规则匹配 SUBSCRIBE、UNSUBSCRIBE 报文携带的主题。\n每条重写规则都由主题过滤器、正则表达式、目标表达式三部分组成。\n在主题重写功能开启的前提下，EMQX 在收到诸如 PUBLISH 报文等带有主题的 MQTT 报文时，将使用报文中的主题去依次匹配配置文件中规则的主题过滤器部分，一旦成功匹配，则使用正则表达式提取主题中的信息，然后替换至目标表达式以构成新的主题。\n目标表达式中可以使用 `$N` 这种格式的变量匹配正则表达中提取出来的元素，`$N` 的值为正则表达式中提取出来的第 N 个元素，比如 `$1` 即为正则表达式提取的第一个元素。\n需要注意的是，EMQX 使用倒序读取配置文件中的重写规则，当一条主题可以同时匹配多条主题重写规则的主题过滤器时，EMQX 仅会使用它匹配到的第一条规则进行重写，如果该条规则中的正则表达式与 MQTT 报文主题不匹配，则重写失败，不会再尝试使用其他的规则进行重写。\n因此用户在使用时需要谨慎的设计 MQTT 报文主题以及主题重写规则。",
      "label": "主题重写"
    },
    "tr_action": {
      "desc": "主题重写在哪种操作上生效：\n  - `subscribe`：订阅时重写主题；\n  - `publish`：发布时重写主题；\n  -`all`：全部重写主题",
      "label": "Action"
    },
    "tr_dest_topic": {
      "desc": "目标主题。",
      "label": "目标主题"
    },
    "tr_re": {
      "desc": "正则表达式"
    },
    "tr_source_topic": {
      "desc": "源主题，客户端业务指定的主题",
      "label": "源主题"
    }
  },
  "emqx_mqttsn_schema": {
    "mqttsn": {
      "desc": "MQTT-SN 网关配置。当前实现仅支持 v1.2 版本"
    },
    "mqttsn_broadcast": {
      "desc": "是否周期性广播 ADVERTISE 消息"
    },
    "mqttsn_enable_qos3": {
      "desc": "是否允许无连接的客户端发送 QoS 等于 -1 的消息。\n该功能主要用于支持轻量的 MQTT-SN 客户端实现，它不会向网关建立连接，注册主题，也不会发起订阅；它只使用 QoS 为 -1 来发布消息"
    },
    "mqttsn_gateway_id": {
      "desc": "MQTT-SN 网关 ID。\n当 <code>broadcast</code> 打开时，MQTT-SN 网关会使用该 ID 来广播 ADVERTISE 消息"
    },
    "mqttsn_predefined": {
      "desc": "预定义主题列表。\n预定义的主题列表，是一组 主题 ID 和 主题名称 的映射关系。使用预先定义的主题列表，可以减少 MQTT-SN 客户端和网关对于固定主题的注册请求"
    },
    "mqttsn_predefined_id": {
      "desc": "主题 ID。范围：1-65535"
    },
    "mqttsn_predefined_topic": {
      "desc": "主题名称。注：不支持通配符"
    },
    "mqttsn_subs_resume": {
      "desc": "在会话被重用后，网关是否主动向客户端注册对已订阅主题名称"
    }
  },
  "emqx_plugins_schema": {
    "check_interval": {
      "desc": "检查间隔：检查集群中插件的状态是否一致，<br/>\n如果连续3次检查结果不一致，则报警。"
    },
    "enable": {
      "desc": "设置为“true”以启用此插件",
      "label": "启用"
    },
    "install_dir": {
      "desc": "插件安装包的目录，出于安全考虑，该目录应该值允许 <code>emqx</code>，或用于运行 EMQX 服务的用户拥有写入权限。",
      "label": "安装目录"
    },
    "name_vsn": {
      "desc": "插件的名称{name}-{version}。<br/>\n它应该与插件的发布包名称一致，如my_plugin-0.1.0。",
      "label": "名称-版本"
    },
    "plugins": {
      "desc": "管理EMQX插件。<br/>\n插件可以是EMQX安装包中的一部分，也可以是一个独立的安装包。<br/>\n独立安装的插件称为“外部插件”。",
      "label": "插件"
    },
    "state": {
      "desc": "描述插件的状态",
      "label": "插件状态"
    },
    "states": {
      "desc": "一组插件的状态。插件将按照定义的顺序启动",
      "label": "插件启动顺序及状态"
    }
  },
  "emqx_prometheus_schema": {
    "enable": {
      "desc": "开启或关闭 Prometheus 数据推送"
    },
    "headers": {
      "desc": "推送到 Push Gateway 的 HTTP Headers 列表。<br/>\n例如，<code> { Authorization = \"some-authz-tokens\"}</code>"
    },
    "interval": {
      "desc": "数据推送间隔"
    },
    "job_name": {
      "desc": "推送到 Push Gateway 的 Job 名称。可用变量为：<br/>\n- ${name}: EMQX 节点的名称。\n- ${host}: EMQX 节点主机名。\n例如，当 EMQX 节点名为 <code>emqx@127.0.0.1</code> 则 name 变量的值为 <code>emqx</code>，host 变量的值为 <code>127.0.0.1</code>。<br/>\n默认值为: <code>${name}/instance/${name}~${host}</code>"
    },
    "mnesia_collector": {
      "desc": "开启或关闭 Mnesia 采集器, 使用 mnesia:system_info/1 收集 Mnesia 相关指标"
    },
    "prometheus": {
      "desc": "Prometheus 监控数据推送",
      "label": "Prometheus"
    },
    "push_gateway_server": {
      "desc": "Prometheus 服务器地址"
    },
    "vm_dist_collector": {
      "desc": "开启或关闭 VM 分布采集器，收集 Erlang 分布机制中涉及的套接字和进程的信息。"
    },
    "vm_memory_collector": {
      "desc": "开启或关闭 VM 内存采集器, 使用 erlang:memory/0 收集 Erlang 虚拟机动态分配的内存信息，同时提供基本的 (D)ETS 统计信息"
    },
    "vm_msacc_collector": {
      "desc": "开启或关闭 VM msacc 采集器, 使用 erlang:statistics(microstate_accounting) 收集微状态计数指标"
    },
    "vm_statistics_collector": {
      "desc": "开启或关闭 VM 统计采集器, 使用 erlang:statistics/1 收集 Erlang VM 相关指标"
    },
    "vm_system_info_collector": {
      "desc": "开启或关闭 VM 系统信息采集器, 使用 erlang:system_info/1 收集 Erlang VM 相关指标"
    }
  },
  "emqx_psk_schema": {
    "chunk_size": {
      "desc": "将 PSK 文件导入到内建数据时每个块的大小"
    },
    "enable": {
      "desc": "是否开启 TLS PSK 支持"
    },
    "init_file": {
      "desc": "如果设置了初始化文件，EMQX 将在启动时从初始化文件中导入 PSK 信息到内建数据库中。\n这个文件需要按行进行组织，每一行必须遵守如下格式: <code>PSKIdentity:SharedSecret</code>\n例如: <code>mydevice1:c2VjcmV0</code>"
    },
    "psk_authentication": {
      "desc": "此配置用于启用 TLS-PSK 身份验证。\n\nPSK 是 “Pre-Shared-Keys” 的缩写。\n\n注意: 确保 SSL 监听器仅启用了 'tlsv1.2'，并且配置了PSK 密码套件，例如 'RSA-PSK-AES256-GCM-SHA384'。\n\n可以通过查看监听器中的 SSL 选项，了解更多详细信息。\n\n可以通过配置 'init_file' 来设置初始化的 ID 和 密钥"
    },
    "separator": {
      "desc": "PSK 文件中 <code>PSKIdentity</code> 和 <code>SharedSecret</code> 之间的分隔符"
    }
  },
  "emqx_resource_schema": {
    "auto_restart_interval": {
      "desc": "资源断开以后，自动重连的时间间隔。",
      "label": "自动重连间隔"
    },
    "batch_size": {
      "desc": "最大批量请求大小。如果设为1，则无批处理。",
      "label": "最大批量请求大小"
    },
    "batch_time": {
      "desc": "在较低消息率情况下尝试累积批量输出时的最大等待间隔，以提高资源的利用率。",
      "label": "批量等待最大间隔"
    },
    "creation_opts": {
      "desc": "资源启动相关的选项。",
      "label": "资源启动选项"
    },
    "enable_batch": {
      "desc": "启用批量模式。",
      "label": "启用批量模式"
    },
    "enable_queue": {
      "desc": "启用磁盘缓存队列（仅对 egress 方向桥接有用）。",
      "label": "启用磁盘缓存队列"
    },
    "health_check_interval": {
      "desc": "健康检查间隔。",
      "label": "健康检查间隔"
    },
    "inflight_window": {
      "desc": "请求飞行队列窗口大小。当请求模式为异步时，如果需要严格保证来自同一 MQTT 客户端的消息有序，则必须将此值设为 1。",
      "label": "请求飞行队列窗口"
    },
    "max_queue_bytes": {
      "desc": "每个缓存 worker 允许使用的最大字节数。",
      "label": "缓存队列最大长度"
    },
    "query_mode": {
      "desc": "请求模式。可选 '同步/异步'，默认为'异步'模式。",
      "label": "请求模式"
    },
    "request_timeout": {
      "desc": "从请求进入缓冲区开始计时，如果请求在规定的时间内仍停留在缓冲区内或者已发送但未能及时收到响应或确认，该请求将被视为过期。",
      "label": "请求超期"
    },
    "resource_opts": {
      "desc": "资源相关的选项。",
      "label": "资源选项"
    },
    "resume_interval": {
      "desc": "在发送失败后尝试重传飞行窗口中的请求的时间间隔。",
      "label": "重试时间间隔"
    },
    "start_after_created": {
      "desc": "是否在创建资源后立即启动资源。",
      "label": "创建后立即启动"
    },
    "start_timeout": {
      "desc": "在回复资源创建请求前等待资源进入健康状态的时间。",
      "label": "启动超时时间"
    },
    "worker_pool_size": {
      "desc": "缓存队列 worker 数量。仅对 egress 类型的桥接有意义。当桥接仅有 ingress 方向时，可设置为 0，否则必须大于 0。",
      "label": "缓存池大小"
    }
  },
  "emqx_retainer_api": {
    "config_content": {
      "desc": "配置内容"
    },
    "config_not_found": {
      "desc": "配置不存在"
    },
    "delete_matching_api": {
      "desc": "删除对应的消息"
    },
    "from_clientid": {
      "desc": "发布者的 ClientID"
    },
    "from_username": {
      "desc": "发布者的用户名"
    },
    "get_config_api": {
      "desc": "查看配置内容"
    },
    "list_retained_api": {
      "desc": "查看保留消息列表"
    },
    "lookup_api": {
      "desc": "通过不带通配符的主题查看对应的保留消息"
    },
    "message_detail": {
      "desc": "消息详情"
    },
    "message_not_exist": {
      "desc": "消息不存在"
    },
    "msgid": {
      "desc": "消息 ID"
    },
    "payload": {
      "desc": "消息内容"
    },
    "publish_at": {
      "desc": "消息发送时间, RFC 3339 格式"
    },
    "qos": {
      "desc": "QoS"
    },
    "retained_list": {
      "desc": "保留消息列表"
    },
    "topic": {
      "desc": "主题"
    },
    "unsupported_backend": {
      "desc": "不支持的后端"
    },
    "update_config_failed": {
      "desc": "配置更新失败"
    },
    "update_config_success": {
      "desc": "配置更新成功"
    },
    "update_retainer_api": {
      "desc": "更新配置"
    }
  },
  "emqx_retainer_schema": {
    "backend": {
      "desc": "保留消息的存储后端"
    },
    "batch_deliver_limiter": {
      "desc": "批量发送的限流器的名称。\n限流器可以用来防止短时间内向客户端发送太多的消息，从而避免过多的消息导致客户端队列堵塞甚至崩溃。\n这个名称需要是指向 `limiter.batch` 下的一个真实存在的限流器。\n如果这个字段为空，则不使用限流器。"
    },
    "batch_deliver_number": {
      "desc": "批量派发时每批的数量。0 代表一次性全部派发"
    },
    "batch_read_number": {
      "desc": "从存储后端批量加载时的每批数量上限，0 代表一次性读取"
    },
    "enable": {
      "desc": "是否开启消息保留功能"
    },
    "flow_control": {
      "desc": "流控设置"
    },
    "max_payload_size": {
      "desc": "消息大小最大值"
    },
    "max_retained_messages": {
      "desc": "消息保留的数量上限。0 表示无限"
    },
    "mnesia_config_storage_type": {
      "desc": "选择消息是存放在磁盘还是内存中"
    },
    "mnesia_config_type": {
      "desc": "后端类型"
    },
    "msg_clear_interval": {
      "desc": "消息清理间隔。0 代表不进行清理"
    },
    "msg_expiry_interval": {
      "desc": "消息保留时间。0 代表永久保留"
    },
    "stop_publish_clear_msg": {
      "desc": "是否不发送保留消息的清理消息，在 MQTT 5.0 中如果一条保留消息的消息体为空，则会清除掉之前存储\n的对应的保留消息，通过这个值控制是否停止发送清理消息"
    }
  },
  "emqx_rewrite_api": {
    "list_topic_rewrite_api": {
      "desc": "列出全部主题重写规则"
    },
    "update_topic_rewrite_api": {
      "desc": "更新全部主题重写规则"
    },
    "update_topic_rewrite_api_response413": {
      "desc": "超出主题重写规则数量上限"
    }
  },
  "emqx_rule_api_schema": {
    "event_action": {
      "desc": "订阅或发布",
      "label": "订阅或发布"
    },
    "event_payload": {
      "desc": "消息负载",
      "label": "消息负载"
    },
    "metrics_actions_failed_out_of_service": {
      "desc": "由于输出停止服务而导致规则调用输出失败的次数。 例如，桥接被禁用或停止。",
      "label": "调用输出失败次数"
    },
    "metrics_actions_failed_unknown": {
      "desc": "由于未知错误，规则调用输出失败的次数。",
      "label": "调用输出失败次数"
    },
    "event_server": {
      "desc": "MQTT broker的 IP 地址（或主机名）和端口，采用 IP:Port 格式",
      "label": "服务器 IP 地址和端口"
    },
    "metrics_actions_total": {
      "desc": "规则调用输出的次数。 该值可能是“sql.matched”的几倍，具体取决于规则输出的数量。",
      "label": "调用输出次数"
    },
    "event_ctx_disconnected_da": {
      "desc": "客户端断开连接的时刻",
      "label": "客户端断开连接时刻"
    },
    "event_topic": {
      "desc": "消息主题",
      "label": "消息主题"
    },
    "event_peername": {
      "desc": "对等客户端的 IP 地址和端口",
      "label": "IP 地址和端口"
    },
    "metrics_sql_passed": {
      "desc": "SQL 通过的次数",
      "label": "SQL 通过"
    },
    "test_context": {
      "desc": "测试事件的上下文",
      "label": "事件上下文"
    },
    "node_node": {
      "desc": "节点名字",
      "label": "节点名字"
    },
    "event_from_clientid": {
      "desc": "事件来源客户端的 ID",
      "label": "客户端 ID"
    },
    "event_keepalive": {
      "desc": "保持连接",
      "label": "保持连接"
    },
    "event_connected_at": {
      "desc": "客户端连接完成时的时刻",
      "label": "连接完成时的时刻"
    },
    "metrics_sql_failed_exception": {
      "desc": "SQL 由于执行异常而失败的次数。 这可能是因为调用 SQL 函数时崩溃，或者试图对未定义的变量进行算术运算",
      "label": "SQL 执行异常"
    },
    "event_from_username": {
      "desc": "事件来源客户端的用户名",
      "label": "用户名"
    },
    "event_ctx_connack_reason_code": {
      "desc": "错误码",
      "label": "错误码"
    },
    "rs_description": {
      "desc": "描述",
      "label": "描述"
    },
    "rule_id": {
      "desc": "规则的 ID",
      "label": "规则 ID"
    },
    "rs_event": {
      "desc": "事件主题",
      "label": "事件主题"
    },
    "event_sockname": {
      "desc": "本地监听的 IP 地址和端口",
      "label": "IP 地址和端口"
    },
    "event_qos": {
      "desc": "消息的 QoS",
      "label": "消息 QoS"
    },
    "event_mountpoint": {
      "desc": "挂载点",
      "label": "挂载点"
    },
    "rs_title": {
      "desc": "标题",
      "label": "标题"
    },
    "ri_metrics": {
      "desc": "规则的计数器",
      "label": "规则计数器"
    },
    "event_retain": {
      "desc": "是否是保留消息",
      "label": "保留消息"
    },
    "event_event_type": {
      "desc": "事件类型",
      "label": "事件类型"
    },
    "event_expiry_interval": {
      "desc": "到期间隔",
      "label": "到期间隔"
    },
    "metrics_sql_matched": {
      "desc": "SQL 的 FROM 子句匹配的次数。",
      "label": "命中数"
    },
    "event_clientid": {
      "desc": "客户端 ID",
      "label": "客户端 ID"
    },
    "metrics_actions_success": {
      "desc": "规则成功调用输出的次数。",
      "label": "成功调用输出次数"
    },
    "metrics_actions_failed": {
      "desc": "规则调用输出失败的次数。",
      "label": "调用输出失败次数"
    },
    "metrics_sql_matched_rate": {
      "desc": "命中速率，次/秒",
      "label": "Matched Rate"
    },
    "event_proto_ver": {
      "desc": "协议版本",
      "label": "协议版本"
    },
    "event_publish_received_at": {
      "desc": "消息被接受的时间",
      "label": "消息被接受的时间"
    },
    "metrics_sql_matched_rate_last5m": {
      "desc": "5分钟平均命中速率，次/秒",
      "label": "平均命中速率"
    },
    "event_is_bridge": {
      "desc": "是否桥接",
      "label": "是否桥接"
    },
    "event_authz_source": {
      "desc": "缓存，插件或者默认值",
      "label": "认证源"
    },
    "metrics_sql_failed_unknown": {
      "desc": "由于未知错误导致 SQL 失败的次数。",
      "label": "SQL 未知错误"
    },
    "metrics_sql_failed": {
      "desc": "SQL 失败的次数",
      "label": "SQL 失败"
    },
    "event_ctx_dropped": {
      "desc": "消息被丢弃的原因",
      "label": "丢弃原因"
    },
    "root_rule_test": {
      "desc": "用于规则测试的 Schema",
      "label": "用于规则测试的 Schema"
    },
    "rs_test_columns": {
      "desc": "测试列",
      "label": "测试列"
    },
    "event_peerhost": {
      "desc": "对等客户端的 IP 地址",
      "label": "对等客户端的 IP"
    },
    "event_proto_name": {
      "desc": "协议名称",
      "label": "协议名称"
    },
    "root_rule_events": {
      "desc": "用于事件的 Schema",
      "label": "用于规则事件的 Schema"
    },
    "rs_sql_example": {
      "desc": "SQL 例子",
      "label": "SQL 例子"
    },
    "metrics_sql_matched_rate_max": {
      "desc": "最大命中速率，次/秒",
      "label": "最大命中速率"
    },
    "event_clean_start": {
      "desc": "清除会话",
      "label": "清除会话"
    },
    "ri_created_at": {
      "desc": "规则创建时间",
      "label": "规则创建时间"
    },
    "event_dup": {
      "desc": "MQTT 消息的 DUP 标志",
      "label": "DUP 标志"
    },
    "ri_from": {
      "desc": "规则指定的主题",
      "label": "规则指定的主题"
    },
    "ri_node_metrics": {
      "desc": "每个节点的规则计数器",
      "label": "每个节点规则计数器"
    },
    "root_rule_creation": {
      "desc": "用于创建规则的 Schema",
      "label": "用于创建规则的 Schema"
    },
    "event_result": {
      "desc": "允许或禁止",
      "label": "认证结果"
    },
    "event_id": {
      "desc": "消息 ID",
      "label": "消息 ID"
    },
    "event_username": {
      "desc": "用户名",
      "label": "用户名"
    },
    "root_rule_info": {
      "desc": "用于规则信息的 Schema",
      "label": "用于规则信息的 Schema"
    },
    "rs_columns": {
      "desc": "列",
      "label": "列"
    },
    "test_sql": {
      "desc": "测试的 SQL",
      "label": "测试 SQL"
    },
    "event_ctx_disconnected_reason": {
      "desc": "断开连接的原因",
      "label": "断开连接原因"
    }
  },
  "emqx_rule_engine_api": {
    "api1": {
      "desc": "列出所有规则",
      "label": "列出所有规则"
    },
    "api1_enable": {
      "desc": "根据规则是否开启条件过滤"
    },
    "api1_from": {
      "desc": "根据规则来源 Topic 过滤, 需要完全匹配"
    },
    "api1_like_description": {
      "desc": "根据规则描述过滤, 使用子串模糊匹配"
    },
    "api1_like_from": {
      "desc": "根据规则来源 Topic 过滤, 使用子串模糊匹配"
    },
    "api1_like_id": {
      "desc": "根据规则 id 过滤, 使用子串模糊匹配"
    },
    "api1_match_from": {
      "desc": "根据规则来源 Topic 过滤, 使用 MQTT Topic 匹配"
    },
    "api2": {
      "desc": "通过指定 ID 创建规则",
      "label": "通过指定 ID 创建规则"
    },
    "api3": {
      "desc": "列出所有能被规则使用的事件",
      "label": "列出所有能被规则使用的事件"
    },
    "api4": {
      "desc": "通过 ID 查询规则",
      "label": "查询规则"
    },
    "api4_1": {
      "desc": "通过给定的 Id 获得规则的指标数据",
      "label": "获得指标数据"
    },
    "api5": {
      "desc": "通过 ID 更新集群里所有节点上的规则",
      "label": "更新集群规则"
    },
    "api6": {
      "desc": "通过 ID 删除集群里所有节点上的规则",
      "label": "删除集群规则"
    },
    "api7": {
      "desc": "重置规则计数",
      "label": "重置规则计数"
    },
    "api8": {
      "desc": "测试一个规则",
      "label": "测试规则"
    },
    "desc9": {
      "desc": "列出所有规则",
      "label": "列出所有规则"
    }
  },
  "emqx_rule_engine_schema": {
    "console_function": {
      "desc": "将输出打印到控制台",
      "label": "控制台函数"
    },
    "desc_builtin_action_console": {
      "desc": "配置打印到控制台",
      "label": "配置打印到控制台"
    },
    "desc_builtin_action_republish": {
      "desc": "配置重新发布。",
      "label": "配置重新发布"
    },
    "desc_republish_args": {
      "desc": "内置 'republish' 动作的参数。\n可以在参数中使用变量。\n变量是规则中选择的字段。 例如规则 SQL 定义如下：\n<code>\n    SELECT clientid, qos, payload FROM \"t/1\"\n</code>\n然后有 3 个变量可用：<code>clientid</code>、<code>qos</code> 和 <code>payload</code>。 如果我们将参数设置为：\n<code>\n    {\n        topic = \"t/${clientid}\"\n        qos = \"${qos}\"\n        payload = \"msg: ${payload}\"\n    }\n</code>\n当收到一条消息 payload = `hello`, qos = 1, clientid = `Steve` 时，将重新发布一条新的 MQTT 消息到主题 `t/Steve`\n消息内容为 payload = `msg: hello`, and `qos = 1",
      "label": "重新发布参数"
    },
    "desc_rule_engine": {
      "desc": "配置 EMQX 规则引擎。",
      "label": "配置规则引擎"
    },
    "desc_rules": {
      "desc": "配置规则",
      "label": "配置规则"
    },
    "desc_user_provided_function": {
      "desc": "配置用户函数",
      "label": "配置用户函数"
    },
    "republish_args_payload": {
      "desc": "要重新发布的消息的有效负载。允许使用带有变量的模板，请参阅“republish_args”的描述。\n默认为 ${payload}。 如果从所选结果中未找到变量 ${payload}，则使用字符串 \"undefined\"。",
      "label": "消息负载"
    },
    "republish_args_qos": {
      "desc": "要重新发布的消息的 qos。允许使用带有变量的模板，请参阅“republish_args”的描述。\n默认为 ${qos}。 如果从规则的选择结果中没有找到变量 ${qos}，则使用 0。",
      "label": "消息 QoS 等级"
    },
    "republish_args_retain": {
      "desc": "要重新发布的消息的“保留”标志。允许使用带有变量的模板，请参阅“republish_args”的描述。\n默认为 ${retain}。 如果从所选结果中未找到变量 ${retain}，则使用 false。",
      "label": "保留消息标志"
    },
    "republish_args_topic": {
      "desc": "重新发布消息的目标主题。\n允许使用带有变量的模板，请参阅“republish_args”的描述。",
      "label": "目标主题"
    },
    "republish_args_user_properties": {
      "desc": "指定使用哪个变量来填充 MQTT 消息的 User-Property 列表。这个变量的值必须是一个 map 类型。\n可以设置成 <code>${pub_props.'User-Property'}</code> 或者\n使用 <code>SELECT *,pub_props.'User-Property' as user_properties</code> 来把源 MQTT 消息\n的 User-Property 列表用于填充。\n也可以使用 <code>map_put</code> 函数来添加新的 User-Property，\n<code>map_put('my-prop-name', 'my-prop-value', user_properties) as user_properties</code>\n注意：MQTT 协议允许一个消息中出现多次同一个 property 名，但是 EMQX 的规则引擎不允许。"
    },
    "republish_function": {
      "desc": "将消息重新发布为新的 MQTT 消息",
      "label": "重新发布函数"
    },
    "rule_engine_ignore_sys_message": {
      "desc": "当设置为“true”（默认）时，规则引擎将忽略发布到 $SYS 主题的消息。",
      "label": "忽略系统消息"
    },
    "rule_engine_jq_function_default_timeout": {
      "desc": "规则引擎内建函数 `jq` 默认时间限制",
      "label": "规则引擎 jq 函数时间限制"
    },
    "rule_engine_jq_implementation_module": {
      "desc": "jq 规则引擎功能的实现模块。可用的两个选项是 jq_nif 和 jq_port。jq_nif 使用 Erlang NIF 库访问 jq 库，而 jq_port 使用基于 Erlang Port 的实现。jq_nif 方式（默认选项）是这两个选项中最快的实现，但 jq_port 方式更安全，因为这种情况下 jq 程序不会在 Erlang VM 进程中执行。",
      "label": "JQ 实现模块"
    },
    "rule_engine_rules": {
      "desc": "规则",
      "label": "规则"
    },
    "rules_actions": {
      "desc": "规则的动作列表。\n动作可以是指向 EMQX bridge 的引用，也可以是一个指向函数的对象。\n我们支持一些内置函数，如“republish”和“console”，我们还支持用户提供的函数，它的格式为：“{module}:{function}”。\n列表中的动作按顺序执行。这意味着如果其中一个动作执行缓慢，则以下所有动作都不会被执行直到它返回。\n如果其中一个动作崩溃，在它之后的所有动作仍然会被按照原始顺序执行。\n如果运行动作时出现任何错误，则会出现错误消息，并且相应的计数器会增加。",
      "label": "动作列表"
    },
    "rules_description": {
      "desc": "规则的描述",
      "label": "规则描述"
    },
    "rules_enable": {
      "desc": "启用或禁用规则引擎",
      "label": "启用或禁用规则引擎"
    },
    "rules_metadata": {
      "desc": "规则的元数据，不要手动修改",
      "label": "规则的元数据"
    },
    "rules_name": {
      "desc": "规则名字",
      "label": "规则名字"
    },
    "rules_sql": {
      "desc": "用于处理消息的 SQL 。\n示例：<code>SELECT * FROM \"test/topic\" WHERE payload.x = 1</code>",
      "label": "规则 SQL"
    },
    "user_provided_function_args": {
      "desc": "用户提供的参数将作为函数 module:function/3 的第三个参数，\n请检查源文件：<code>apps/emqx_rule_engine/src/emqx_rule_actions.erl</code> 中的示例函数 <code>console</code> 和<code>republish</code> 。",
      "label": "用户提供函数的参数"
    },
    "user_provided_function_function": {
      "desc": "用户提供的函数。 格式应为：'{module}:{function}'。\n其中 {module} 是 Erlang 回调模块， {function} 是 Erlang 函数。\n要编写自己的函数，请检查源文件：<code>apps/emqx_rule_engine/src/emqx_rule_actions.erl</code> 中的示例函数 <code>console</code> 和<code>republish</code> 。",
      "label": "用户提供的函数"
    }
  },
  "emqx_schema": {
    "fields_mqtt_quic_listener_peer_unidi_stream_count": {
      "desc": "允许对端打开的单向流的数量",
      "label": "对端单向流的数量"
    },
    "fields_authorization_no_match": {
      "desc": "如果用户或客户端不匹配ACL规则，或者从可配置授权源(比如内置数据库、HTTP API 或 PostgreSQL 等。)内未找\n到此类用户或客户端时，模式的认访问控制操作。\n在“授权”中查找更多详细信息。",
      "label": "未匹时的默认授权动作"
    },
    "sysmon_top_db_hostname": {
      "desc": "收集数据点的 PostgreSQL 数据库的主机名。",
      "label": "数据库主机名"
    },
    "zones": {
      "desc": "<code>zone</code> 是按<code>name</code> 分组的一组配置。\n对于灵活的配置映射，可以将 <code>name</code> 设置为侦听器的 <code>zone</code> 配置。\n注：名为 <code>default</code> 的内置区域是自动创建的，无法删除。"
    },
    "fields_mqtt_quic_listener_certfile": {
      "desc": "证书文件。在 5.1 中会被废弃，使用 .ssl_options.certfile 代替。",
      "label": "证书文件"
    },
    "fields_rate_limit_conn_bytes_in": {
      "desc": "限制 MQTT 连接接收数据包的速率。 速率以每秒的数据包字节数计算。",
      "label": "数据包速率"
    },
    "crl_cache_capacity": {
      "desc": "缓存中可容纳的 CRL URL 的最大数量。 如果缓存的容量已满，并且必须获取一个新的 URL，那么它将驱逐缓存中插入的最老的 URL。",
      "label": "CRL 缓存容量"
    },
    "alarm_actions": {
      "desc": "警报激活时触发的动作。<br/>目前，支持以下操作：<code>log</code> 和 <code>publish</code>.\n<code>log</code> 将告警写入日志 (控制台或者文件).\n<code>publish</code> 将告警作为 MQTT 消息发布到系统主题:\n<code>$SYS/brokers/emqx@xx.xx.xx.x/alarms/activate</code> and\n<code>$SYS/brokers/emqx@xx.xx.xx.x/alarms/deactivate</code>",
      "label": "告警动作"
    },
    "base_listener_max_connections": {
      "desc": "监听器允许的最大并发连接数。",
      "label": "最大并发连接数"
    },
    "mqtt_peer_cert_as_username": {
      "desc": "使用对端证书中的 CN、DN 字段或整个证书内容来作为用户名；仅适用于 TLS 连接。\n目前支持：\n- <code>cn</code>: 取证书的 CN 字段\n- <code>dn</code>: 取证书的 DN 字段\n- <code>crt</code>: 取 <code>DER</code> 或 <code>PEM</code> 的证书内容\n- <code>pem</code>: 将 <code>DER</code> 证书转换为 <code>PEM</code> 格式作为用户名\n- <code>md5</code>: 取 <code>DER</code> 或 <code>PEM</code> 证书内容的 MD5 值",
      "label": "对端证书作为用户名"
    },
    "fields_cache_enable": {
      "desc": "启用或禁用授权缓存。",
      "label": "启用或禁用授权缓存"
    },
    "fields_mqtt_quic_listener_disconnect_timeout_ms": {
      "desc": "在判定路径无效和断开连接之前，要等待多长时间的ACK。默认：16000",
      "label": "断开连接超时 毫秒"
    },
    "mqtt_max_topic_alias": {
      "desc": "允许的最大主题别名数，0 表示不支持主题别名。",
      "label": "最大主题别名"
    },
    "common_ssl_opts_schema_user_lookup_fun": {
      "desc": "用于查找预共享密钥（PSK）标识的 EMQX 内部回调。",
      "label": "SSL PSK 用户回调"
    },
    "fields_listeners_wss": {
      "desc": "HTTPS websocket 监听器。",
      "label": "HTTPS websocket 监听器"
    },
    "sysmon_top_max_procs": {
      "desc": "当 VM 中的进程数超过此值时，停止收集数据。",
      "label": "最大进程数"
    },
    "mqtt_use_username_as_clientid": {
      "desc": "是否使用用户名作为客户端 ID。\n此设置的作用时间晚于 <code>对端证书作为用户名</code> 和 <code>对端证书作为客户端 ID</code>。",
      "label": "用户名作为客户端 ID"
    },
    "mqtt_max_qos_allowed": {
      "desc": "允许的最大 QoS 等级。",
      "label": "最大 QoS"
    },
    "fields_mqtt_quic_listener_max_binding_stateless_operations": {
      "desc": "在任何时候可以在一个绑定上排队的无状态操作的最大数量。默认值：100",
      "label": "最大绑定无状态操作"
    },
    "fields_mqtt_quic_listener_stream_recv_buffer_default": {
      "desc": "流的初始缓冲区大小。默认：4096",
      "label": "流媒体接收缓冲区默认值"
    },
    "fields_mqtt_quic_listener_pacing_enabled": {
      "desc": "有节奏的发送，以避免路径上的缓冲区过度填充。默认值：1（已启用）",
      "label": "启用节奏发送"
    },
    "mqtt_max_subscriptions": {
      "desc": "允许每个客户端建立的最大订阅数量。",
      "label": "最大订阅数量"
    },
    "persistent_session_builtin_messages_table": {
      "desc": "用于内建消息表的性能调优参数。",
      "label": "持久化消息"
    },
    "sysmon_os_cpu_low_watermark": {
      "desc": "在解除相应警报之前可以使用多少系统 CPU 的阈值，以系统CPU负载的百分比表示。",
      "label": "CPU 低水位线"
    },
    "fields_mqtt_quic_listener_tls_server_max_send_buffer": {
      "desc": "缓冲多少TLS数据。 默认值：8192",
      "label": "TLS 服务器最大发送缓冲区"
    },
    "base_listener_bind": {
      "desc": "监听套接字的 IP 地址和端口。",
      "label": "IP 地址和端口"
    },
    "server_ssl_opts_schema_handshake_timeout": {
      "desc": "握手完成所允许的最长时间",
      "label": "握手超时时间"
    },
    "fields_deflate_opts_server_context_takeover": {
      "desc": "接管意味着在服务器消息之间保留压缩状态。",
      "label": "服务上下文接管"
    },
    "mqtt_session_expiry_interval": {
      "desc": "指定会话将在连接断开后多久过期，仅适用于非 MQTT 5.0 的连接。",
      "label": "会话过期间隔"
    },
    "fields_listener_enabled": {
      "desc": "启停监听器。",
      "label": "启停监听器"
    },
    "mqtt": {
      "desc": "全局的 MQTT 配置项。\nmqtt 下所有的配置作为全局的默认值存在，它可以被 <code>zone</code> 中的配置覆盖。"
    },
    "crl_cache_refresh_http_timeout": {
      "desc": "获取 CRLs 时 HTTP 请求的超时。 该配置对所有启用 CRL 检查的监听器监听器有效。",
      "label": "CRL 缓存刷新 HTTP 超时"
    },
    "fields_tcp_opts_backlog": {
      "desc": "TCP backlog 定义了挂起连接队列可以增长到的最大长度。",
      "label": "TCP 连接队列长度"
    },
    "broker_route_batch_clean": {
      "desc": "是否开启批量清除路由。"
    },
    "fields_mqtt_quic_listener_initial_window_packets": {
      "desc": "一个连接的初始拥堵窗口的大小（以包为单位）。默认值：10",
      "label": "初始窗口数据包"
    },
    "flapping_detect_enable": {
      "desc": "启用抖动检测功能。",
      "label": "启用抖动检测"
    },
    "sysmon_top_db_password": {
      "desc": "PostgreSQL 数据库的密码",
      "label": "数据库密码"
    },
    "fields_ws_opts_check_origins": {
      "desc": "允许的 origins 列表",
      "label": "允许的 origins"
    },
    "fields_deflate_opts_client_context_takeover": {
      "desc": "接管意味着在客户端消息之间保留压缩状态。",
      "label": "客户端上下文接管"
    },
    "base_listener_acceptors": {
      "desc": "监听器接收池的大小。",
      "label": "接收器数量"
    },
    "common_ssl_opts_schema_cacertfile": {
      "desc": "受信任的PEM格式 CA  证书捆绑文件<br/>\n此文件中的证书用于验证TLS对等方的证书。\n如果要信任新 CA，请将新证书附加到文件中。\n无需重启EMQX即可加载更新的文件，因为系统会定期检查文件是否已更新（并重新加载）<br/>\n注意：从文件中失效（删除）证书不会影响已建立的连接。",
      "label": "CA 证书文件"
    },
    "fields_ws_opts_mqtt_path": {
      "desc": "WebSocket 的 MQTT 协议路径。因此，EMQX Broker的WebSocket地址为：\n<code>ws://{ip}:{port}/mqtt</code>",
      "label": "WS MQTT 路径"
    },
    "sysmon_os_procmem_high_watermark": {
      "desc": "在发出相应警报之前，一个Erlang进程可以分配多少系统内存的阈值，以系统内存的百分比表示。",
      "label": "进程内存高水位线"
    },
    "fields_listeners_quic": {
      "desc": "QUIC 监听器。",
      "label": "QUIC 监听器"
    },
    "fields_listeners_ws": {
      "desc": "HTTP websocket 监听器。",
      "label": "HTTP websocket 监听器"
    },
    "mqtt_retry_interval": {
      "desc": "QoS 1/2 消息的重新投递间隔。",
      "label": "重试间隔"
    },
    "stats_enable": {
      "desc": "启用/禁用统计数据收集功能。",
      "label": "启用/禁用统计数据收集功能"
    },
    "fields_authorization_deny_action": {
      "desc": "授权检查拒绝操作时的操作。",
      "label": "授权检查拒绝操作时的操作"
    },
    "fields_deflate_opts_server_max_window_bits": {
      "desc": "指定服务器压缩上下文的大小。",
      "label": "服务器压缩窗口大小"
    },
    "client_ssl_opts_schema_server_name_indication": {
      "desc": "指定要在 TLS 服务器名称指示扩展中使用的主机名。<br/>\n例如，当连接到 \"server.example.net\" 时，接受连接并执行 TLS 握手的真正服务器可能与 TLS 客户端最初连接到的主机不同，\n例如，当连接到 IP 地址时，或者当主机具有多个可解析的 DNS 记录时<br/>\n如果未指定，它将默认为使用的主机名字符串\n建立连接，除非使用 IP 地址<br/>\n然后，主机名也用于对等机的主机名验证证书<br/>\n特殊值 <code>disable</code> 阻止发送服务器名称指示扩展，并禁用主机名验证检查。",
      "label": "服务器名称指示"
    },
    "fields_mqtt_quic_listener_retry_memory_limit": {
      "desc": "在使用无状态重试之前，可用于握手连接的可用内存的百分比。计算为`N/65535`。默认值：65",
      "label": "重试内存限制"
    },
    "force_shutdown_max_message_queue_len": {
      "desc": "消息队列的最大长度。",
      "label": "进程邮箱消息队列的最大长度"
    },
    "sys_heartbeat_interval": {
      "desc": "发送心跳系统消息的间隔时间，它包括：\n  - `$SYS/brokers/<node>/uptime`\n  - `$SYS/brokers/<node>/datetime`"
    },
    "flapping_detect_ban_time": {
      "desc": "抖动的客户端将会被禁止登录多长时间。",
      "label": "禁止登录时长"
    },
    "sysmon_top_num_items": {
      "desc": "每个监视组的顶级进程数。",
      "label": "顶级进程数"
    },
    "persistent_session_builtin_session_table": {
      "desc": "用于内建会话表的性能调优参数。",
      "label": "持久会话"
    },
    "mqtt_upgrade_qos": {
      "desc": "投递消息时，是否根据订阅主题时的 QoS 等级来强制提升派发的消息的 QoS 等级。",
      "label": "升级 QoS"
    },
    "mqtt_shared_subscription": {
      "desc": "是否启用对 MQTT 共享订阅的支持。",
      "label": "共享订阅可用"
    },
    "fields_tcp_opts_sndbuf": {
      "desc": "连接的 TCP 发送缓冲区（OS 内核）。",
      "label": "TCP 发送缓冲区"
    },
    "sysmon_os_mem_check_interval": {
      "desc": "定期内存检查的时间间隔。",
      "label": "内存检查间隔"
    },
    "server_ssl_opts_schema_gc_after_handshake": {
      "desc": "内存使用调优。如果启用，将在TLS/SSL握手完成后立即执行垃圾回收。TLS/SSL握手建立后立即进行GC。",
      "label": "握手后执行GC"
    },
    "fields_mqtt_quic_listener_ssl_options": {
      "desc": "QUIC 传输层的 TLS 选项",
      "label": "TLS 选项"
    },
    "fields_ws_opts_mqtt_piggyback": {
      "desc": "WebSocket消息是否允许包含多个 MQTT 数据包。",
      "label": "MQTT Piggyback"
    },
    "base_listener_mountpoint": {
      "desc": "发布或订阅时，请在所有主题前面加上 mountpoint 字符串。\n\n将消息传递给订阅者时，将从主题名称中删除带前缀的字符串。挂载点是一种用户可以用来实现不同侦听器之间消息路由隔离的方法。\n\n例如，如果客户机 A 使用 <code>listeners.tcp.\\<name>.mountpoint</code> 设置为'some_tenant'，那么客户端实际上订阅了主题'some_tenant/t'。<br/>\n类似地，如果另一个客户端B（与客户端A连接到同一个侦听器）向主题 't' 发送消息，该消息将路由到所有订阅了'some_租户/t'的客户端，因此客户端 A 将接收主题名为't'的消息<br/>\n\n设置为<code>\"\"</code> 以禁用该功能<br/>\n\nmountpoint 字符串中的变量：\n- <code>${clientid}</code>: clientid\n- <code>${username}</code>: username",
      "label": "mountpoint"
    },
    "mqtt_max_awaiting_rel": {
      "desc": "每个发布者的会话中，都存在一个队列来处理客户端发送的 QoS 2 消息。该队列会存储 QoS 2 消息的报文 ID 直到收到客户端的 PUBREL 或超时，达到队列长度的限制后，新的 QoS 2 消息发布会被拒绝，并返回 `147(0x93)` 错误。",
      "label": "PUBREL 等待队列长度"
    },
    "ciphers_schema_quic": {
      "desc": "此配置保存由逗号分隔的 TLS 密码套件名称，或作为字符串数组。例如\n<code>\"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256\"</code>或\n<code>[\"TLS_AES_256_GCM_SHA384\",\"TLS_AES_128_GCM_SHA256\"]</code>。\n<br/>\n密码（及其顺序）定义了客户端和服务器通过网络连接加密信息的方式。\n选择一个好的密码套件对于应用程序的数据安全性、机密性和性能至关重要。\n\n名称应为 OpenSSL 字符串格式（而不是 RFC 格式）。\nEMQX 配置文档提供的所有默认值和示例都是 OpenSSL 格式<br/>\n注意：某些密码套件仅与特定的 TLS <code>版本</code>兼容（'tlsv1.1'、'tlsv1.2'或'tlsv1.3'）。\n不兼容的密码套件将被自动删除。\n\n例如，如果只有 <code>versions</code> 仅配置为 <code>tlsv1.3</code>。为其他版本配置密码套件将无效。\n\n<br/>\n注：PSK 的 Ciphers 不支持 tlsv1.3<br/>\n如果打算使用PSK密码套件，<code>tlsv1.3</code>。应在<code>ssl.versions</code>中禁用。\n\n<br/>\nPSK 密码套件：\n<code>\"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,\nRSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,\nRSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,\nRSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA\"</code><br/>\n\n注：QUIC 监听器不支持 tlsv1.3 的 ciphers",
      "label": ""
    },
    "fields_mqtt_quic_listener_max_bytes_per_key": {
      "desc": "在启动密钥更新之前，用单个 1-RTT 加密密钥加密的最大字节数。默认值：274877906944",
      "label": "每个密钥的最大字节数"
    },
    "fields_mqtt_quic_listener_mtu_discovery_search_complete_timeout_us": {
      "desc": "如果没有达到 max ，在重新尝试 MTU 探测之前要等待的时间，单位是微秒。默认值：600000000",
      "label": ""
    },
    "fields_ws_opts_check_origin_enable": {
      "desc": "如果<code>true</code>，<code>origin</code>HTTP 头将根据<code>check_origins</code>参数中配置的允许来源列表进行验证。",
      "label": "检查 origin"
    },
    "sysmon_vm_busy_dist_port": {
      "desc": "启用后，当用于集群接点之间 RPC 的连接过忙时，会触发一条带有 <code>busy_dist_port</code> 关键字的 warning 级别日志。\n同时还会发布一条主题为 <code>$SYS/sysmon/busy_dist_port</code> 的 MQTT 系统消息。",
      "label": "启用分布式端口过忙监控"
    },
    "mqtt_max_mqueue_len": {
      "desc": "消息队列最大长度。持久客户端断开连接或飞行窗口已满时排队的消息长度。",
      "label": "最大消息队列长度"
    },
    "mqtt_max_inflight": {
      "desc": "允许在完成应答前同时投递的 QoS 1 和 QoS 2 消息的最大数量。",
      "label": "最大飞行窗口"
    },
    "persistent_session_store_enabled": {
      "desc": "使用数据库存储有关持久会话的信息。\n这使得在节点停止时，可以将客户端连接迁移到另一个群集节点。",
      "label": "启用持久会话保存"
    },
    "fields_deflate_opts_level": {
      "desc": "压缩级别",
      "label": "压缩级别"
    },
    "mqtt_server_keepalive": {
      "desc": "EMQX 要求的保活时间，如设为 disabled，则将使用客户端指定的保持连接时间；仅适用于 MQTT 5.0 客户端。",
      "label": "服务端保活时间"
    },
    "global_authentication": {
      "desc": "全局 MQTT 监听器的默认认证配置。 为每个监听器配置认证参考监听器器配置中的<code>authentication</code> 配置。\n\n该配置可以被配置为：\n<ul>\n  <li><code>[]</code>: 默认值，允许所有的登录请求\n  <li>配置为单认证器，例如 <code>{enable:true,backend:\"built_in_database\",mechanism=\"password_based\"}</code></li>\n  <li>配置为认证器数组</li>\n</ul>\n\n当配置为认证链后，登录凭证会按照配置的顺序进行检查，直到做出<code>allow</code> 或 <code>deny</code>的结果。\n\n如果在所有的认证器都执行完后，还是没有结果，登录将被拒绝。"
    },
    "fields_mqtt_quic_listener_load_balancing_mode": {
      "desc": "0: 禁用, 1: SERVER_ID_IP, 2: SERVER_ID_FIXED. 默认: 0",
      "label": "负载平衡模式"
    },
    "persistent_session_store_session_message_gc_interval": {
      "desc": "持久会话消息的临时数据垃圾收集的开始间隔。\n这不会影响持久会话消息的生命周期长度。",
      "label": "会话消息清理间隔"
    },
    "server_ssl_opts_schema_ocsp_refresh_http_timeout": {
      "desc": "检查 OCSP 响应时，HTTP 请求的超时。",
      "label": "OCSP 刷新 HTTP 超时"
    },
    "fields_tcp_opts_send_timeout": {
      "desc": "连接的 TCP 发送超时。",
      "label": "TCP 发送超时"
    },
    "sysmon_vm_process_high_watermark": {
      "desc": "在发出相应警报之前，本地节点上可以同时存在多少进程的阈值（以进程百分比表示）。",
      "label": "进程数高水位线"
    },
    "fields_tcp_opts_buffer": {
      "desc": "驱动程序使用的用户空间缓冲区的大小。",
      "label": "TCP 用户态缓冲区"
    },
    "server_ssl_opts_schema_honor_cipher_order": {
      "desc": "一个重要的安全设置，它强制根据服务器指定的顺序而不是客户机指定的顺序设置密码，从而强制服务器管理员执行（通常配置得更正确）安全顺序。",
      "label": "SSL honor cipher order"
    },
    "conn_congestion_min_alarm_sustain_duration": {
      "desc": "清除警报前的最短时间。<br/>只有当队列中没有挂起的数据，并且连接至少被堵塞了 <code>min_alarm_sustain_duration</code> 毫秒时，<br/>报警才会被清除。这是为了避免太频繁地清除和再次发出警报。",
      "label": "告警维持时间"
    },
    "fields_mqtt_quic_listener_keep_alive_interval_ms": {
      "desc": "多长时间发送一次PING帧以保活连接。",
      "label": "保持活着的时间间隔 毫秒"
    },
    "fields_mqtt_quic_listener_handshake_idle_timeout_ms": {
      "desc": "一个握手在被丢弃之前可以空闲多长时间",
      "label": "握手空闲超时 毫秒"
    },
    "broker_session_locking_strategy": {
      "desc": "Session 在集群中的锁策略。\n  - `loca`：仅锁本节点的 Session；\n  - `one`：任选一个其它节点加锁；\n  - `quorum`：选择集群中半数以上的节点加锁；\n  - `all`：选择所有节点加锁。"
    },
    "persistent_store_ram_cache": {
      "desc": "在内存中保持一份数据的副本，以便更快地访问。",
      "label": "内存缓存"
    },
    "fields_mqtt_quic_listener_stream_recv_window_default": {
      "desc": "初始流接收窗口大小。 默认值：32678",
      "label": "流接收窗口默认"
    },
    "mqtt_mqueue_priorities": {
      "desc": "主题优先级。取值范围 [1-255]\n默认优先级表为空，即所有的主题优先级相同。\n\n注：优先主题名称中不支持使用逗号和等号。\n注：不在此列表中的主题，被视为最高/最低优先级，这取决于<code>mqtt.mqueue_default_priority</code> 的配置\n\n示例：\n配置 <code>\"topic/1\" > \"topic/2\"</code>:\n<code>mqueue_priorities: {\"topic/1\": 10, \"topic/2\": 8}</code>",
      "label": "主题优先级"
    },
    "fields_rate_limit_conn_messages_in": {
      "desc": "外部 MQTT 连接的消息限制。",
      "label": "外部 MQTT 连接的消息限制"
    },
    "fields_rate_limit_max_conn_rate": {
      "desc": "每秒最大连接数。",
      "label": "每秒最大连接数"
    },
    "alarm_size_limit": {
      "desc": "要保留为历史记录的已停用报警的最大总数。当超过此限制时，将删除最旧的停用报警，以限制总数。",
      "label": "告警总数限制"
    },
    "fields_cache_max_size": {
      "desc": "缓存项的最大数量。",
      "label": "缓存项的最大数量"
    },
    "fields_listeners_tcp": {
      "desc": "TCP 监听器。",
      "label": "TCP 监听器"
    },
    "conn_congestion_enable_alarm": {
      "desc": "启用或者禁用连接阻塞告警功能。",
      "label": "启用/禁用阻塞告警"
    },
    "fields_ws_opts_proxy_port_header": {
      "desc": "HTTP 头，用于传递有关客户端端口的信息。当 EMQX 集群部署在负载平衡器后面时，这一点非常重要。",
      "label": "客户端端口头"
    },
    "overload_protection_enable": {
      "desc": "是否对系统过载做出反应。",
      "label": "是否对系统过载做出反应"
    },
    "fields_mqtt_quic_listener_minimum_mtu": {
      "desc": "一个连接所支持的最小MTU。这将被作为起始MTU使用。默认值：1248",
      "label": "最小 MTU"
    },
    "sys_msg_interval": {
      "desc": "发送 `$SYS` 主题的间隔时间。"
    },
    "mqtt_await_rel_timeout": {
      "desc": "客户端发布 QoS 2 消息时，服务器等待 `PUBREL` 的最长时延。超过该时长后服务器会放弃等待，该PACKET ID 会被释放，从而允许后续新的 PUBLISH 消息使用。如果超时后收到 PUBREL，服务器将会产生一条告警日志。注意，向订阅客户端转发消息的动作发生在进入等待之前。",
      "label": "PUBREL 最大等待时间"
    },
    "common_ssl_opts_schema_verify": {
      "desc": "启用或禁用对等验证。",
      "label": "对等验证"
    },
    "fields_listeners_ssl": {
      "desc": "SSL 监听器。",
      "label": "SSL 监听器"
    },
    "fields_deflate_opts_client_max_window_bits": {
      "desc": "指定客户端压缩上下文的大小。",
      "label": "压缩窗口大小"
    },
    "common_ssl_opts_schema_keyfile": {
      "desc": "PEM格式的私钥文件。",
      "label": "私钥文件"
    },
    "sysmon_os_cpu_high_watermark": {
      "desc": "在发出相应警报之前可以使用多少系统 CPU 的阈值，以系统CPU负载的百分比表示。",
      "label": "CPU 高水位线"
    },
    "flapping_detect_window_time": {
      "desc": "抖动检测的时间窗口。",
      "label": "时间窗口"
    },
    "mqtt_mqueue_default_priority": {
      "desc": "默认的主题优先级，不在 <code>主题优先级</code>（<code>mqueue_priorities</code>） 中的主题将会使用该优先级。",
      "label": "默认主题优先级"
    },
    "client_ssl_opts_schema_enable": {
      "desc": "启用 TLS。",
      "label": "启用 TLS"
    },
    "fields_mqtt_quic_listener_mtu_discovery_missing_probe_count": {
      "desc": "在任何时候都可以在一个绑定上排队的无状态操作的最大数量。默认值：3",
      "label": "MTU发现丢失的探针数量"
    },
    "fields_tcp_opts_recbuf": {
      "desc": "连接的 TCP 接收缓冲区（OS 内核）。",
      "label": "TCP 接收缓冲区"
    },
    "sysmon_vm_process_check_interval": {
      "desc": "定期进程限制检查的时间间隔。",
      "label": "进程限制检查时间"
    },
    "fields_mqtt_quic_listener_server_resumption_level": {
      "desc": "连接恢复 和/或 0-RTT 服务器支持。默认值：0（无恢复功能）",
      "label": "服务端连接恢复支持"
    },
    "fields_ws_opts_proxy_address_header": {
      "desc": "HTTP 头，用于传递有关客户端 IP 地址的信息。\n当 EMQX 集群部署在负载平衡器后面时，这一点非常重要。",
      "label": "客户端地址头"
    },
    "sysmon_os_sysmem_high_watermark": {
      "desc": "在发出相应报警之前可以分配多少系统内存的阈值，以系统内存的百分比表示。",
      "label": "系统内存高水位线"
    },
    "fields_tcp_opts_high_watermark": {
      "desc": "当 VM 套接字实现内部排队的数据量达到此限制时，套接字将设置为忙碌状态。",
      "label": ""
    },
    "fields_mqtt_quic_listener_stateless_operation_expiration_ms": {
      "desc": "同一个对端的操作之间的时间限制，单位是毫秒。 默认：100",
      "label": "无状态操作过期 毫秒"
    },
    "server_ssl_opts_schema_dhfile": {
      "desc": "如果协商使用Diffie-Hellman密钥交换的密码套件，则服务器将使用包含PEM编码的Diffie-Hellman参数的文件的路径。如果未指定，则使用默认参数。<br/>\n注意：TLS 1.3不支持<code>dhfile</code>选项。",
      "label": "SSL dhfile"
    },
    "flapping_detect_max_count": {
      "desc": "MQTT 客户端在“窗口”时间内允许的最大断开次数。",
      "label": "最大断开次数"
    },
    "mqtt_max_topic_levels": {
      "desc": "允许的最大主题层级。",
      "label": "最大主题层级"
    },
    "force_shutdown_max_heap_size": {
      "desc": "Heap 的总大小。",
      "label": "Heap 的总大小"
    },
    "persistent_store_on_disc": {
      "desc": "将持久会话数据保存在磁盘上。如果为 false 则存储在内存中。\n如开启， 持久会话数据可在集群重启后恢复。\n如关闭， 数据仅存储在内存中， 则在整个集群停止后丢失。",
      "label": "持久化在磁盘上"
    },
    "mqtt_ignore_loop_deliver": {
      "desc": "设置由 MQTT v3.1.1/v3.1.0 客户端发布的消息是否将转发给其本身；类似 MQTT 5.0 协议中的 <code>No Local</code> 选项。",
      "label": "忽略循环投递"
    },
    "common_ssl_opts_schema_certfile": {
      "desc": "PEM格式证书链文件<br/>\n此文件中的证书应与证书颁发链的顺序相反。也就是说，主机的证书应该放在文件的开头，\n然后是直接颁发者 CA 证书，依此类推，一直到根 CA 证书。\n根 CA 证书是可选的，如果想要添加，应加到文件到最末端。",
      "label": "证书文件"
    },
    "mqtt_exclusive_subscription": {
      "desc": "是否启用对 MQTT 排它订阅的支持。",
      "label": "排它订阅"
    },
    "mqtt_retain_available": {
      "desc": "是否启用对 MQTT 保留消息的支持。",
      "label": "保留消息可用"
    },
    "fields_tcp_opts_reuseaddr": {
      "desc": "连接的 SO_REUSEADDR 标识。",
      "label": "SO_REUSEADDR"
    },
    "sysmon_vm_long_schedule": {
      "desc": "启用后，如果 Erlang VM 调度器出现某个任务占用时间过长时，会触发一条带有 'long_schedule' 关键字的日志。\n同时还会发布一条主题为 <code>$SYS/sysmon/long_schedule</code> 的 MQTT 系统消息。",
      "label": "启用长调度监控"
    },
    "mqtt_keepalive_backoff": {
      "desc": "EMQX 判定客户端保活超时使用的阈值系数。计算公式为：Keep Alive * Backoff * 2",
      "label": "保活超时阈值系数"
    },
    "force_gc_bytes": {
      "desc": "在进程处理过多少个字节之后，对此进程执行垃圾回收。",
      "label": "垃圾回收字节数"
    },
    "server_ssl_opts_schema_fail_if_no_peer_cert": {
      "desc": "TLS/DTLS 服务器与 {verify，verify_peer} 一起使用。\n如果设置为true，则如果客户端没有要发送的证书，即发送空证书，服务器将失败。\n如果设置为false，则仅当客户端发送无效证书（空证书被视为有效证书）时才会失败。",
      "label": "没有证书则 SSL 失败"
    },
    "fields_ws_opts_compress": {
      "desc": "如果 <code>true</code>，则使用<code>zlib</code> 压缩 WebSocket 消息<br/>\n<code>deflate_opts</code> 下的配置项属于压缩相关参数配置。",
      "label": "Ws 压缩"
    },
    "fields_mqtt_quic_listener_keep_alive_interval": {
      "desc": "发送 PING 帧的频率，以保活连接. 设为 0 表示禁用。",
      "label": "PING 保活频率"
    },
    "fields_cache_ttl": {
      "desc": "缓存数据的生存时间。",
      "label": "缓存数据的生存时间。"
    },
    "sys_topics": {
      "desc": "系统主题配置。"
    },
    "sys_event_client_subscribed": {
      "desc": "是否开启客户端已成功订阅主题事件消息。"
    },
    "sysmon_top_db_port": {
      "desc": "收集数据点的 PostgreSQL 数据库的端口。",
      "label": "数据库端口"
    },
    "fields_mqtt_quic_listener_max_operations_per_drain": {
      "desc": "每个连接操作的最大耗费操作数。默认：16",
      "label": "每次操作最大操作数"
    },
    "fields_mqtt_quic_listener_datagram_receive_enabled": {
      "desc": "宣传对QUIC Datagram 扩展的支持。为将来保留。默认为0（FALSE）",
      "label": "启用 Datagram 接收"
    },
    "fields_mqtt_quic_listener_initial_rtt_ms": {
      "desc": "初始RTT估计",
      "label": "Initial RTT 毫秒"
    },
    "overload_protection_backoff_gc": {
      "desc": "高负载时，跳过强制 GC。",
      "label": "跳过GC"
    },
    "broker_perf_route_lock_type": {
      "desc": "通配主题订阅/取消订阅性能调优。\n建议仅当通配符主题较多时才更改此参数。\n\n注：当从/更改为 `global` 锁时，它要求集群中的所有节点在更改之前停止。\n  - `key`：为 Mnesia 事务涉及到的每个 key 上锁，建议单节点时使用。\n  - `tab`：为 Mnesia 事务涉及到的表上锁，建议在集群中使用。\n  - `global`：所以更新操作都被全局的锁保护，仅建议在超大规模集群中使用。"
    },
    "fields_tcp_opts_nodelay": {
      "desc": "连接的 TCP_NODELAY 标识",
      "label": "TCP_NODELAY"
    },
    "sysmon_top_db_username": {
      "desc": "PostgreSQL 数据库的用户名",
      "label": "数据库用户名"
    },
    "broker": {
      "desc": "Broker 相关配置项。"
    },
    "force_gc_count": {
      "desc": "在进程收到多少消息之后，对此进程执行垃圾回收。",
      "label": "垃圾回收消息数"
    },
    "mqtt_max_clientid_len": {
      "desc": "允许的最大 MQTT Client ID 长度。",
      "label": "最大 Client ID 长度"
    },
    "fields_ws_opts_supported_subprotocols": {
      "desc": "逗号分隔的 subprotocols 支持列表。",
      "label": "Subprotocols 支持列表"
    },
    "broker_shared_subscription_strategy": {
      "desc": "共享订阅消息派发策略。\n  - `random`：随机挑选一个共享订阅者派发；\n  - `round_robin`：使用 round-robin 策略派发；\n  - `round_robin_per_group`：在共享组内循环选择下一个成员；\n  - `local`：选择随机的本地成员，否则选择随机的集群范围内成员;\n  - `sticky`：总是使用上次选中的订阅者派发，直到它断开连接；\n  - `hash_clientid`：通过对发送者的客户端 ID 进行 Hash 处理来选择订阅者;\n  - `hash_topic`：通过对源主题进行 Hash 处理来选择订阅者。"
    },
    "fields_deflate_opts_mem_level": {
      "desc": "指定压缩状态的大小<br/>\n较低的值会减少每个连接的内存使用。",
      "label": "压缩状态大小"
    },
    "fields_mqtt_quic_listener_send_idle_timeout_ms": {
      "desc": "在闲置一定时间后重置拥堵控制。默认值：1000",
      "label": "发送空闲超时毫秒"
    },
    "base_listener_limiter": {
      "desc": "速率限制类型",
      "label": "速率限制类型"
    },
    "persistent_session_store_backend": {
      "desc": "用于存储持久性会话和信息的数据库管理后端\n- `builtin`: 使用内置的数据库（mria）",
      "label": "后端类型"
    },
    "alarm_validity_period": {
      "desc": "停用报警的保留时间。报警在停用时不会立即删除，而是在保留时间之后删除。",
      "label": "告警保留时间"
    },
    "server_ssl_opts_schema_ocsp_issuer_pem": {
      "desc": "服务器证书的 OCSP 签发者的 PEM 编码证书。",
      "label": "OCSP 签发者证书"
    },
    "fields_tcp_opts_active_n": {
      "desc": "为此套接字指定{active，N}选项<br/>\nSee: https://erlang.org/doc/man/inet.html#setopts-2",
      "label": "active_n"
    },
    "listener_authentication": {
      "desc": "监听器认证重载。\n认证配置可以是单个认证器实例，也可以是一个认证器数组组成的认证链。\n执行登录验证时（用户名、客户端 ID 等），将按配置的顺序执行。",
      "label": "每个监听器的认证覆盖"
    },
    "fields_trace_payload_encode": {
      "desc": "确定跟踪文件中有效负载格式的格式。<br/>\n`text`：基于文本的协议或纯文本协议。\n建议在有效负载为JSON编码时使用<br/>\n`hex`：二进制十六进制编码。当有效负载是自定义二进制协议时，建议使用此选项<br/>\n`hidden`：有效负载被模糊化为 `******`",
      "label": "有效负载编码"
    },
    "mqtt_response_information": {
      "desc": "UTF-8 字符串，用于指定返回给客户端的响应主题，如 <code>reqrsp/</code>，此时请求和应答客户端都需要使用 <code>reqrsp/</code> 前缀的主题来完成通讯。\n如希望禁用此功能，请在下方的文字框中输入<code>\"\"</code>；仅适用于 MQTT 5.0 客户端。",
      "label": "响应信息"
    },
    "persistent_session_store_max_retain_undelivered": {
      "desc": "如果重新启动时处理上一个会话的节点已停止，则未传递到持久会话的消息在垃圾收集之前会被存储。",
      "label": "未投递的消息保留条数"
    },
    "fields_mqtt_quic_listener_migration_enabled": {
      "desc": "开启客户端地址迁移功能。需要一个支持的负载平衡器，或者没有负载平衡器。默认值：1（已启用）",
      "label": "启用地址迁移"
    },
    "common_ssl_opts_schema_password": {
      "desc": "包含用户密码的字符串。仅在私钥文件受密码保护时使用。",
      "label": "秘钥文件密码"
    },
    "common_ssl_opts_schema_hibernate_after": {
      "desc": "在闲置一定时间后休眠 SSL 进程，减少其内存占用。",
      "label": "闲置多久后休眠"
    },
    "fields_mqtt_quic_listener_send_buffering_enabled": {
      "desc": "缓冲发送数据，而不是保留应用缓冲区，直到发送数据被确认。默认值：1（启用）",
      "label": "启用发送缓冲功能"
    },
    "sys_event_client_unsubscribed": {
      "desc": "是否开启客户端已成功取消订阅主题事件消息。"
    },
    "overload_protection_backoff_new_conn": {
      "desc": "高负载时，拒绝新进来的客户端连接。",
      "label": "关闭新连接"
    },
    "server_ssl_opts_schema_ocsp_responder_url": {
      "desc": "用于检查服务器证书的 OCSP Responder 的 URL。",
      "label": "OCSP Responder 的 URL"
    },
    "mqtt_idle_timeout": {
      "desc": "设置连接被断开或进入休眠状态前的等待时间，空闲超时后，\n  - 如暂未收到客户端的 CONNECT 报文，连接将断开；\n  - 如已收到客户端的 CONNECT 报文，连接将进入休眠模式以节省系统资源。\n\n注意：请合理设置该参数值，如等待时间设置过长，可能造成系统资源的浪费。",
      "label": "空闲超时"
    },
    "fields_mqtt_quic_listener_conn_flow_control_window": {
      "desc": "连接的流控窗口。默认：16777216",
      "label": "流控窗口"
    },
    "fields_mqtt_quic_listener_maximum_mtu": {
      "desc": "一个连接所支持的最大MTU。这将是最大的探测值。默认值：1500",
      "label": "最大 MTU"
    },
    "sysmon_top_db_name": {
      "desc": "PostgreSQL 数据库的数据库名",
      "label": "数据库名"
    },
    "mqtt_strict_mode": {
      "desc": "是否以严格模式解析 MQTT 消息。\n严格模式下，如客户端 ID、主题名称等中包含无效 utf8 字符串，连接将被断开。",
      "label": "严格模式"
    },
    "shared_subscription_group_strategy": {
      "desc": "设置共享订阅组为单位的分发策略。该配置是一个从组名到\n策略名的一个map，组名不得包含 `[A-Za-z0-9]` 之外的特殊字符。"
    },
    "fields_deflate_opts_strategy": {
      "desc": "指定压缩策略。",
      "label": "指定压缩策略"
    },
    "shared_subscription_strategy_enum": {
      "desc": "共享订阅的分发策略名称。\n- `random`：随机选择一个组内成员；\n- `round_robin`：循环选择下一个成员；\n- `round_robin_per_group`：在共享组内循环选择下一个成员；\n- `sticky`：使用上一次选中的成员；\n- `hash`：根据 ClientID 哈希映射到一个成员；\n- `local`：随机分发到节点本地成成员，如果本地成员不存在，则随机分发到任意一个成员。"
    },
    "persistent_session_builtin_sess_msg_table": {
      "desc": "优化内置的会话消息表的配置。",
      "label": "用于内建会话管理表的性能调优参数"
    },
    "mqtt_mqueue_store_qos0": {
      "desc": "指定在连接断开但会话保持期间，是否需要在消息队列中存储 QoS 0 消息。",
      "label": "存储 QoS 0 消息"
    },
    "server_ssl_opts_schema_client_renegotiation": {
      "desc": "在支持客户机发起的重新协商的协议中，这种操作的资源成本对于服务器来说高于客户机。\n这可能会成为拒绝服务攻击的载体。\nSSL 应用程序已经采取措施来反击此类尝试，但通过将此选项设置为 false，可以严格禁用客户端发起的重新协商。\n默认值为 true。请注意，由于基础密码套件可以加密的消息数量有限，禁用重新协商可能会导致长期连接变得不可用。",
      "label": "SSL 客户端冲协商"
    },
    "server_ssl_opts_schema_enable_crl_check": {
      "desc": "是否为该监听器启用 CRL 检查。",
      "label": "启用 CRL 检查"
    },
    "fields_mqtt_quic_listener_peer_bidi_stream_count": {
      "desc": "允许对端打开的双向流的数量",
      "label": "对端双向流的数量"
    },
    "fields_mqtt_quic_listener_max_stateless_operations": {
      "desc": "无状态操作的最大数量，在任何时候都可以在一个工作者上排队。默认值：16",
      "label": "最大无状态操作数"
    },
    "fields_ws_opts_idle_timeout": {
      "desc": "关闭在此间隔内未发送 MQTT CONNECT 消息的客户端的传输层连接。",
      "label": "WS 空闲时间"
    },
    "fields_mqtt_quic_listener_max_ack_delay_ms": {
      "desc": "在收到数据后要等待多长时间才能发送一个ACK。默认值：25",
      "label": "最大应答延迟 毫秒"
    },
    "base_listener_zone": {
      "desc": "监听器所属的配置组。",
      "label": "配置组"
    },
    "fields_mqtt_quic_listener_handshake_idle_timeout": {
      "desc": "一个握手在被丢弃之前可以空闲多长时间。",
      "label": "握手空闲超时时间"
    },
    "force_gc_enable": {
      "desc": "启用强制垃圾回收。",
      "label": "启用强制垃圾回收"
    },
    "fields_ws_opts_allow_origin_absence": {
      "desc": "If <code>false</code> and <code>check_origin_enable</code> is <code>true</code>, the server will reject requests that don't have <code>origin</code> HTTP header.",
      "label": "允许 origin 缺失"
    },
    "common_ssl_opts_schema_versions": {
      "desc": "支持所有TLS/DTLS版本<br/>\n注：PSK 的 Ciphers 无法在 <code>tlsv1.3</code> 中使用，如果打算使用 PSK 密码套件，请确保这里配置为 <code>[\"tlsv1.2\",\"tlsv1.1\"]</code>。",
      "label": "SSL 版本"
    },
    "mqtt_listener_proxy_protocol_timeout": {
      "desc": "代理协议超时。如果在超时时间内未收到代理协议数据包，EMQX将关闭TCP连接。",
      "label": "Proxy protocol 超时时间"
    },
    "fields_mqtt_quic_listener_idle_timeout": {
      "desc": "一个连接在被关闭之前可以空闲多长时间。0表示禁用。",
      "label": "空闲超时时间"
    },
    "common_ssl_opts_schema_secure_renegotiate": {
      "desc": "SSL 参数重新协商是一种允许客户端和服务器动态重新协商 SSL 连接参数的功能。\nRFC 5746 定义了一种更安全的方法。通过启用安全的重新协商，您就失去了对不安全的重新协商的支持，从而容易受到 MitM 攻击。",
      "label": "SSL 重新协商"
    },
    "sysmon_vm_busy_port": {
      "desc": "当一个系统接口（例如 TCP socket）过忙，会触发一条带有 <code>busy_port</code> 关键字的 warning 级别的日志。\n同时还会发布一条主题为 <code>$SYS/sysmon/busy_port</code> 的 MQTT 系统消息。",
      "label": "启用端口过忙监控"
    },
    "sys_event_client_connected": {
      "desc": "是否开启客户端已连接事件消息。"
    },
    "sysmon_vm_process_low_watermark": {
      "desc": "在清除相应警报之前，本地节点上可以同时存在多少进程的阈值（以进程百分比表示）。",
      "label": "进程数低水位线"
    },
    "mqtt_max_packet_size": {
      "desc": "允许的最大 MQTT 报文大小。",
      "label": "最大报文大小"
    },
    "common_ssl_opts_schema_reuse_sessions": {
      "desc": "启用 TLS 会话重用。",
      "label": "TLS 会话重用"
    },
    "common_ssl_opts_schema_depth": {
      "desc": "在有效的证书路径中，可以跟随对等证书的非自颁发中间证书的最大数量。\n因此，如果深度为0，则对等方必须由受信任的根 CA 直接签名；<br/>\n如果是1，路径可以是 PEER、中间 CA、ROOT-CA；<br/>\n如果是2，则路径可以是PEER、中间 CA1、中间 CA2、ROOT-CA。",
      "label": "CA 证书深度"
    },
    "sysmon_vm_long_gc": {
      "desc": "当系统检测到某个 Erlang 进程垃圾回收占用过长时间，会触发一条带有 <code>long_gc</code> 关键字的日志。\n同时还会发布一条主题为 <code>$SYS/sysmon/long_gc</code> 的 MQTT 系统消息。",
      "label": "启用长垃圾回收监控"
    },
    "fields_mqtt_quic_listener_keyfile": {
      "desc": "私钥文件。在 5.1 中会被废弃，使用 .ssl_options.keyfile 代替。",
      "label": "私钥文件"
    },
    "mqtt_peer_cert_as_clientid": {
      "desc": "使用对端证书中的 CN、DN 字段或整个证书内容来作为客户端 ID。仅适用于 TLS 连接；\n目前支持：\n- <code>cn</code>: 取证书的 CN 字段\n- <code>dn</code>: 取证书的 DN 字段\n- <code>crt</code>: 取 <code>DER</code> 或 <code>PEM</code> 证书的内容\n- <code>pem</code>: 将 <code>DER</code> 证书内容转换为 <code>PEM</code> 格式作为客户端 ID\n- <code>md5</code>: 取 <code>DER</code> 或 <code>PEM</code> 证书内容的 MD5 值",
      "label": "对端证书作为客户端 ID"
    },
    "persistent_session_store_message_gc_interval": {
      "desc": "将未送达的消息垃圾收集到持久会话的开始间隔。\n这会影响检查 \"max_retain_undelivered\"（最大保留未送达）的删除频率。",
      "label": "消息清理间隔"
    },
    "broker_shared_dispatch_ack_enabled": {
      "desc": "该配置项已废弃，会在 5.1 中移除。\n启用/禁用 QoS 1 和 QoS 2 消息的共享派发确认。\n开启后，允许将消息从未及时回复 ACK 的订阅者 （例如，客户端离线） 重新派发给另外一个订阅者。"
    },
    "base_listener_enable_authn": {
      "desc": "配置 <code>true</code> （默认值）启用客户端进行身份认证，通过检查认配置的认认证器链来决定是否允许接入。\n配置 <code>false</code> 时，将不对客户端做任何认证，任何客户端，不论是不是携带用户名等认证信息，都可以接入。\n配置 <code>quick_deny_anonymous</code> 时，行为跟 <code>true</code> 类似，但是会对匿名\n客户直接拒绝，不做使用任何认证器对客户端进行身份检查。",
      "label": "启用身份认证"
    },
    "force_shutdown_enable": {
      "desc": "启用 `force_shutdown` 功能。",
      "label": "启用 `force_shutdown` 功能"
    },
    "broker_enable_session_registry": {
      "desc": "是否启用 Session Registry"
    },
    "overload_protection_backoff_delay": {
      "desc": "高负载时，一些不重要的任务可能会延迟执行，在这里设置允许延迟的时间。",
      "label": "延迟时间"
    },
    "ciphers_schema_common": {
      "desc": "此配置保存由逗号分隔的 TLS 密码套件名称，或作为字符串数组。例如\n<code>\"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256\"</code>或\n<code>[\"TLS_AES_256_GCM_SHA384\",\"TLS_AES_128_GCM_SHA256\"]</code>。\n<br/>\n密码（及其顺序）定义了客户端和服务器通过网络连接加密信息的方式。\n选择一个好的密码套件对于应用程序的数据安全性、机密性和性能至关重要。\n\n名称应为 OpenSSL 字符串格式（而不是 RFC 格式）。\nEMQX 配置文档提供的所有默认值和示例都是 OpenSSL 格式<br/>\n注意：某些密码套件仅与特定的 TLS <code>版本</code>兼容（'tlsv1.1'、'tlsv1.2'或'tlsv1.3'）。\n不兼容的密码套件将被自动删除。\n\n例如，如果只有 <code>versions</code> 仅配置为 <code>tlsv1.3</code>。为其他版本配置密码套件将无效。\n\n<br/>\n注：PSK 的 Ciphers 不支持 tlsv1.3<br/>\n如果打算使用PSK密码套件 <code>tlsv1.3</code>。应在<code>ssl.versions</code>中禁用。\n\n<br/>\nPSK 密码套件：\n<code>\"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,\nRSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,\nRSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,\nRSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA\"</code>",
      "label": ""
    },
    "sys_event_client_disconnected": {
      "desc": "是否开启客户端已断开连接事件消息。"
    },
    "crl_cache_refresh_interval": {
      "desc": "从服务器刷新CRL的周期。 该配置对所有 URL 和监听器有效。",
      "label": "CRL 缓存刷新间隔"
    },
    "mqtt_listener_proxy_protocol": {
      "desc": "如果EMQX集群部署在 HAProxy 或 Nginx 之后，请启用代理协议 V1/2 <br/>\n详情见: https://www.haproxy.com/blog/haproxy/proxy-protocol/",
      "label": "Proxy protocol"
    },
    "mqtt_listener_access_rules": {
      "desc": "此监听器的访问控制规则。",
      "label": "访问控制规则"
    },
    "server_ssl_opts_schema_enable_ocsp_stapling": {
      "desc": "是否为监听器启用 OCSP Stapling 功能。 如果设置为 true，需要定义 OCSP Responder 的 URL 和证书签发者的 PEM 文件路径。",
      "label": "启用 OCSP Stapling"
    },
    "fields_tcp_opts_send_timeout_close": {
      "desc": "如果发送超时，则关闭连接。",
      "label": "TCP 发送超时关闭连接"
    },
    "sysmon_os_cpu_check_interval": {
      "desc": "定期 CPU 检查的时间间隔。",
      "label": "定期 CPU 检查的时间间隔"
    },
    "sysmon_top_sample_interval": {
      "desc": "指定应收集进程顶部的频率。",
      "label": "取样时间"
    },
    "fields_mqtt_quic_listener_idle_timeout_ms": {
      "desc": "一个连接在被优雅地关闭之前可以空闲多长时间。0 表示禁用超时",
      "label": "空闲超时 毫秒"
    },
    "fields_ws_opts_fail_if_no_subprotocol": {
      "desc": "如果<code>true</code>，当客户端未携带<code>Sec WebSocket Protocol</code>字段时，服务器将返回一个错误。\n<br/>注意：微信小程序需要禁用此验证。",
      "label": "无 subprotocol 则失败"
    },
    "mqtt_wildcard_subscription": {
      "desc": "是否启用对 MQTT 通配符订阅的支持。",
      "label": "通配符订阅可用"
    },
    "server_ssl_opts_schema_ocsp_refresh_interval": {
      "desc": "为服务器刷新OCSP响应的周期。",
      "label": "OCSP 刷新间隔"
    },
    "overload_protection_backoff_hibernation": {
      "desc": "高负载时，跳过进程休眠。",
      "label": "跳过休眠"
    },
    "fields_ws_opts_max_frame_size": {
      "desc": "单个 MQTT 数据包的最大长度。",
      "label": "最大数据包长度"
    },
    "sys_event_messages": {
      "desc": "客户端事件消息。"
    },
    "broker_perf_trie_compaction": {
      "desc": "是否开启主题表压缩存储。\n启用它会显着提高通配符主题订阅率，如果通配符主题具有唯一前缀，例如：'sensor/{{id}}/+/'，其中每个订阅者的 ID 是唯一的。\n如果消息主要发布到具有大量级别的主题，则主题匹配性能（发布时）可能会降低。\n\n注意：这是一个集群范围的配置。 它要求在更改之前停止所有节点。"
    },
    "sysmon_vm_large_heap": {
      "desc": "启用后，当一个 Erlang 进程申请了大量内存，系统会触发一条带有 <code>large_heap</code> 关键字的\nwarning 级别日志。同时还会发布一条主题为 <code>$SYS/sysmon/busy_dist_port</code> 的 MQTT 系统消息。",
      "label": "启用大 heap 监控"
    }
  },
  "emqx_slow_subs_api": {
    "clear_records_api": {
      "desc": "清除当前记录，然后重新开始统计"
    },
    "clientid": {
      "desc": "消息的客户端 ID"
    },
    "get_records_api": {
      "desc": "查看慢订阅的统计数据"
    },
    "get_setting_api": {
      "desc": "查看配置"
    },
    "last_update_time": {
      "desc": "记录的更新时间戳"
    },
    "node": {
      "desc": "消息的节点名称"
    },
    "timespan": {
      "desc": "消息的传输耗时"
    },
    "topic": {
      "desc": "消息的主题"
    },
    "update_setting_api": {
      "desc": "更新配置"
    }
  },
  "emqx_slow_subs_schema": {
    "enable": {
      "desc": "开启慢订阅"
    },
    "expire_interval": {
      "desc": "慢订阅记录的有效时间"
    },
    "stats_type": {
      "desc": "慢订阅的统计类型"
    },
    "threshold": {
      "desc": "慢订阅统计的阈值"
    },
    "top_k_num": {
      "desc": "慢订阅统计表的记录数量上限"
    }
  },
  "emqx_statsd_api": {
    "get_statsd_config_api": {
      "desc": "列出 StatsD 指标采集和推送服务的的配置。"
    },
    "update_statsd_config_api": {
      "desc": "更新 StatsD 指标采集和推送服务的配置。"
    }
  },
  "emqx_statsd_schema": {
    "enable": {
      "desc": "启用或禁用 StatsD 指标采集和推送服务。"
    },
    "flush_interval": {
      "desc": "指标的推送间隔。"
    },
    "get_statsd_config_api": {
      "desc": "列出 StatsD 指标采集和推送服务的的配置。"
    },
    "sample_interval": {
      "desc": "指标的采样间隔。"
    },
    "server": {
      "desc": "StatsD 服务器地址。"
    },
    "statsd": {
      "desc": "StatsD 指标采集与推送配置。",
      "label": "StatsD"
    },
    "tags": {
      "desc": "指标的标签。"
    },
    "update_statsd_config_api": {
      "desc": "更新 StatsD 指标采集和推送服务的配置。"
    }
  },
  "emqx_stomp_schema": {
    "stom_frame_max_body_length": {
      "desc": "允许的 Stomp 报文 Body 的最大字节数"
    },
    "stom_frame_max_headers": {
      "desc": "允许的 Header 最大数量"
    },
    "stomp": {
      "desc": "Stomp 网关配置。当前实现支持 v1.2/1.1/1.0 协议版本"
    },
    "stomp_frame_max_headers_length": {
      "desc": "允许的 Header 字符串的最大长度"
    }
  },
  "emqx_telemetry_api": {
    "active_modules": {
      "desc": "获取活跃模块"
    },
    "active_plugins": {
      "desc": "获取活跃插件"
    },
    "emqx_version": {
      "desc": "获取 emqx 版本"
    },
    "enable": {
      "desc": "启用遥测"
    },
    "get_telemetry_data_api": {
      "desc": "获取遥测数据"
    },
    "get_telemetry_status_api": {
      "desc": "获取遥测状态"
    },
    "license": {
      "desc": "获取 license 信息"
    },
    "messages_received": {
      "desc": "获取接收到的消息数量"
    },
    "messages_sent": {
      "desc": "获取发送的消息数量"
    },
    "nodes_uuid": {
      "desc": "获取节点 UUID"
    },
    "num_clients": {
      "desc": "获取客户端数量"
    },
    "os_name": {
      "desc": "获取操作系统名称"
    },
    "os_version": {
      "desc": "获取操作系统版本"
    },
    "otp_version": {
      "desc": "获取 OTP 版本"
    },
    "up_time": {
      "desc": "获取运行时间"
    },
    "update_telemetry_status_api": {
      "desc": "更新遥测状态"
    },
    "uuid": {
      "desc": "获取 UUID"
    }
  },
  "emqx_topic_metrics_api": {
    "message_qos1_in_rate": {
      "desc": "QoS1 接收消息速率"
    },
    "message_out_count": {
      "desc": "发送消息数量"
    },
    "message_qos2_out_rate": {
      "desc": "QoS2 发送消息速率"
    },
    "message_qos0_in_rate": {
      "desc": "QoS0 接收消息速率"
    },
    "get_topic_metrics_api": {
      "desc": "获取主题监控数据"
    },
    "reset_time": {
      "desc": "重置时间。标准 rfc3339 时间格式，例如：2018-01-01T12:00:00Z。如果从未重置则为空"
    },
    "topic_metrics_api_response400": {
      "desc": "错误请求。已存在或错误的主题名称"
    },
    "reset_topic_desc": {
      "desc": "主题名称。如果此参数不存在，则所有创建的主题监控数据都将重置。"
    },
    "topic_metrics_api_response409": {
      "desc": "冲突。主题监控数据超过最大限制512"
    },
    "post_topic_metrics_api": {
      "desc": "创建主题监控数据"
    },
    "message_dropped_rate": {
      "desc": "丢弃消息速率"
    },
    "message_qos2_in_rate": {
      "desc": "QoS2 接收消息速率"
    },
    "message_in_rate": {
      "desc": "接收消息速率"
    },
    "message_qos0_out_rate": {
      "desc": "QoS0 发送消息速率"
    },
    "message_qos2_in_count": {
      "desc": "QoS2 接收消息数量"
    },
    "message_dropped_count": {
      "desc": "丢弃消息数量"
    },
    "topic_metrics_api_response404": {
      "desc": "未找到。主题监控数据未找到"
    },
    "topic_in_path": {
      "desc": "主题字符串。注意：主题字符串在url路径中必须编码"
    },
    "action": {
      "desc": "操作，仅支持 reset"
    },
    "message_qos0_in_count": {
      "desc": "QoS0 接收消息数量"
    },
    "message_qos1_out_rate": {
      "desc": "QoS1 发送消息速率"
    },
    "topic": {
      "desc": "主题"
    },
    "reset_topic_metrics_api": {
      "desc": "重置主题监控状态"
    },
    "create_time": {
      "desc": "创建时间。标准 rfc3339 时间格式，例如：2018-01-01T12:00:00Z"
    },
    "metrics": {
      "desc": "监控数据"
    },
    "message_qos1_out_count": {
      "desc": "QoS1 发送消息数量"
    },
    "gat_topic_metrics_data_api": {
      "desc": "获取主题监控数据"
    },
    "message_qos1_in_count": {
      "desc": "QoS1 接收消息数量"
    },
    "delete_topic_metrics_data_api": {
      "desc": "删除主题监控数据"
    },
    "message_qos0_out_count": {
      "desc": "QoS0 发送消息数量"
    },
    "topic_in_body": {
      "desc": "主题字符串"
    },
    "message_in_count": {
      "desc": "接收消息数量"
    },
    "message_qos2_out_count": {
      "desc": "QoS2 发送消息数量"
    },
    "message_out_rate": {
      "desc": "发送消息速率"
    }
  }
}